# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/5.1_utils.visualization.ipynb (unless otherwise specified).

__all__ = ['logger', 'save_plotly_fig', 'generate_distributions', 'save_gmm_model', 'load_gmm_model', 'setup_data',
           'setup_meshgrid', 'gmm_kl', 'js_dist_from_gmms_samples', 'js_dist_from_gmms_points',
           'plot_data_distribution_2d', 'overlapping_data_points_3d', 'plot_overlapping_distributions_2d',
           'plot_gmm_2d_single_distribution', 'plot_overlapping_gmms', 'plot_gmms_vs_points',
           'plot_gmms_vs_points_sheet', 'plot_kmedoids_decision_boundaries', 'plot_data_distribution', 'plot_gmm_2d',
           'plot_overlapping_features', 'visualize_2D_gmm', 'plot_gmm', 'plot_kmedoids', 'plot_overlapping_gmm',
           'plot_overlapping_and_gmms', 'plot_gmm_1d', 'plot_features', 'plot_clusters']

# Cell

import matplotlib
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import matplotlib.cm as cmx
import matplotlib.patches as patches

import plotly.io as plt_io
import plotly.graph_objects as go
import plotly.offline as pyo
import plotly.express as px
from plotly.subplots import make_subplots

pyo.init_notebook_mode()

import numpy as np

from mpl_toolkits.mplot3d import Axes3D
from matplotlib.colors import ListedColormap, LogNorm

from sklearn.neighbors import KernelDensity
from sklearn.mixture import GaussianMixture

from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, Tuple, List
from collections.abc import Iterable
from .clusterization import *

import pickle

# Configs

import logging

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# Cell

# Util. method for saving pyplot plots and validate output directory

def _save_plot(out_path: str,  file_name: str, file_format: Optional[str]='png'):
    """
    Store pyplot figures veryfing containing directories
    """
    path = Path(out_path)

    if not path.exists():
        path.mkdir(exist_ok=True)

    now = datetime.now()
    ts = datetime.timestamp(now)

    plt.savefig(f"{str(path/file_name)}-{ts}.{file_format}", dpi=100, format=file_format)

# Cell

def save_plotly_fig(fig: go.Figure, out_path: str, fig_name: str, img_fmt: Optional[str]='png',
                    export_additional_svg: Optional[bool]=True):
    """
    Export the given plotly Figure using the specified format

    :param fig: Plotly Figure to be exported
    :param out_path: str specifying the output directory
    :param fig_name: str specifying the name for the img file
    :param img_fmt:  Optional str specifying the format (extension) for the generated file
                     default: png

    """

    path = Path(out_path)
    file_name = f"{fig_name}.{img_fmt}"

    if not path.exists():
        logging.error(f"Figure {file_name} could not be exported,\n{out_path} does not exist.")
        return

    full_path = path / file_name
    fig.write_image(str(full_path),  engine="kaleido")

    logging.info(f"Exported figure at: {str(full_path)}")

    if export_additional_svg:
        file_name = f"{fig_name}.svg"
        full_path = path / file_name
        fig.write_image(str(full_path), engine='kaleido')

        logging.info(f"Exported svg figure at: {str(full_path)}")

# Cell

def _get_plotly_colors():
    """
    Gets a list containing multiple discrete plotly colors as a list
    """
    colors = px.colors.qualitative.Plotly
    colors = px.colors.qualitative.D3
    colors = px.colors.qualitative.Set2
    colors += px.colors.qualitative.Set3
    colors += px.colors.qualitative.Safe
    colors += px.colors.qualitative.Light24
    colors += px.colors.qualitative.Vivid
    colors += px.colors.qualitative.Pastel
    colors += px.colors.qualitative.Pastel1
    colors += px.colors.qualitative.Antique
    colors += px.colors.qualitative.Prism

    return colors

# Cell

# Generate Mixed Gaussian Models with k components

def generate_distributions(feature_vectors, k):
    """
    Generate Mixed Gaussian mixture model with k components
    :param feature_vectors: Data
    :param k: Number of components to get GMM
    :return: sklearn GMM
    """
    gmm = GaussianMixture(k, covariance_type="diag")
    gmm.fit(feature_vectors)

    return gmm

# Cell

def save_gmm_model(gmm_model, out_path):
    """
    :param gmm_model: sklearn GMM model to be saved
    :param out_path: str indicating the full path (including gmm model's name)
    """
    np.save(out_path + '_weights', gmm_model.weights_)
    np.save(out_path + '_means', gmm_model.means_)
    np.save(out_path + '_covariances', gmm_model.covariances_)

def load_gmm_model(path):
    """
    Load an sklearn GMM model from the specified path
    :path: str indicating the full path containing GMM data

    :return: sklearn GMM model with the saved data
    """
    means = np.load(path + '_means.npy')
    covar = np.load(path + '_covariances.npy')
    loaded_gmm = GaussianMixture(n_components = len(means), covariance_type='full')
    loaded_gmm.precisions_cholesky_ = np.linalg.cholesky(np.linalg.inv(covar))
    loaded_gmm.weights_ = np.load(path + '_weights.npy')
    loaded_gmm.means_ = means
    loaded_gmm.covariances_ = covar

    return loaded_gmm

# Cell

def setup_data(cluster):
    """
    Get decision boundaries by means of np.meshgrid

    :return: Tuple (vectors, centroids, X component of mesghgrid, Y component of meshgrid, )
    """
    feature_vectors, _, centroids, _, kmeans = cluster
    # Step size of the mesh. Decrease to increase the quality of the VQ.
    h = .2     # point in the mesh [x_min, x_max]x[y_min, y_max].

    # Plot the decision boundary. For that, we will assign a color to each
    x_min, x_max = feature_vectors[:, 0].min() - 1, feature_vectors[:, 0].max() + 1
    y_min, y_max = feature_vectors[:, 1].min() - 1, feature_vectors[:, 1].max() + 1
    xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))

    Z = kmeans.predict(np.c_[xx.ravel(), yy.ravel()])
    Z = Z.reshape(xx.shape)

    return feature_vectors, centroids, xx, yy, Z

# Cell

def setup_meshgrid(cluster, h=0.05):
    vectors, _, medoid_ids, kmedoids = cluster
    medoids = np.array([vectors[i] for i in medoid_ids])
    # h = .8     # point in the mesh [x_min, x_max]x[y_min, y_max].

    # Plot the decision boundary. For that, we will assign a color to each
    x_min, x_max = vectors[:, 0].min() - 1, vectors[:, 0].max() + 1
    y_min, y_max = vectors[:, 1].min() - 1, vectors[:, 1].max() + 1

    xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h)) # np.meshgrid(np.arange(-10, 10, h), np.arange(-10, 10, h))

    Z = kmedoids.predict(np.c_[xx.ravel(), yy.ravel()])
    Z = Z.reshape(xx.shape)

    y_ = np.arange(y_min, y_max, h)

    return vectors, medoids, xx, yy, Z, y_

# Cell

# Change to providing it the actual samples from the distribution instead of sampling from it

def gmm_kl(gmm_p, gmm_q, n_samples=10**5):
    """
    Compute the KL-divergence value for 2 given
    Gaussian Mixture models

    :param gmm_p: 1st GMM model
    :param gmm_q: 2nd GMM model

    :return: Float indicating KL-divergence value
    """
    # From https://stackoverflow.com/a/26079963/5768407
    X = gmm_p.sample(n_samples)[0]
    log_p_X = gmm_p.score_samples(X)
    log_q_X = gmm_q.score_samples(X)
    return log_p_X.mean() - log_q_X.mean()

# Cell

def js_dist_from_gmms_samples(gmm_p, gmm_q, n_samples=5000):
    """
    Compute JS divergence & distance from provided GMM models by sampling
    """
    # Just take the vector component of the returned tuple
    # Ignore the component label
    X = gmm_p.sample(n_samples)[0]
    log_p_X = gmm_p.score_samples(X)
    log_q_X = gmm_q.score_samples(X)
    log_mix_X = np.logaddexp(log_p_X, log_q_X)

    # Just take the vector component of the returned tuple
    # Ignore the component label
    Y = gmm_q.sample(n_samples)[0]
    log_p_Y = gmm_p.score_samples(Y)
    log_q_Y = gmm_q.score_samples(Y)
    log_mix_Y = np.logaddexp(log_p_Y, log_q_Y)
    js_div = (log_p_X.mean() - (log_mix_X.mean() - np.log(2))
              + log_q_Y.mean() - (log_mix_Y.mean() - np.log(2))) / 2
    js_dist = np.sqrt(js_div)
    return js_div, js_dist

# Cell

def js_dist_from_gmms_points(gmm_p, gmm_q, ft_vect1, ft_vect2):
    """
    Compute JS divergence & distance from provided GMM models and
    points by scoring (real points)
    """
    X = ft_vect1
    log_p_X = gmm_p.score(X)
    log_q_X = gmm_q.score(X)
    log_mix_X = np.logaddexp(log_p_X, log_q_X)

    Y = ft_vect2
    log_p_Y = gmm_p.score(Y)
    log_q_Y = gmm_q.score(Y)
    log_mix_Y = np.logaddexp(log_p_Y, log_q_Y)
    js_div = (log_p_X.mean() - (log_mix_X.mean() - np.log(2))
              + log_q_Y.mean() - (log_mix_Y.mean() - np.log(2))) / 2
    js_dist = np.sqrt(js_div)
    return js_div, js_dist

# Cell

def plot_data_distribution_2d(feat_vectors: np.ndarray,
                               dist_name: str,
                               out_path: str,
                               color: Optional[str]="lightskyblue",
                               img_fmt: Optional[str]="png",
                               show: Optional[bool]=True,
                               export: Optional[bool]=False):
    """
    Plot the data distribution reduced using UMAP (2 dimensions)

    :param feat_vectors: Vectors containing data to be plotted
    :param dist_name: String identifying the data distribution
    :param out_path: String specifying the location to store the generated figures
    :param color: String indicating the color of markers (according to plotly), default=lightskyblue
    :param img_fmt: Format of the exported img file
    :param show: (Optional) Bool indicating whether or not show the plot, default=True
    :param export: (Optional) Bool indicating whether or not export the figure, default=False
    """


    x1 = feat_vectors[:, 0]
    x2 = feat_vectors[:, 1]

    layout = go.Layout(
        title=f"Data distribution for {dist_name}",
        xaxis=dict(
            title="UMAP Dim.1"
        ),
        yaxis=dict(
            title="UMAP Dim.2"
        )
    )
    fig = go.Figure(data=go.Scatter(
        x = x1,
        y = x2,
        mode='markers',
        marker=dict(
            size=8,
            line_width=1,
            color=color

        )
    ), layout=layout)

    fig.update_layout(margin=dict( l=100,r=100,b=100,t=100),width=1000,height=600)
    fig.layout.template = 'plotly_white'

    if show:
        fig.show()

    if export:
        save_plotly_fig(fig, out_path, fig_name=f'DataDistribution{dist_name}', img_fmt=img_fmt)

# Cell

def overlapping_data_points_3d(feat_vectors1: np.ndarray,
                               feat_vectors2: np.ndarray,
                               dist1_name: str, dist2_name: str,
                               out_path: str,
                               color: Optional[List[str]]=["lightskyblue", "khaki"],
                               img_fmt: Optional[str]="png",
                               show: Optional[bool]=True, export: Optional[bool]=False):
    """
    Plot 3D scatter for 2 data points distribution
    :param feat_vectors1: np.ndarray containing dist. 1 vectors
    :param feat_vectors2: np.ndarray containing dist. 2 vectors
    :param dist1_name: str indicating the name for 1st dist.
    :param dist2_name: str indicating the name for 1st dist.
    :param out_path: str indicating output directory for generated figures
    :param color: Optional[List[str]] indicating colors for scatter points
                  Default: ["lightskyblue", "khaki"]
    :param img_fmt: Optional[str] indicating format for exported files
                    Default: 'png'
    :param show: Optional[bool] indicating whether show figures or not
    :param export: Optional[bool] indicating whether export figures or not
    """

    layout = go.Layout(
        title=f"Data distributions for {dist1_name} - {dist2_name}",
        xaxis=dict(
            title="UMAP Dim.1"
        ),
        yaxis=dict(
            title="UMAP Dim.2"
        ),
        zaxis=dict(
            title="UMAP Dim.3"
        )
    )

    fig = go.Figure(layout=layout)

    # Plot 1st distribution
    x = feat_vectors1[:, 0]
    y = feat_vectors1[:, 1]
    z = feat_vectors1[:, 2]

    fig.add_trace(
        go.Scatter3d(
            x=x, y=y, z=z,
            mode='markers'
        )
    )

    # Plot 2nd distribution
    x = feat_vectors2[:, 0]
    y = feat_vectors2[:, 1]
    z = feat_vectors2[2:, 2]

    fig.add_trace(
        go.Scatter3d(
            x=x, y=y, z=z,
            mode='markers'
        )
    )

    if show:
        fig.show()
    if export:
        save_plotly_fig(
            fig, out_path,
            fig_name=f'3D-Data_distributions_{dist1_name}_{dist2_name}',
            img_fmt=img_fmt
        )

# Cell

def plot_overlapping_distributions_2d(clusters,
                                       out_path: str,
                                       colors: Optional[List]=['khaki', 'lightcyan'],
                                       img_fmt: Optional[str]='png',
                                       export: Optional[bool]=False,
                                       show: Optional[bool]=True,
                                      ):
    """
    Plot the distributions for 2 given distributions.
    The distributions are asumed to be obtained via UMAP reduction (2 dimensions)

    :param clusters: Dictionary containing cluster-related data for 2 distributions
    :param out_path: Location to export the image file
    :param colors: (Optional) List containing the 2 colors to represent the data distributions,
                    default: ['khaki', 'lightcyan']
    :param img_fmt: (Optional) File format for the exported file, default: png
    :param export: (Optional) Boolean indicating whether or not export file, default: False
    :param show: (Optional) Boolean indicating whether show the image
    """

    fig = go.Figure()
    models = list(clusters.keys())

    for i, model in enumerate(clusters):
        feat_vectors, _, _, _ = clusters[model]
        fig.add_trace(go.Scatter(
            x = feat_vectors[:, 0],
            y = feat_vectors[:, 1],
            mode='markers',
            marker=dict(
                size=5,
                line_width=0.8,
                color=colors[i]
            ),
            name=model
        ))


    fig.update_layout(
        legend=dict(
            yanchor="top",
            # y=0.99,
            xanchor="left",
            #x=0.01
        ),
        title=f'Overlapping distributions for {models[0]} - {models[1]}',
        xaxis=dict(
            title="UMAP Dim.1"
        ),
        yaxis=dict(
            title="UMAP Dim.2"
        )
    )
    fig.layout.template = 'plotly_white'

    if show:
        fig.show()

    if export:
        save_plotly_fig(fig, out_path, f"Overlap-distr-{models[0]}-{models[1]}", img_fmt=img_fmt)

# Cell

def _visualize_gmm_2d(points, w, mu, stdev, model_id, fig,
                      export: Optional[bool]=False,
                      fixed_color: Optional[str]=None,
                      label_name: Optional[str]=None
                     ):
    """
    Plot the GMMs for a given model

    :param points: Vectors of reduced data
    :param w:
    :param: mu:
    :param stdev:
    :param model_id:
    :param export: Optional[bool] indicating whether or not export the figure
    :param fixed_color: Optional[str] indicating the color to apply to all generated GMMs
                        representations (ellipses)

    """
    showlegend = label_name is not None
    colors = _get_plotly_colors()

    n_gaussians = mu.shape[1]

    if n_gaussians > len(colors):
        msg = "Cannot plot the provided ammount of GMMs"
        logging.error(msg)
        raise Exception(msg)

    N = int(np.round(points.shape[0]/n_gaussians))

    for i in range(n_gaussians):
        shape_name = label_name if i < 1 else None
        for j in range(4):
            center = mu[:, i]
            std1 = stdev[0, i]
            std2 = stdev[1, i]

            width = (j+1) * stdev[0, i]
            height = (j+1) *  stdev[1, i]

            # print(f"center: {center}, std1: {std1}, std2: {std2}")

            x0 = center[0] - (width/2)
            x1 = center[0] + (width/2)
            y0 = center[1] - (height/2)
            y1 = center[1] + (height/2)

            gmm_color = fixed_color if fixed_color is not None else colors[i]

            fig.add_shape(
                type="circle",
                xref="x", yref="y",
                x0=x0, y0=y0, x1=x1, y1=y1,
                fillcolor=gmm_color,
                opacity=0.4,
                line=dict(color=gmm_color, width=12),
                name=shape_name
            )

    fig.update_layout(
        margin=dict(l=20, r=20, b=100),
        height=700, width=700
    )

    return fig

# Cell

def plot_gmm_2d_single_distribution(cluster_data: Tuple, model: str,
                                    out_path: str, export: Optional[bool]=False,
                                    show: Optional[bool]=True, img_fmt: Optional[str]="png",
                                   ):
    """
    Plot a single distribution of datapoints alongside with the calculated GMMs

    :param cluster_data: Tuple containing the data for a cluster (vectors, _, centroids, _)
    :param model: Str indicating the name of the distribution
    :param out_path: Str indicating the location for the generated figure
    :param export: Optional[bool] indicating whether or not to export the figure

    """
    gmms = {}
    feat_vectors, _, centroid_ids, _ = cluster_data

    fig = go.Figure(data=go.Scatter(
        x = feat_vectors[:, 0],
        y =  feat_vectors[:, 1],
        mode='markers',
        marker=dict(
            size=5,
            line_width=0.4,
            color='rgb(255, 255, 204)'
            )
        ),
        layout=dict(
            title=f"Gaussian Mixture Models for {model}",
            xaxis=dict(
                title="UMAP Dim.1"
            ),
            yaxis=dict(
                title="UMAP Dim.2"
            )
        )
    )

    gmm = generate_distributions(feat_vectors, len(centroid_ids))
    gmms[model] = gmm

    fig = _visualize_gmm_2d(feat_vectors, gmm.weights_, gmm.means_.T, np.sqrt(gmm.covariances_).T, model, fig)

    if show:
        fig.show()

    if export:
        save_plotly_fig(fig, out_path, f"GMM-{model}", img_fmt=img_fmt)

# Matplotlib implementation
#     plt.figure(figsize = (8, 8))
#     plt.title(f'Gaussian Mixture Models for {model}')
#     plt.plot(feat_vectors[:, 0], feat_vectors[:, 1], 'c.', markersize = 4, zorder = -1)

#     __visualize_2D_gmm(feat_vectors, gmm.weights_, gmm.means_.T, np.sqrt(gmm.covariances_).T, model, 'blue')

#     x_min = feat_vectors[:, 0].min() - 1
#     x_max = feat_vectors[:, 0].max() + 1

#     y_min = feat_vectors[:, 1].min() - 1
#     y_max = feat_vectors[:, 1].max() + 1

#     plt.xlim(x_min, x_max)
#     plt.ylim(y_min, y_max)

#     plt.grid(True)

# Cell

def plot_overlapping_gmms(clusters: Dict, out_path: str,
                          sample_set1_name: str, sample_set2_name: str,
                          export: Optional[bool]=False, img_fmt: Optional[str]="png",
                          show: Optional[bool]=True, scatter_colors: Optional[List]=['palegreen', 'lightskyblue'],
                          gmm_colors: Optional[List]=['rgb(242, 183, 1)', 'rgb(231, 41, 138)']) -> Tuple[float, float]:
    """
    Plot the overlapping distributions/GMMS for a couple of sample sets

    :param cluster: Dictionary containing cluster data for 2 sample sets
    :param out_path: Location to store generated figures
    :param export: Optional[bool] indicating whether or not to store the figures
    :param scatter_colors: Optional[List] indicating colors for plotting distribution datapoints
    :param gmm_color: Optional[List] indicating colors for plotting GMMs data
    :param sample_set1_name: str indicating the sample set name being compared (from model)
    :param sample_set2name: str indicating the sample set name being compared (from human)

    :return: Tuple(float, float) containing KL divergence computation for the givent distributions
    """
    gmms = {}

    models = list(clusters.keys())
    model1 = models[0]
    model2 = models[1]

    fig = go.Figure(layout=dict(title=f"Overlapping GMMs {sample_set1_name}-{sample_set2_name}"))

    for i, model in enumerate(clusters):
        feat_vectors, _, centroid_ids, _ = clusters[model]
        fig.add_trace(go.Scatter(
            name=model,
            x = feat_vectors[:, 0],
            y =  feat_vectors[:, 1],
            mode='markers',
            marker=dict(
                size=5,
                line_width=0.4,
                color=scatter_colors[i]
                )
            )
         )

        gmm = generate_distributions(feat_vectors, len(centroid_ids))

        prototypes = feat_vectors[centroid_ids]

        fig.add_trace(go.Scatter(
            name=f'GMMs for {model}',
            x = prototypes[:, 0],
            y = prototypes[:, 1],
            mode='markers',
            marker=dict(
                size=10,
                line_width=0.8,
                color=gmm_colors[i]
                )
        ))

        gmms[model] = gmm

        fig = _visualize_gmm_2d(feat_vectors, gmm.weights_, gmm.means_.T, np.sqrt(gmm.covariances_).T, model, fig,
                                 fixed_color=gmm_colors[i])

    if show:
        fig.show()

    if export:
        save_plotly_fig(fig, out_path, f"Overlapping-gmms-{sample_set1_name}-{sample_set2_name}", img_fmt=img_fmt)

    # Compute JS divergence
    js_div_samples, js_dist_samples = js_dist_from_gmms_samples(gmms[model1], gmms[model2])

    ft_vect1, _, _, _ = clusters[model1]
    ft_vect2, _, _, _ = clusters[model2]
    js_div_points, js_dist_points = js_dist_from_gmms_points(gmms[model1], gmms[model2], ft_vect1, ft_vect2)

    return js_div_samples, js_dist_samples, js_div_points, js_dist_points

# Cell

def plot_gmms_vs_points(points_data: Tuple, distribution_data: Tuple,
                        distribution_name: str, points_name: str,
                        out_path: str,
                        show: Optional[bool]=True, export: Optional[bool]=False,
                        img_fmt: Optional[str]='png',
                        mkrs_colors: Optional[List[str]]=["khaki", "lightcoral", "red"],
                        scatter_colors: Optional[List]=['palegreen', 'lightskyblue'],
                        gmm_color: Optional[str]='rgb(242, 183, 1)',
                        gmm_path: Optional[str]=None,
                        gmm_shapes_path: Optional[str]=None,
                        use_gmm_model: Optional[bool]=True,
                        plot_dist_points: Optional[bool]=True,
                        compute_crits: Optional[bool]=True,
                        add_labels: Optional[bool]=True
                       ) -> Tuple:
    """
    Plot distribution (GMM-based) vs points for 2 given sample sets data

    :return: Tuple(traces, shapes)
    """
    fig = go.Figure()
    fig_traces = []
    feat_vectors, _, centroid_ids_dist, _ = distribution_data

    # Handle GMM model & plot GMM-based distribution
    # ----------------------------------------------------------------------
    logging.info('Handling distribution plots...')
    shapes_path = str(Path(out_path) / f"gmm-shapes{distribution_name}-{points_name}")
    if use_gmm_model:
        if gmm_path is None:
            logging.info('Generating GMM model...')
            gmm = generate_distributions(feat_vectors, len(centroid_ids_dist))
            gmm_model_path = Path(out_path) / f'gmm-{distribution_name}-{points_name}'
            save_gmm_model(gmm, str(gmm_model_path))
        else:
            logging.info('Loading GMM model...')
            gmm = load_gmm_model(gmm_path)

        gmm_plot_name = f"GMMs for {distribution_name}" if add_labels else None

        fig = _visualize_gmm_2d(
            feat_vectors, gmm.weights_, gmm.means_.T, np.sqrt(gmm.covariances_).T,
            distribution_name, fig, fixed_color=gmm_color, label_name=gmm_plot_name
        )
        # Save GMM shapes
        fig_shapes = fig.layout.shapes
        with open(f'{shapes_path}.pkl', 'wb') as f:
            pickle.dump(fig.layout.shapes, f)
    else:
        logging.info('Loading shapes data...')
        # Just load gmm shapes
        with open(f'{shapes_path}.pkl', 'rb') as f:
            fig_shapes = pickle.load(f)
    # ----------------------------------------------------------------------
    # Plot datapoints to verify GMMs shown distribution
    if plot_dist_points:
        gmm_points_trace_name = "Compared distribution" if add_labels else None
        gmm_points_trace = go.Scatter(
            name=gmm_points_trace_name,
            showlegend=add_labels,
            x=feat_vectors[:, 0],
            y=feat_vectors[:, 1],
            mode='markers',
            marker=dict(
                size=2.8,
                line_width=0.4,
                color=scatter_colors[1]
            )
        )

        fig.add_trace(gmm_points_trace)
        fig_traces.append(gmm_points_trace)

    # ----------------------------------------------------------------------
    # Plot points data
    # Points distribution
    logging.info('Handling points plots...')
    point_vectors, _, point_centroid_ids, _ = points_data
    points_trace_name = "Generated samples" if add_labels else None
    points_trace = go.Scatter(
        name=points_trace_name,
        showlegend=add_labels,
        x = point_vectors[:, 0],
        y =  point_vectors[:, 1],
        mode='markers',
        marker=dict(
            size=4,
            line_width=0.4,
            color=scatter_colors[0]
        )
    )

    # Prototypes (cluster centroids)
    centroids = np.array([point_vectors[i] for i in point_centroid_ids])
    proto_trace_name = "Prototypes" if add_labels else None
    proto_trace = go.Scatter(
        x=centroids[:, 0],
        y=centroids[:, 1],
        mode='markers',
        marker=dict(
            size=15,
            color=mkrs_colors[1],
            line=dict(color='black', width=1.2),
            symbol='octagon-dot'
        ),
        name=proto_trace_name,
        showlegend=add_labels
    )
    # Criticisms
    crits_path = str(Path(out_path) / f"{points_name}-crits_ix")
    if compute_crits:
        _, crit_ids = gen_criticisms(point_vectors, centroids)
        np.save(crits_path, crit_ids)
    else:
        crit_ids = np.load(f"{crits_path}.npy")

    crit_points = np.take(point_vectors, crit_ids, axis=0)
    crit_trace_name = "Criticisms" if add_labels else None
    crit_trace = go.Scatter(
        x = crit_points[:, 0],
        y = crit_points[:, 1],
        mode='markers',
        marker=dict(
            size=14,
            color=mkrs_colors[2],
            line=dict(color='black', width=0.9),
            symbol='x-dot'
        ),
        name=crit_trace_name,
        showlegend=add_labels
    )

    fig.add_trace(points_trace)
    fig.add_trace(proto_trace)
    fig.add_trace(crit_trace)

    fig_traces.append(points_trace)
    fig_traces.append(proto_trace)
    fig_traces.append(crit_trace)

    fig.update_layout(
        legend=dict(
            yanchor="top",
            xanchor="left",
        ),
        title=f'Prototypes & criticisims for {points_name}',
        xaxis=dict(
            title="UMAP Dim.1"
        ),
        yaxis=dict(
            title="UMAP Dim.2"
        )
    )

    if show:
        fig.show()

    if export:
        save_plotly_fig(fig, out_path, f"GMM-{distribution_name}-vs-Points-{points_name}", img_fmt=img_fmt)

    return fig_traces, fig_shapes

# Cell

def plot_gmms_vs_points_sheet(sheet_titles: Tuple, n_experiments: int, fig_info: List,
                              out_path: str, fig_name: str,
                              show: Optional[bool]=True, export: Optional[bool]=False,
                              img_fmt: Optional[str]='png',
                              split_plot: Optional[bool]=True
                             ):
    """
    Plot sheet (grid) to summarize prototypes and crits. results

    :param sheet_titles: Tuple[str] containing title for individual plots
    :param n_experiments: int indicating number
    :param fig_info: List[Tuple] containing [traces, shapes] for each experiment
    :param out_path: str indicating path to save generated figures
    :param fig_name: str indicating name for exported figure
    :param show: bool indicating whether or not to show figures
    :param export: bool indicating whether or not to export figures
    :param img_fmt: str indicating format of generated files
    """
    n_rows = 3
    n_cols = 5
    half_experiments = int(n_experiments/2)

    fig = make_subplots(
        rows=n_rows, cols=n_cols,
        subplot_titles=sheet_titles[:half_experiments]
    )

    fig2 = make_subplots(
        rows=n_rows, cols=n_cols,
        subplot_titles=sheet_titles[half_experiments:]
    )

    for i in range(half_experiments):
        current_row = int(i / n_cols) + 1
        current_col = (i % n_cols) + 1

        traces, shapes = fig_info[i]

        # Points, Prots & Crits
        for trace in traces:
            fig.add_trace(trace, row=current_row, col=current_col)

        # GMM shapes
        for shape in shapes:
            fig.add_shape(shape, row=current_row, col=current_col)

    fig.update_layout(title_text=f"Prototypes-Criticisms for {fig_name}",
                      height=1100, width=1920,
                      hovermode=False)


    fig.update_xaxes(range=[-25, 25])
    fig.update_yaxes(range=[-25, 25])

    row_ix = 0
    for i in range(half_experiments, n_experiments):
        current_row = int(row_ix / n_cols) + 1
        current_col = (row_ix % n_cols) + 1

        traces, shapes = fig_info[i]

        # Points, Prots & Crits
        for trace in traces:
            fig2.add_trace(trace, row=current_row, col=current_col)

        # GMM shapes
        for shape in shapes:
            fig2.add_shape(shape, row=current_row, col=current_col)

        row_ix += 1

    fig2.update_layout(title_text=f"Prototypes-Criticisms for {fig_name}",
                      height=1100, width=1920,
                      hovermode=False)


    fig2.update_xaxes(range=[-25, 25])
    fig2.update_yaxes(range=[-25, 25])

    if show:
        fig.show()
        fig2.show()

    if export:
        save_plotly_fig(fig, out_path, f"{fig_name}-sheet1", img_fmt=img_fmt)
        save_plotly_fig(fig2, out_path, f"{fig_name}-sheet2", img_fmt=img_fmt)

# Cell

def plot_kmedoids_decision_boundaries(cluster: Tuple, model: str,
                                       out_path: str,
                                       bound_h: Optional[float]=0.02,
                                       colorscale: Optional[str]="teal",
                                       mkrs_colors: Optional[List[str]]=["khaki", "lightcoral", "red"],
                                       img_fmt: Optional[str]="png",
                                       show: Optional[bool]=True,
                                       export: Optional[bool]=False):
    """
    Plot the decision boundaries for the clusters obtained via k-medoids

    :param cluster: Tuple containing cluster data
    :param model: Str identifying the model
    :param out_path: Str indicating the location for the exported plot
    :param bound_h: (Optional) float indicating the interpolation param for plotting the decision boundaries
    :param colorscale: (Optional) Str indicating the color for the decision boundaries
    :param mkrs_colors: (Optional) List indicating the colors for markers: data, centroids, criticisms
    :param img_fmt: (Optional) Str indicating the file format for the stored image
    :param show: (Optional) Bool indicating whether or not to show the plot
    :param export: (Optional) Bool indicating whether or not to export the plot
    """
    feat_vectors, centroids, xx, yy, Z, y_ = setup_meshgrid(cluster, h=bound_h)
    _, crit_ids = gen_criticisms(feat_vectors, centroids)

    fig = go.Figure()

    boundaries_trace = go.Heatmap(x=xx[0], y=y_, z=Z,
                  colorscale=colorscale,
                  showscale=False)

    # Data points
    data_trace = go.Scatter(
        x=feat_vectors[:, 0],
        y=feat_vectors[:, 1],
        mode='markers',
        marker=dict(
            size=6,
            color=mkrs_colors[0],
            line=dict(color='black', width=0.2)
        ),
        name=f"{model} Data distribution"
    )

    # Prototypes (cluster centroids)
    proto_trace = go.Scatter(
        x=centroids[:, 0],
        y=centroids[:, 1],
        mode='markers',
        marker=dict(
            size=15,
            color=mkrs_colors[1],
            line=dict(color='black', width=1.2),
            symbol='octagon-dot'
        ),
        name="Prototypes"
    )



    # Criticisms
    crit_points = np.take(feat_vectors, crit_ids, axis=0)

    crit_trace = go.Scatter(
        x = crit_points[:, 0],
        y = crit_points[:, 1],
        mode='markers',
        marker=dict(
            size=14,
            color=mkrs_colors[2],
            line=dict(color='black', width=0.9),
            symbol='x-dot'
        ),
        name="Criticisms"
    )

    fig.add_trace(boundaries_trace)
    fig.add_trace(data_trace)
    fig.add_trace(proto_trace)
    fig.add_trace(crit_trace)

    fig.update_layout(
        legend=dict(
            yanchor="top",
            xanchor="left",
        ),
        title=f'Prototypes & criticisims for {model}',
        xaxis=dict(
            title="UMAP Dim.1"
        ),
        yaxis=dict(
            title="UMAP Dim.2"
        )
    )

    if show:
        # py.iplot(fig)
        fig.show()

    if export:
        save_plotly_fig(fig, out_path, f"DecisionBoundaries-distr-{model}", img_fmt=img_fmt)

# Cell

# Note the use of plot instead of scatter for clearer plots

def plot_data_distribution(feat_vectors: np.ndarray, model: str,
                             out_path: str,
                             color: Optional[str]='c.',
                             export: Optional[bool]=False):
    """
    Plot the data distribution of the provided vectors
    :param feat_vectors:
    :param model:
    :param out_path:
    :param color:
    :param export:

    """

    plt.figure(figsize=(8, 8))
    plt.title(f"Data Distribution for {model}")

    plt.plot(feat_vectors[:, 0], feat_vectors[:, 1], color, markersize = 4, zorder = -1)

    if export:
        _save_plot(out_path, f"Data-distribution-{model}")

# Cell

def plot_gmm_2d(clusters: Dict, out_path: str, export = False):
    plt.figure(figsize=(12, 8))
    # Create 2x2 sub plots
    gs = gridspec.GridSpec(1, 2)
    plt.clf()
    for i, model in enumerate(clusters):
        samples, _, medoid_ids, _ = clusters[model]
        gmm = generate_distributions(samples, len(medoid_ids))

        # Plot Data
        plt.subplot(gs[0, i])
        visualize_2D_gmm(samples, gmm.weights_, gmm.means_.T, np.sqrt(gmm.covariances_).T, i)

    if export:
        _save_plot(out_path, f"2D_GMM_{model}")
    plt.show()

# Cell

def plot_overlapping_features(clusters: Dict,
                              out_path: str, colmap: Optional[Dict]={0: 'c.', 1: 'm.', 2: 'y.'},
                              lim: Optional[int]=10, export: Optional[bool]=False):
    """
    Plot the distribution for 2 sets of samples

    :param clusters: Dict containing cluster info. for 2 distributions
    :param out_path: Str indicating the location for storing generated figures
    :param colmap: Dict specifying colors for plots
    :param lim: int
    :param export: Bool indicating whether or not to store generated figure
    """
    plt.figure(figsize=(8, 8))
    plt.title(f'Overlapping features for {" and ".join(clusters.keys())} samples. \n')
    for i, model in enumerate(clusters):
        samples, _, _, _ = clusters[model]
        plt.plot(samples[:, 0], samples[:, 1], colmap[i], markersize = 4)

        plt.xlabel('T-SNE Dim 1')
        plt.ylabel('T-SNE Dim 2')

    plt.xlim(-lim, lim)
    plt.ylim(-lim, lim)
    plt.legend(clusters.keys())
    plt.grid(True)

    if export:
        _save_plot(out_path, f'overlapping_features_{"_".join(clusters.keys())}')

# Cell

# From http://www.itzikbs.com/gaussian-mixture-model-gmm-3d-point-cloud-classification-primer
def visualize_2D_gmm(points, w, mu, stdev, model_id, c, export=False):
    '''
    plots points and their corresponding gmm model in 2D
    Input:
        points: N X 2, sampled points
        w: n_gaussians, gmm weights
        mu: 2 X n_gaussians, gmm means
        stdev: 2 X n_gaussians, gmm standard deviation (assuming diagonal covariance matrix)
    Output:
        None
    '''
    n_gaussians = mu.shape[1]
    N = int(np.round(points.shape[0] / n_gaussians))
    # Visualize data
    axes = plt.gca()
    colors = cmx.Accent(np.linspace(0, 1, n_gaussians)) if id == 'human' else cmx.Paired(np.linspace(0, 1, n_gaussians))
    for i in range(n_gaussians):
        idx = range(i * N, (i + 1) * N)
        for j in range(4):
            axes.add_patch(
                patches.Ellipse(mu[:, i], width=(j+1) * stdev[0, i], height=(j+1) *  stdev[1, i], alpha = 0.4, fill=True, color=colors[i]))
    plt.xlabel('Dim 1')
    plt.ylabel('Dim 2')

# Cell

def plot_gmm(cluster: Dict, model: str, c, out_path: str, export: Optional[bool]=True):
    """
    Plot Gaussian Mixture models for an individual set of samples

    :param cluster:
    :param model:
    :param c:
    :param out_path:
    :param export: Bool indicating whether or not store the generated figure
    """
    plt.figure(figsize = (8, 8))
    plt.title(f'Gaussian Mixture Models for {model} samples.\n')

    samples, _, medoid_ids, _ = cluster
    plt.plot(samples[:, 0], samples[:, 1], c, markersize = 4, zorder = -1)
    gmm = generate_distributions(samples, len(medoid_ids))

    # Plot Data
    visualize_2D_gmm(samples, gmm.weights_, gmm.means_.T, np.sqrt(gmm.covariances_).T, model, c)
    plt.xlim(-10, 10)
    plt.ylim(-10, 10)
    plt.legend([model])
    plt.grid(True)

    if export:
        _save_plot(out_path, f"gmm_{model}")

# Cell

def plot_kmedoids(cluster, model,
                  cmap = ListedColormap(["whitesmoke", "lightgrey", 'darkgrey', 'dimgrey', 'black']),
                  cm = 'c.', lim = 10, export = True):
    plt.figure(figsize=(8, 8))
    samples, centroids, xx, yy, Z = setup_meshgrid(cluster, lim)
    _, crit_ids = gen_criticisms(samples, centroids)
    plt.imshow(
        Z, interpolation='nearest',
        extent = (xx.min(), xx.max(), yy.min(), yy.max()),
        cmap = cmap, aspect = 'auto', origin = 'lower'
    )
    plt.plot(samples[:, 0], samples[:, 1], cm, markersize = 4)
    plt.scatter(
        centroids[:, 0], centroids[:, 1],
        marker = 'o', s = 64, linewidths = 3,
        color = 'b', zorder = 10
    )
    for crit_id in crit_ids:
        plt.scatter(
            samples[crit_id, 0], samples[crit_id, 1],
            marker = 'x', s = 64, linewidths = 3, color = 'r',
            zorder = 10
        )
    plt.title(
        f'K-Medoids clustering via\n'
        f'(PCA & T-SNE - reduced data) for {model} testbed\n'
    )
    plt.xlim(-lim, lim)
    plt.ylim(-lim, lim)
    plt.xlabel('T-SNE Dim 1')
    plt.ylabel('T-SNE Dim 2')
    plt.legend([model, 'prototypes', 'criticisms'])
    plt.grid(True)

    if export:
        plt.savefig(f'/tf/data/graphics/k-medoids_{model}.png', dpi=100, format='png')

# Cell

def plot_overlapping_gmm(clusters: Dict, out_path: str,
                         colmap: Optional = {0: 'c.', 1: 'm.', 2: 'y.'},
                         lim: Optional[float]=10.0, export: Optional[bool]=True):
    """
    Plot the comparison between 2 distributions: Includes overlapping distributions
    and GMMs

    :param clusters: Dict containing clusters data for 2 distributions
    :param colmap: Dict indicating colors for datapoints
    :param lim: Float indicating the limit value for the plots
    :param export: Bool indicating whether or not save the generated figure

    """
    plt.figure(figsize = (8, 8))
    plt.title(f'Gaussian Mixture Models for {" and ".join(clusters.keys())} samples.\n')

    gmms = {}
    cs = ['c', 'g', 'm', 'y']
    sets = []
    for i, model in enumerate(clusters):
        samples, _, medoid_ids, _ = clusters[model]
        plt.plot(samples[:, 0], samples[:, 1], colmap[i], markersize = 4, zorder = -1)
        gmm = generate_distributions(samples, len(medoid_ids))
        gmms[model] = gmm

        # Plot Data
        visualize_2D_gmm(samples, gmm.weights_, gmm.means_.T, np.sqrt(gmm.covariances_).T, model, cs[i])
    plt.xlim(-lim, lim)
    plt.ylim(-lim, lim)
    plt.legend(clusters.keys())
    plt.grid(True)

    if export:
        _save_plot(out_path, f"overlapping_gmm_{'_'.join(clusters.keys())}")

# Cell


def plot_overlapping_and_gmms(clusters: Dict, out_path: str, export: Optional[bool]=True) -> Tuple[float, float]:
    """
    Separately plot the overlapping distribution the GMM models for 2 given sample sets

    :param clusters: Dict. containing clusters info.
    :param export: Bool indicating whether or not store the generated figure

    :return: Tuple (KL div. dist1-dist2, KL div. dist2-dist1)
    """
    plt.figure(figsize=(12, 8))
    # Create 2x2 sub plots
    gs = gridspec.GridSpec(2, 2)
    plt.clf()

    plt.subplot(gs[1, 0])
    colmap = {0: 'co', 1: 'mo'}

    models = list(clusters.keys())
    plt.title(f'Overlapping distributions\nCyan denotes {models[0]} samples and \
    \nMagenta denotes {models[1]} samples.')

    for i, model in enumerate(clusters):
        samples, _, _, _ = clusters[model]
        plt.plot(samples[:, 0], samples[:, 1], colmap[i], markersize=2)
        plt.xlim(-10, 10)
        plt.ylim(-10, 10)
        plt.xlabel('T-SNE Dim 1')
        plt.ylabel('T-SNE Dim 2')

    plt.subplot(gs[1, 1])
    plt.xlim(-10, 10)
    plt.ylim(-10, 10)
    gmms = {}
    cs = ['c', 'm']
    sets = []
    for i, model in enumerate(clusters):
        samples, _, medoid_ids, _ = clusters[model]
        gmm = generate_distributions(samples, len(medoid_ids))
        gmms[model] = gmm

        # Plot Data
        visualize_2D_gmm(samples, gmm.weights_, gmm.means_.T, np.sqrt(gmm.covariances_).T, model, cs[i])

    # Compute Kl divergence

    dist1_to_dist2_kl = gmm_kl(gmms[models[0]], gmms[models[1]])
    dist2_to_dist1_kl = gmm_kl(gmms[models[1]], gmms[models[0]])

    plt.title(f'{models[0]} to {models[1]} KL Divergence: {dist1_to_dist2_kl}\
    \n{models[1]} to {models[0]} KL Divergence: {dist2_to_dist1_kl}')

    plt.show()

    if export:
        _save_plot(out_path, f"Distributions-{models[0]}-vs-{models[1]}")

    return dist1_to_dist2_kl, dist2_to_dist1_kl

# Cell


def plot_gmm_1d(clusters, export = False):
    plt.figure(figsize=(12, 8))
    # Create 2x2 sub plots
    gs = gridspec.GridSpec(1, 2)
    plt.clf()
    for i, model in enumerate(clusters):
        samples, _, medoid_ids, _ = clusters[model]
        gmm = generate_distributions(samples, len(medoid_ids))
        x_min, x_max = samples[:, 0].min(), samples[:, 0].max()

        # Plot Data
        plt.subplot(gs[0, i])

        delta = 10
        x = np.linspace(x_min - delta, x_max + delta, 1000).reshape(500,2)
        logprob = gmm.score_samples(x)
        pdf = np.exp(logprob)
        plt.plot(x, pdf, '-k')

    if export:
        if not os.path.exists('images/'): os.mkdir('images/')
        plt.savefig('images/1D_GMM_demonstration.png', dpi=100, format='png')

    plt.show()

# Cell

def plot_features(clusters, export = True):
    plt.figure(figsize=(12, 8))
    # Create 2x2 sub plots
    gs = gridspec.GridSpec(2, 2)
    plt.clf()

    plt.subplot(gs[1, 0])
    colmap = {0: 'co', 1: 'mo'}
    plt.title('Overlapping Models\nCyan denotes Human Methods and\nMagenta denotes Generator Samples')
    for i, model in enumerate(clusters):
        samples, _, _, _ = clusters[model]
        plt.plot(samples[:, 0], samples[:, 1], colmap[i], markersize=2)
        plt.xlim(-10, 10)
        plt.ylim(-10, 10)
        plt.xlabel('T-SNE Dim 1')
        plt.ylabel('T-SNE Dim 2')

    plt.subplot(gs[1, 1])
    plt.xlim(-10, 10)
    plt.ylim(-10, 10)
    gmms = {}
    cs = ['c', 'm']
    sets = []
    for i, model in enumerate(clusters):
        samples, _, medoid_ids, _ = clusters[model]
        gmm = generate_distributions(samples, len(medoid_ids))
        gmms[model] = gmm

        # Plot Data
        visualize_2D_gmm(samples, gmm.weights_, gmm.means_.T, np.sqrt(gmm.covariances_).T, model, cs[i])
    human_to_model_kl = gmm_kl(gmms['human'], gmms['model'])
    model_to_human_kl = gmm_kl(gmms['model'], gmms['human'])
    plt.title(f'Human to Model KL Divergence: {human_to_model_kl}\nModel to Human KL Divergence: {model_to_human_kl}')

    plt.show()

    if export:
        if not os.path.exists('images/'): os.mkdir('images/')
        plt.savefig('images/1D_GMM_demonstration.png', dpi=100, format='png')

# Cell

def plot_clusters(clusters: Iterable, out_path: str, export: Optional[bool]=True,
                  clustering_type: Optional[str]='K-medoids'):
    plt.figure(figsize=(12, 8))
    # Create 2x2 sub plots
    gs = gridspec.GridSpec(2, 2)
    plt.clf()
    for i, cluster in enumerate(clusters):
        # Setup data to be plotted
        feature_vectors, centroids, xx, yy, Z = setup_data(cluster)

        logger.info('Generated setup data (decision boundaries).')

        # Plot data
        plt.subplot(gs[0, i])
        plt.imshow(Z, interpolation='nearest',
               extent=(xx.min(), xx.max(), yy.min(), yy.max()),
               cmap=plt.cm.Paired,
               aspect='auto', origin='lower')

        plt.plot(feature_vectors[:, 0], feature_vectors[:, 1], 'k.', markersize=2)
        # Plot the centroids as a white X
        plt.scatter(centroids[:, 0], centroids[:, 1],
                    marker='x', s=169, linewidths=3,
                    color='w', zorder=10)
        plt.title(f'{clustering_type} Clustering\n'
                  '(PCA & T-SNE - reduced data)\n'
                  'Centroids are marked with white cross')
        plt.xlim(xx.min(), xx.max())
        plt.ylim(yy.min(), yy.max())

    plt.subplot(gs[1, :])
    colmap = {0: 'b.', 1: 'r.'}
    plt.title('Blue denotes Human Methods and Red denotes Generator Samples')
    for i, cluster in enumerate(clusters):
        feature_vectors, _, _, _, _ = cluster
        plt.plot(feature_vectors[:, 0], feature_vectors[:, 1], colmap[i], markersize=10)

    if export:
        _save_plot(out_path, f"clustered_datapoints_")
        plt.savefig('images/feature_vectors_scatter_plot.png', dpi=100, format='png')
    plt.show()