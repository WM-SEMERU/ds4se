▁p ackage ▁smos . storage ; ▁import ▁java . sql . Connection ; ▁import ▁java . sql . ResultSet ; ▁import ▁java . sql . SQLException ; ▁import ▁java . util . Collection ; ▁import ▁java . util . Date ; ▁import ▁java . util . Vector ; ▁import ▁smos . bean . Absence ; ▁import ▁smos . bean . Delay ; ▁import ▁smos . bean . Justify ; ▁import ▁smos . bean . Note ; ▁import ▁smos . bean . RegisterLine ; ▁import ▁smos . bean . UserListItem ; ▁import ▁smos . exception . Entity N otFoundException ; ▁import ▁smos . exception . Invalid ValueException ; ▁import ▁smos . exception . Mandatory FieldException ; ▁import ▁smos . storage . connect ionManagement . DBConnection ; ▁import ▁smos . storage . connect ionManagement . exception . Connection Exception ; ▁import ▁smos . utility . Utility ; ▁public ▁class ▁ManagerRegister ▁{ ▁/** ▁* ▁Classe ▁che ▁gestisc e ▁il ▁Registro ▁Digitale ▁* ▁@ author ▁ N icola ▁Pi santi ▁* ▁@ version ▁1.0 ▁*/ ▁private ▁static ▁ManagerRegister ▁instance ; ▁public ▁final ▁static ▁String ▁ TAB LE _ ABSENCE =" absence "; ▁public ▁final ▁static ▁String ▁ TAB LE _ DELAY =" delay "; ▁public ▁final ▁static ▁String ▁ TAB LE _ JUSTIFY =" justify "; ▁public ▁final ▁static ▁String ▁ TAB LE _ NOTE =" note "; ▁private ▁ManagerRegister (){ ▁super (); ▁} ▁/** ▁* ▁Ritorna ▁la ▁sola ▁i stanza ▁della ▁classe ▁esistente . ▁* ▁* ▁@ return ▁Ritorna ▁l ' istanza ▁della ▁classe . ▁*/ ▁public ▁static ▁sy nc hro nized ▁ManagerRegister ▁get Instance (){ ▁if ( instance == null ){ ▁instance ▁= ▁new ▁ManagerRegister (); ▁} ▁return ▁instance ; ▁} ▁/** ▁* ▁Verifica ▁se ▁la ▁classe ▁data ▁in ▁input ▁ Ã ▁ ̈ ▁nel ▁database ▁* ▁@ param ▁pAbsence ▁* ▁La ▁classe ▁di ▁cui ▁bisogn a ▁verificar e ▁l ' esistenza ▁* ▁@ return ▁true ▁se ▁la ▁classe ▁ Ã ▁ ̈ ▁nel ▁database , ▁altrimenti ▁false ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁*/ ▁public ▁sy nc hro nized ▁boolean ▁exists ( Absence ▁pAbsence ) ▁throws ▁Connection Exception , ▁SQLException ▁{ ▁boolean ▁result ▁= ▁false ; ▁Connection ▁connect ▁= ▁null ; ▁try ▁{ ▁// Otten iamo ▁una ▁ Connessione ▁al ▁DataBase ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect ▁== ▁null ) ▁throw ▁new ▁Connection Exception (); ▁String ▁sql ▁= ▁" SELECT ▁* ▁FR OM ▁" ▁+ ▁ManagerRegister . TAB LE _ ABSENCE ▁+ ▁" ▁W HER E ▁id _ absence ▁= ▁" ▁+ ▁Utility . is Null ( pAbsence . getId Absence ()); ▁// ▁Inv iamo ▁la ▁Query ▁al ▁DataBase ▁ResultSet ▁tRs ▁= ▁Utility . query Operation ( connect , ▁sql ); ▁if ▁( tRs . next ( )){ ▁result ▁= ▁true ; ▁} ▁return ▁result ; ▁} ▁finally ▁{ ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁Verifica ▁se ▁la ▁classe ▁data ▁in ▁input ▁ Ã ▁ ̈ ▁nel ▁database ▁* ▁@ param ▁pDelay ▁* ▁La ▁classe ▁di ▁cui ▁bisogn a ▁verificar e ▁l ' esistenza ▁* ▁@ return ▁true ▁se ▁la ▁classe ▁ Ã ▁ ̈ ▁nel ▁database , ▁altrimenti ▁false ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁*/ ▁public ▁sy nc hro nized ▁boolean ▁exists ( Delay ▁pDelay ) ▁throws ▁Connection Exception , ▁SQLException ▁{ ▁boolean ▁result ▁= ▁false ; ▁Connection ▁connect ▁= ▁null ; ▁try ▁{ ▁// Otten iamo ▁una ▁ Connessione ▁al ▁DataBase ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect ▁== ▁null ) ▁throw ▁new ▁Connection Exception (); ▁String ▁sql ▁= ▁" SELECT ▁* ▁FR OM ▁" ▁+ ▁ManagerRegister . TAB LE _ ABSENCE ▁+ ▁" ▁W HER E ▁id _ delay ▁= ▁" ▁+ ▁Utility . is Null ( pDelay . getId Delay ()); ▁// ▁Inv iamo ▁la ▁Query ▁al ▁DataBase ▁ResultSet ▁tRs ▁= ▁Utility . query Operation ( connect , ▁sql ); ▁if ▁( tRs . next ()) ▁result ▁= ▁true ; ▁return ▁result ; ▁} ▁finally ▁{ ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁Verifica ▁se ▁la ▁classe ▁data ▁in ▁input ▁ Ã ▁ ̈ ▁nel ▁database ▁* ▁@ param ▁pDelay ▁* ▁La ▁classe ▁di ▁cui ▁bisogn a ▁verificar e ▁l ' esistenza ▁* ▁@ return ▁true ▁se ▁la ▁classe ▁ Ã ▁ ̈ ▁nel ▁database , ▁altrimenti ▁false ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁*/ ▁public ▁sy nc hro nized ▁boolean ▁exists ( Justify ▁pJustify ) ▁throws ▁Connection Exception , ▁SQLException ▁{ ▁boolean ▁result ▁= ▁false ; ▁Connection ▁connect ▁= ▁null ; ▁try ▁{ ▁// Otten iamo ▁una ▁ Connessione ▁al ▁DataBase ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect ▁== ▁null ) ▁throw ▁new ▁Connection Exception (); ▁String ▁sql ▁= ▁" SELECT ▁* ▁FR OM ▁" ▁+ ▁ManagerRegister . TAB LE _ JUSTIFY ▁+ ▁" ▁W HER E ▁id _ justify ▁= ▁" ▁+ ▁Utility . is Null ( pJustify . get IdJustify ()); ▁// ▁Inv iamo ▁la ▁Query ▁al ▁DataBase ▁ResultSet ▁tRs ▁= ▁Utility . query Operation ( connect , ▁sql ); ▁if ▁( tRs . next ()) ▁result ▁= ▁true ; ▁return ▁result ; ▁} ▁finally ▁{ ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁Inserisc e ▁un ▁assenza ▁nel ▁database ▁* ▁@ param ▁pAbsence ▁* ▁un ▁oggetto ▁di ▁tipo ▁Absence ▁da ▁inserire ▁nel ▁database ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁Invalid ValueException ▁*/ ▁public ▁sy nc hro nized ▁void ▁insert Absence ( Absence ▁pAbsence ) ▁throws ▁Connection Exception , ▁SQLException , ▁Entity N otFoundException , ▁Invalid ValueException { ▁Connection ▁connect = ▁null ; ▁try { ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect == null ) ▁throw ▁new ▁Connection Exception (); ▁// Prepar iamo ▁la ▁stringa ▁ Sql ▁String ▁sql ▁= ▁" INSER T ▁I NTO ▁" ▁+ ▁ManagerRegister . TAB LE _ ABSENCE ▁+ ▁" ▁( id _ user , ▁date _ absence , ▁id _ justify , ▁accademic _ year ) ▁" ▁+ ▁" VALUES ▁ (" ▁+ ▁Utility . is Null ( pAbsence . getId User ()) ▁+ ▁"," ▁+ ▁Utility . is Null ( pAbsence . get DateAbsence ()) ▁+ ▁"," ▁+ ▁Utility . is Null ( pAbsence . get IdJustify ()) ▁+ ▁"," ▁+ ▁Utility . is Null ( pAbsence . getAcademicYear ()) ▁+ ▁")" ; ▁Utility . execute Operation ( connect , sql ); ▁pAbsence . setId Absence ( ( Utility . getMax Value (" id _ absence ", ManagerRegister . TAB LE _ ABSENCE ))); ▁} finally ▁{ ▁// rilascia ▁le ▁ris or se ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁Inserisc e ▁un ▁ritardo ▁nel ▁database ▁* ▁@ param ▁pDelay ▁* ▁un ▁oggetto ▁di ▁tipo ▁Delay ▁da ▁inserire ▁nel ▁database ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁Invalid ValueException ▁*/ ▁public ▁sy nc hro nized ▁void ▁insert Delay ( Delay ▁pDelay ) ▁throws ▁Connection Exception , ▁SQLException , ▁Entity N otFoundException , ▁Invalid ValueException { ▁Connection ▁connect = ▁null ; ▁try { ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect == null ) ▁throw ▁new ▁Connection Exception (); ▁// Prepar iamo ▁la ▁stringa ▁ Sql ▁String ▁sql ▁= ▁" INSER T ▁I NTO ▁" ▁+ ▁ManagerRegister . TAB LE _ DELAY ▁+ ▁" ▁( id _ user , ▁date _ delay , ▁time _ delay , ▁accademic _ year ) ▁" ▁+ ▁" VALUES ▁ (" ▁+ ▁Utility . is Null ( pDelay . getId User ()) ▁+ ▁"," ▁+ ▁Utility . is Null ( pDelay . get DateDelay ()) ▁+ ▁"," ▁+ ▁Utility . is Null ( pDelay . get TimeDelay ()) ▁+ ▁"," ▁+ ▁Utility . is Null ( pDelay . getAcademicYear ()) ▁+ ▁")" ; ▁Utility . execute Operation ( connect , sql ); ▁pDelay . set IdDelay ( ( Utility . getMax Value (" id _ delay ", ManagerRegister . TAB LE _ DELAY ))); ▁} finally ▁{ ▁// rilascia ▁le ▁ris or se ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁Inserisc e ▁una ▁nota ▁nel ▁database ▁* ▁@ param ▁pNote ▁* ▁un ▁oggetto ▁di ▁tipo ▁Note ▁da ▁inserire ▁nel ▁database ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁Invalid ValueException ▁*/ ▁public ▁sy nc hro nized ▁void ▁insert Note ( Note ▁pNote ) ▁throws ▁ Mandatory FieldException , ▁Connection Exception , ▁SQLException , ▁Entity N otFoundException , ▁Invalid ValueException { ▁Connection ▁connect = ▁null ; ▁try { ▁if ▁( pNote . getDescription () ▁== ▁null ▁|| ▁pNote . getDescription () . equals ("")) ▁throw ▁new ▁ Mandatory FieldException (" Inseri re ▁il ▁testo ▁della ▁nota "); ▁if ▁( pNote . get Teacher () ▁== ▁null ▁|| ▁pNote . get Teacher () . equals ("") ▁) ▁throw ▁new ▁ Mandatory FieldException (" Inseri re ▁l ' insegnante "); ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect == null ) ▁throw ▁new ▁Connection Exception (); ▁// Prepar iamo ▁la ▁stringa ▁ Sql ▁String ▁sql ▁= ▁" INSER T ▁I NTO ▁" ▁+ ▁ManagerRegister . TAB LE _ NOTE ▁+ ▁" ▁( id _ user , ▁date _ note , ▁description , ▁teacher , ▁accademic _ year ) ▁" ▁+ ▁" VALUES ▁ (" ▁+ ▁Utility . is Null ( pNote . getId User ()) ▁+ ▁"," ▁+ ▁Utility . is Null ( pNote . get DateNote ()) ▁+ ▁"," ▁+ ▁Utility . is Null ( pNote . getDescription ()) ▁+ ▁"," ▁+ ▁Utility . is Null ( pNote . get Teacher ()) ▁+ ▁"," ▁+ ▁Utility . is Null ( pNote . getAcademicYear ()) ▁+ ▁")" ; ▁Utility . execute Operation ( connect , sql ); ▁pNote . set IdNote ( ( Utility . getMax Value (" id _ note ", ManagerRegister . TAB LE _ NOTE ))); ▁} finally ▁{ ▁// rilascia ▁le ▁ris or se ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁Inserisc e ▁una ▁giustifica ▁nel ▁database ▁* ▁@ param ▁pJustify ▁* ▁un ▁oggetto ▁di ▁tipo ▁Justify ▁da ▁inserire ▁nel ▁database ▁* ▁@ param ▁pAbsence ▁* ▁un ▁oggetto ▁di ▁tipo ▁Absence ▁che ▁rappresenta ▁l ' assenza ▁giustificata ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁Invalid ValueException ▁*/ ▁public ▁sy nc hro nized ▁void ▁insert Justify ( Justify ▁pJustify , ▁Absence ▁pAbsence ) ▁throws ▁Connection Exception , ▁SQLException , ▁Entity N otFoundException , ▁Invalid ValueException { ▁Connection ▁connect = ▁null ; ▁try { ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect == null ) ▁throw ▁new ▁Connection Exception (); ▁// Prepar iamo ▁la ▁stringa ▁ Sql ▁String ▁sql ▁= ▁" INSER T ▁I NTO ▁" ▁+ ▁ManagerRegister . TAB LE _ JUSTIFY ▁+ ▁" ▁( id _ user , ▁date _ justify , ▁accademic _ year ) ▁" ▁+ ▁" VALUES ▁ (" ▁+ ▁Utility . is Null ( pJustify . getId User ()) ▁+ ▁"," ▁+ ▁Utility . is Null ( pJustify . get DateJustify ()) ▁+ ▁"," ▁+ ▁Utility . is Null ( pJustify . getAcademicYear ()) ▁+ ▁")" ; ▁Utility . execute Operation ( connect , sql ); ▁pJustify . set IdJustify ( ( Utility . getMax Value (" id _ justify ", ManagerRegister . TAB LE _ JUSTIFY ))); ▁pAbsence . set IdJustify ( pJustify . get IdJustify ()); ▁this . updateAbsence ( pAbsence ); ▁} finally ▁{ ▁// rilascia ▁le ▁ris or se ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁Cancella ▁un ' assenza ▁dal ▁database ▁* ▁@ param ▁pAbsence ▁* ▁l ' assenza ▁da ▁cancellare ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁Invalid ValueException ▁*/ ▁public ▁sy nc hro nized ▁void ▁ deleteAbsence ▁( Absence ▁pAbsence ) ▁throws ▁Connection Exception , ▁SQLException , ▁Entity N otFoundException , ▁ Mandatory FieldException , ▁Invalid ValueException ▁{ ▁Connection ▁connect ▁= ▁null ; ▁try ▁{ ▁connect ▁= ▁DBConnection . getConnection (); ▁// Prepar iamo ▁la ▁stringa ▁SQL ▁String ▁sql ▁= ▁" DE LE TE ▁FR OM ▁" ▁+ ▁ManagerRegister . TAB LE _ ABSENCE ▁+ ▁" ▁W HER E ▁id _ absence ▁= ▁" ▁+ ▁Utility . is Null ( pAbsence . getId Absence ()); ▁Utility . execute Operation ( connect , ▁sql ); ▁if ▁(!( pAbsence . get IdJustify ()== null )){ ▁ deleteJustify ( pAbsence . get IdJustify ()); ▁} ▁} finally ▁{ ▁// rilascia ▁le ▁ris or se ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁Cancella ▁un ▁ritardo ▁dal ▁database ▁* ▁@ param ▁pDelay ▁* ▁il ▁ritardo ▁da ▁cancellare ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁Invalid ValueException ▁*/ ▁public ▁sy nc hro nized ▁void ▁ deleteDelay ▁( Delay ▁pDelay ) ▁throws ▁Connection Exception , ▁SQLException , ▁Entity N otFoundException , ▁ Mandatory FieldException , ▁Invalid ValueException ▁{ ▁Connection ▁connect ▁= ▁null ; ▁try ▁{ ▁connect ▁= ▁DBConnection . getConnection (); ▁// Prepar iamo ▁la ▁stringa ▁SQL ▁String ▁sql ▁= ▁" DE LE TE ▁FR OM ▁" ▁+ ▁ManagerRegister . TAB LE _ DELAY ▁+ ▁" ▁W HER E ▁id _ delay ▁= ▁" ▁+ ▁Utility . is Null ( pDelay . getId Delay ()); ▁Utility . execute Operation ( connect , ▁sql ); ▁} finally ▁{ ▁// rilascia ▁le ▁ris or se ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁Cancella ▁una ▁nota ▁dal ▁database ▁* ▁@ param ▁pNote ▁* ▁la ▁nota ▁da ▁cancellare ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁Invalid ValueException ▁*/ ▁public ▁sy nc hro nized ▁void ▁ deleteNote ▁( Note ▁pNote ) ▁throws ▁Connection Exception , ▁SQLException , ▁Entity N otFoundException , ▁Invalid ValueException ▁{ ▁Connection ▁connect ▁= ▁null ; ▁try ▁{ ▁connect ▁= ▁DBConnection . getConnection (); ▁// Prepar iamo ▁la ▁stringa ▁SQL ▁String ▁sql ▁= ▁" DE LE TE ▁FR OM ▁" ▁+ ▁ManagerRegister . TAB LE _ NOTE ▁+ ▁" ▁W HER E ▁id _ note ▁= ▁" ▁+ ▁Utility . is Null ( pNote . getId Note ()); ▁Utility . execute Operation ( connect , ▁sql ); ▁} finally ▁{ ▁// rilascia ▁le ▁ris or se ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁Cancella ▁una ▁nota ▁dal ▁database ▁* ▁@ param ▁p J ID ust if y ▁* ▁l ' ID ▁della ▁nota ▁da ▁cancellare ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁Invalid ValueException ▁*/ ▁public ▁sy nc hro nized ▁void ▁ deleteJustify ▁( int ▁pIDJustify ) ▁throws ▁Connection Exception , ▁SQLException , ▁Entity N otFoundException , ▁ Mandatory FieldException , ▁Invalid ValueException ▁{ ▁Connection ▁connect ▁= ▁null ; ▁try ▁{ ▁connect ▁= ▁DBConnection . getConnection (); ▁// Prepar iamo ▁la ▁stringa ▁SQL ▁String ▁sql ▁= ▁" DE LE TE ▁FR OM ▁" ▁+ ▁ManagerRegister . TAB LE _ JUSTIFY ▁+ ▁" ▁W HER E ▁id _ justify ▁= ▁" ▁+ ▁Utility . is Null ( pIDJustify ); ▁Utility . execute Operation ( connect , ▁sql ); ▁try { ▁Absence ▁temp = ▁getAbsenceById Justify ( pIDJustify ); ▁temp . set IdJustify (0) ; ▁ updateAbsence ( temp ); ▁} catch ( Exception ▁e ){ ▁// ▁ è ▁normale ▁se ▁un ▁exception ▁viene ▁generata ▁// ▁dato ▁che ▁pu ò ▁essere ▁che ▁st iamo ▁cancella ndo ▁una ▁giustifica ▁// di ▁cui ▁abbia mo ▁appen a ▁cancella to ▁l ' assenza ▁} ▁} finally ▁{ ▁// rilascia ▁le ▁ris or se ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁Aggiorna ▁le ▁statistiche ▁di ▁un ' assenza ▁* ▁@ param ▁pAbsence ▁* ▁L ' assenza ▁con ▁le ▁statistiche ▁aggiornat e ▁( ma ▁ID ▁identico ) ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁ Mandatory FieldException ▁*/ ▁public ▁sy nc hro nized ▁void ▁ updateAbsence ▁( Absence ▁pAbsence ) ▁throws ▁Connection Exception , ▁SQLException , ▁Entity N otFoundException { ▁Connection ▁connect = ▁null ; ▁try { ▁// Prepar iamo ▁la ▁stringa ▁SQL ▁String ▁sql = ▁" UP DATE ▁" ▁+ ▁ManagerRegister . TAB LE _ ABSENCE ▁+ ▁" ▁SE T " ▁+ ▁" ▁id _ user ▁= ▁" ▁+ ▁Utility . is Null ( pAbsence . getId User ()) ▁+ ▁" , ▁date _ absence ▁= ▁" ▁+ ▁Utility . is Null ( pAbsence . get DateAbsence ()) ▁+ ▁" , ▁id _ justify ▁= ▁" ▁+ ▁Utility . is Null ( pAbsence . get IdJustify ()) ▁+ ▁" , ▁accademic _ year ▁= ▁" ▁+ ▁Utility . is Null ( pAbsence . getAcademicYear ()) ▁+ ▁" ▁W HER E ▁id _ absence ▁= ▁" ▁+ ▁Utility . is Null ( pAbsence . getId Absence ()); ▁// effettua ▁una ▁nuova ▁connessione ▁e ▁invia ▁la ▁query ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect == null ) ▁throw ▁new ▁Connection Exception (); ▁Utility . execute Operation ( connect , ▁sql ); ▁} finally ▁{ ▁// rilascia ▁le ▁ris or se ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁Aggiorna ▁le ▁statistiche ▁di ▁un ▁ritardo ▁* ▁@ param ▁pDelay ▁* ▁Il ▁ritardo ▁con ▁le ▁statistiche ▁aggiornat e ▁( ma ▁ID ▁identico ) ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁ Mandatory FieldException ▁*/ ▁public ▁sy nc hro nized ▁void ▁ updateDelay ▁( Delay ▁pDelay ) ▁throws ▁Connection Exception , ▁SQLException , ▁Entity N otFoundException , ▁ Mandatory FieldException { ▁Connection ▁connect = ▁null ; ▁try { ▁// Prepar iamo ▁la ▁stringa ▁SQL ▁String ▁sql = ▁" UP DATE ▁" ▁+ ▁ManagerRegister . TAB LE _ DELAY ▁+ ▁" ▁SE T " ▁+ ▁" ▁id _ user ▁= ▁" ▁+ ▁Utility . is Null ( pDelay . getId User ()) ▁+ ▁" , ▁date _ delay ▁= ▁" ▁+ ▁Utility . is Null ( pDelay . get DateDelay ()) ▁+ ▁" , ▁time _ delay ▁= ▁" ▁+ ▁Utility . is Null ( pDelay . get TimeDelay ()) ▁+ ▁" , ▁accademic _ year ▁= ▁" ▁+ ▁Utility . is Null ( pDelay . getAcademicYear ()) ▁+ ▁" ▁W HER E ▁id _ delay ▁= ▁" ▁+ ▁Utility . is Null ( pDelay . getId Delay ()); ▁// effettua ▁una ▁nuova ▁connessione ▁e ▁invia ▁la ▁query ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect == null ) ▁throw ▁new ▁Connection Exception (); ▁Utility . execute Operation ( connect , ▁sql ); ▁} finally ▁{ ▁// rilascia ▁le ▁ris or se ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁M etodo ▁che ▁aggiorna ▁le ▁statistiche ▁di ▁una ▁Nota ▁* ▁@ param ▁pNote ▁* ▁un ▁oggetto ▁di ▁tipo ▁Note ▁con ▁le ▁statistiche ▁aggiornat e ▁ma ▁id ▁identico ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁ Mandatory FieldException ▁*/ ▁public ▁sy nc hro nized ▁void ▁ updateNote ▁( Note ▁pNote ) ▁throws ▁Connection Exception , ▁SQLException , ▁Entity N otFoundException , ▁ Mandatory FieldException { ▁Connection ▁connect = ▁null ; ▁try { ▁if ▁( pNote . getDescription () ▁== ▁null ▁|| ▁pNote . getDescription () . equals ("")) ▁throw ▁new ▁ Mandatory FieldException (" Inseri re ▁il ▁testo ▁della ▁nota "); ▁if ▁( pNote . get Teacher () ▁== ▁null ▁|| ▁pNote . get Teacher () . equals ("") ▁) ▁throw ▁new ▁ Mandatory FieldException (" Inseri re ▁l ' insegnante "); ▁// Prepar iamo ▁la ▁stringa ▁SQL ▁String ▁sql = ▁" UP DATE ▁" ▁+ ▁ManagerRegister . TAB LE _ NOTE ▁+ ▁" ▁SE T " ▁+ ▁" ▁id _ user ▁= ▁" ▁+ ▁Utility . is Null ( pNote . getId User ()) ▁+ ▁" , ▁date _ note ▁= ▁" ▁+ ▁Utility . is Null ( pNote . get DateNote ()) ▁+ ▁" , ▁description ▁= ▁" ▁+ ▁Utility . is Null ( pNote . getDescription ()) ▁+ ▁" , ▁teacher ▁= ▁" ▁+ ▁Utility . is Null ( pNote . get Teacher ()) ▁+ ▁" , ▁accademic _ year ▁= ▁" ▁+ ▁Utility . is Null ( pNote . getAcademicYear ()) ▁+ ▁" ▁W HER E ▁id _ note ▁= ▁" ▁+ ▁Utility . is Null ( pNote . getId Note ()); ▁// effettua ▁una ▁nuova ▁connessione ▁e ▁invia ▁la ▁query ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect == null ) ▁throw ▁new ▁Connection Exception (); ▁Utility . execute Operation ( connect , ▁sql ); ▁} finally ▁{ ▁// rilascia ▁le ▁ris or se ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁Aggiorna ▁le ▁statistiche ▁di ▁una ▁giustifica ▁* ▁@ param ▁pJustify ▁* ▁la ▁giustifica ▁con ▁le ▁statistiche ▁aggiornat e ▁( ma ▁ID ▁identico ) ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁ Mandatory FieldException ▁*/ ▁public ▁sy nc hro nized ▁void ▁ updateJustify ▁( Justify ▁pJustify ) ▁throws ▁Connection Exception , ▁SQLException , ▁Entity N otFoundException , ▁ Mandatory FieldException { ▁Connection ▁connect = ▁null ; ▁try { ▁// Prepar iamo ▁la ▁stringa ▁SQL ▁String ▁sql = ▁" UP DATE ▁" ▁+ ▁ManagerRegister . TAB LE _ JUSTIFY ▁+ ▁" ▁SE T " ▁+ ▁" ▁id _ user ▁= ▁" ▁+ ▁Utility . is Null ( pJustify . getId User ()) ▁+ ▁" , ▁date _ justify ▁= ▁" ▁+ ▁Utility . is Null ( pJustify . get DateJustify ()) ▁+ ▁" , ▁accademic _ year ▁= ▁" ▁+ ▁Utility . is Null ( pJustify . getAcademicYear ()) ▁+ ▁" ▁W HER E ▁id _ justify ▁= ▁" ▁+ ▁Utility . is Null ( pJustify . get IdJustify ()); ▁// effettua ▁una ▁nuova ▁connessione ▁e ▁invia ▁la ▁query ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect == null ) ▁throw ▁new ▁Connection Exception (); ▁Utility . execute Operation ( connect , ▁sql ); ▁} finally ▁{ ▁// rilascia ▁le ▁ris or se ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁M etodo ▁che ▁restitui sce ▁una ▁nota ▁dato ▁l ' id ▁della ▁note ▁stessa ▁* ▁@ param ▁pIDJustify ▁* ▁un ▁intero ▁che ▁rappresenta ▁l ' id ▁della ▁nota ▁* ▁@ return ▁un ▁oggetto ▁di ▁tipo ▁Note ▁che ▁rappresenta ▁la ▁nota ▁* ▁@ throws ▁Invalid ValueException ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁*/ ▁public ▁sy nc hro nized ▁Note ▁ getNoteByI d ( ▁int ▁ pIDNote ) throws ▁Invalid ValueException , ▁Entity N otFoundException , ▁Connection Exception , ▁SQLException { ▁Note ▁result = null ; ▁Connection ▁connect ▁= ▁null ; ▁try ▁{ ▁// ▁Se ▁non ▁ Ã ▁ ̈ ▁stato ▁fornito ▁l ' id ▁restitui amo ▁un ▁codice ▁di ▁errore ▁if ▁( pIDNote <=0) ▁throw ▁new ▁Entity N otFoundException (" Im possibile ▁trova re ▁la ▁nota "); ▁/* ▁* ▁Prepar iamo ▁la ▁stringa ▁SQL ▁per ▁recuperare ▁le ▁informazioni ▁* ▁corrispondent i ▁alla ▁classe ▁dell ' id ▁passato ▁*/ ▁String ▁tSql ▁= ▁" SELECT ▁* ▁FR OM ▁" ▁+ ▁ManagerRegister . TAB LE _ NOTE ▁+ ▁" ▁W HER E ▁id _ note ▁= ▁" ▁+ ▁Utility . is Null ( pIDNote ) ▁ ; ▁// ▁Otten iamo ▁una ▁ Connessione ▁al ▁DataBase ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect ▁== ▁null ) ▁throw ▁new ▁Connection Exception (); ▁// ▁Inv iamo ▁la ▁Query ▁al ▁DataBase ▁ResultSet ▁tRs ▁= ▁Utility . query Operation ( connect , ▁tSql ); ▁if ▁( tRs . next ()) ▁result ▁= ▁this . load Note From Rs ( tRs ); ▁else ▁throw ▁new ▁Entity N otFoundException (" Im possibile ▁trova re ▁la ▁nota !" ); ▁return ▁result ; ▁} finally { ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁M etodo ▁che ▁restitui sce ▁un ▁assenza ▁dato ▁l ' id ▁della ▁gi ust if ca ▁associat a ▁a ▁ tale ▁assenza ▁* ▁@ param ▁pIDJustify ▁* ▁un ▁intero ▁che ▁rappresenta ▁l ' id ▁della ▁giustifica ▁* ▁@ return ▁un ▁oggetto ▁di ▁tipo ▁Absence ▁che ▁rappresenta ▁l ' assenza ▁giustificata ▁* ▁@ throws ▁Invalid ValueException ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁*/ ▁public ▁sy nc hro nized ▁Absence ▁getAbsenceById Justify ( ▁int ▁pIDJustify ) throws ▁Invalid ValueException , ▁Entity N otFoundException , ▁Connection Exception , ▁SQLException { ▁Absence ▁result = null ; ▁Connection ▁connect ▁= ▁null ; ▁try ▁{ ▁// ▁Se ▁non ▁ Ã ▁ ̈ ▁stato ▁fornito ▁l ' id ▁restitui amo ▁un ▁codice ▁di ▁errore ▁if ▁( pIDJustify <=0) ▁throw ▁new ▁Entity N otFoundException (" Im possibile ▁trova re ▁la ▁l ' assenza "); ▁/* ▁* ▁Prepar iamo ▁la ▁stringa ▁SQL ▁per ▁recuperare ▁le ▁informazioni ▁* ▁corrispondent i ▁alla ▁classe ▁dell ' id ▁passato ▁*/ ▁String ▁tSql ▁= ▁" SELECT ▁* ▁FR OM ▁" ▁+ ▁ManagerRegister . TAB LE _ ABSENCE ▁+ ▁" ▁W HER E ▁id _ justify ▁= ▁" ▁+ ▁Utility . is Null ( pIDJustify ) ▁ ; ▁// ▁Otten iamo ▁una ▁ Connessione ▁al ▁DataBase ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect ▁== ▁null ) ▁throw ▁new ▁Connection Exception (); ▁// ▁Inv iamo ▁la ▁Query ▁al ▁DataBase ▁ResultSet ▁tRs ▁= ▁Utility . query Operation ( connect , ▁tSql ); ▁if ▁( tRs . next ()) ▁result ▁= ▁this . load Absence From Rs ( tRs ); ▁else ▁throw ▁new ▁Entity N otFoundException (" Im possibile ▁trova re ▁l ' assenza !" ); ▁return ▁result ; ▁} finally { ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁M etodo ▁che ▁restitui sce ▁un ▁assenza ▁dato ▁l ' id ▁di ▁questa ▁* ▁@ param ▁pIDAbsence ▁* ▁un ▁intero ▁che ▁rappresenta ▁l ' id ▁dell ' assenza ▁* ▁@ return ▁un ▁oggetto ▁di ▁tipo ▁Absence ▁che ▁rappresenta ▁l ' assenza ▁* ▁@ throws ▁Invalid ValueException ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁*/ ▁public ▁sy nc hro nized ▁Absence ▁getAbsenceById Absence ( ▁int ▁pIDAbsence ) throws ▁Invalid ValueException , ▁Entity N otFoundException , ▁Connection Exception , ▁SQLException { ▁Absence ▁result = null ; ▁Connection ▁connect ▁= ▁null ; ▁try ▁{ ▁// ▁Se ▁non ▁ Ã ▁ ̈ ▁stato ▁fornito ▁l ' id ▁restitui amo ▁un ▁codice ▁di ▁errore ▁if ▁( pIDAbsence <=0) ▁throw ▁new ▁Entity N otFoundException (" Im possibile ▁trova re ▁l ' ▁assenza "); ▁/* ▁* ▁Prepar iamo ▁la ▁stringa ▁SQL ▁per ▁recuperare ▁le ▁informazioni ▁* ▁corrispondent i ▁alla ▁classe ▁dell ' id ▁passato ▁*/ ▁String ▁tSql ▁= ▁" SELECT ▁* ▁FR OM ▁" ▁+ ▁ManagerRegister . TAB LE _ ABSENCE ▁+ ▁" ▁W HER E ▁id _ absence ▁= ▁" ▁+ ▁Utility . is Null ( pIDAbsence ) ▁ ; ▁// ▁Otten iamo ▁una ▁ Connessione ▁al ▁DataBase ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect ▁== ▁null ) ▁throw ▁new ▁Connection Exception (); ▁// ▁Inv iamo ▁la ▁Query ▁al ▁DataBase ▁ResultSet ▁tRs ▁= ▁Utility . query Operation ( connect , ▁tSql ); ▁if ▁( tRs . next ()) ▁result ▁= ▁this . load Absence From Rs ( tRs ); ▁else ▁throw ▁new ▁Entity N otFoundException (" Im possibile ▁trova re ▁l ' assenza !" ); ▁return ▁result ; ▁} finally { ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁M etodo ▁che ▁restitui sce ▁un ▁ritardo ▁dato ▁l ' id ▁di ▁questo ▁* ▁@ param ▁ pIDDelay ▁* ▁un ▁intero ▁che ▁rappresenta ▁l ' id ▁del ▁ritardo ▁* ▁@ return ▁un ▁oggetto ▁di ▁tipo ▁Delay ▁che ▁rappresenta ▁il ▁ritardo ▁* ▁@ throws ▁Invalid ValueException ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁*/ ▁public ▁sy nc hro nized ▁Delay ▁getDelayByI d ( ▁int ▁ pIDDelay ) throws ▁Invalid ValueException , ▁Entity N otFoundException , ▁Connection Exception , ▁SQLException { ▁Delay ▁result = null ; ▁Connection ▁connect ▁= ▁null ; ▁try ▁{ ▁// ▁Se ▁non ▁ Ã ▁ ̈ ▁stato ▁fornito ▁l ' id ▁restitui amo ▁un ▁codice ▁di ▁errore ▁if ▁( pIDDelay <=0) ▁throw ▁new ▁Entity N otFoundException (" Im possibile ▁trova re ▁il ▁ritardo "); ▁/* ▁* ▁Prepar iamo ▁la ▁stringa ▁SQL ▁per ▁recuperare ▁le ▁informazioni ▁* ▁corrispondent i ▁alla ▁classe ▁dell ' id ▁passato ▁*/ ▁String ▁tSql ▁= ▁" SELECT ▁* ▁FR OM ▁" ▁+ ▁ManagerRegister . TAB LE _ DELAY ▁+ ▁" ▁W HER E ▁id _ delay ▁= ▁" ▁+ ▁Utility . is Null ( pIDDelay ) ▁ ; ▁// ▁Otten iamo ▁una ▁ Connessione ▁al ▁DataBase ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect ▁== ▁null ) ▁throw ▁new ▁Connection Exception (); ▁// ▁Inv iamo ▁la ▁Query ▁al ▁DataBase ▁ResultSet ▁tRs ▁= ▁Utility . query Operation ( connect , ▁tSql ); ▁if ▁( tRs . next ()) ▁result ▁= ▁this . load Delay From Rs ( tRs ); ▁else ▁throw ▁new ▁Entity N otFoundException (" Im possibile ▁trova re ▁l ' assenza !" ); ▁return ▁result ; ▁} finally { ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁M etodo ▁che ▁restitui sce ▁un ▁assenza ▁dato ▁l ' id ▁di ▁questa ▁* ▁@ param ▁pIDAbsence ▁* ▁un ▁intero ▁che ▁rappresenta ▁l ' id ▁dell ' assenza ▁* ▁@ return ▁un ▁oggetto ▁di ▁tipo ▁Absence ▁che ▁rappresenta ▁l ' assenza ▁* ▁@ throws ▁Invalid ValueException ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁*/ ▁public ▁sy nc hro nized ▁Justify ▁ getJustifyBy IdJustify ( ▁int ▁pIDJustify ) throws ▁Invalid ValueException , ▁Entity N otFoundException , ▁Connection Exception , ▁SQLException { ▁Justify ▁result = null ; ▁Connection ▁connect ▁= ▁null ; ▁try ▁{ ▁// ▁Se ▁non ▁ Ã ▁ ̈ ▁stato ▁fornito ▁l ' id ▁restitui amo ▁un ▁codice ▁di ▁errore ▁if ▁( pIDJustify <=0) ▁throw ▁new ▁Entity N otFoundException (" Im possibile ▁trova re ▁la ▁giustifica "); ▁/* ▁* ▁Prepar iamo ▁la ▁stringa ▁SQL ▁per ▁recuperare ▁le ▁informazioni ▁* ▁corrispondent i ▁alla ▁classe ▁dell ' id ▁passato ▁*/ ▁String ▁tSql ▁= ▁" SELECT ▁* ▁FR OM ▁" ▁+ ▁ManagerRegister . TAB LE _ JUSTIFY ▁+ ▁" ▁W HER E ▁id _ justify ▁= ▁" ▁+ ▁Utility . is Null ( pIDJustify ) ▁ ; ▁// ▁Otten iamo ▁una ▁ Connessione ▁al ▁DataBase ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect ▁== ▁null ) ▁throw ▁new ▁Connection Exception (); ▁// ▁Inv iamo ▁la ▁Query ▁al ▁DataBase ▁ResultSet ▁tRs ▁= ▁Utility . query Operation ( connect , ▁tSql ); ▁if ▁( tRs . next ()) ▁result = ▁this . load Justify From Rs ( tRs ); ▁else ▁throw ▁new ▁Entity N otFoundException (" Im possibile ▁trova re ▁la ▁giustifica !" ); ▁return ▁result ; ▁} finally { ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁M etodo ▁che ▁restitui sce ▁true ▁se ▁l ' assenza ▁data ▁in ▁input ▁ha ▁una ▁giustifica ▁assegnata ▁* ▁@ param ▁pAbsence ▁* ▁un ▁oggetto ▁di ▁valore ▁Absence ▁di ▁cui ▁bisogn a ▁controllare ▁se ▁ha ▁giustifica ▁* ▁@ return ▁true ▁se ▁l ' assenza ▁ Ã ▁ ̈ ▁giustificata , ▁false ▁altrimenti ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁*/ ▁public ▁sy nc hro nized ▁boolean ▁has Justify ( Absence ▁pAbsence ) throws ▁Entity N otFoundException , ▁Connection Exception , ▁SQLException { ▁if (! exists ( pAbsence )) ▁throw ▁new ▁Entity N otFoundException (" Assenza ▁non ▁presente ▁in ▁database "); ▁if ( pAbsence . get IdJustify ()== null ) ▁return ▁false ; ▁return ▁true ; ▁} ▁/** ▁* ▁M etodo ▁che ▁restitui sce ▁la ▁giustifica ▁le ga ta ▁a ▁una ▁data ▁assenza ▁* ▁@ param ▁pAbsence ▁* ▁un ▁oggetto ▁di ▁tipo ▁Absence ▁che ▁rappresenta ▁l ' assenza ▁* ▁@ return ▁un ▁oggetto ▁di ▁tipo ▁Justify , ▁opp ure ▁null ▁se ▁l ' assenza ▁non ▁ha ▁giustifica ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁* ▁@ throws ▁Invalid ValueException ▁*/ ▁public ▁sy nc hro nized ▁Justify ▁ getJustifyBy Absence ( Absence ▁pAbsence ) throws ▁Entity N otFoundException , ▁Connection Exception , ▁SQLException , ▁Invalid ValueException { ▁if (! exists ( pAbsence )) ▁throw ▁new ▁Entity N otFoundException (" Assenza ▁non ▁presente ▁in ▁database "); ▁if ( pAbsence . get IdJustify ()== null ) ▁return ▁null ; ▁Justify ▁result = null ; ▁Connection ▁connect ▁= ▁null ; ▁try { ▁/* ▁* ▁Prepar iamo ▁la ▁stringa ▁SQL ▁per ▁recuperare ▁le ▁informazioni ▁* ▁corrispondent i ▁alla ▁classe ▁dell ' id ▁passato ▁*/ ▁String ▁tSql ▁= ▁" SELECT ▁* ▁FR OM ▁" ▁+ ▁ManagerRegister . TAB LE _ JUSTIFY ▁+ ▁" ▁W HER E ▁id _ justify ▁= ▁" ▁+ ▁Utility . is Null ( pAbsence . get IdJustify ()) ▁ ; ▁// ▁Otten iamo ▁una ▁ Connessione ▁al ▁DataBase ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect ▁== ▁null ) ▁throw ▁new ▁Connection Exception (); ▁// ▁Inv iamo ▁la ▁Query ▁al ▁DataBase ▁ResultSet ▁tRs ▁= ▁Utility . query Operation ( connect , ▁tSql ); ▁if ▁( tRs . next ()) ▁result ▁= ▁this . load Justify From Rs ( tRs ); ▁else ▁throw ▁new ▁Entity N otFoundException (" Im possibile ▁trova re ▁la ▁giustifica !" ); ▁return ▁result ; ▁} finally { ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁M etodo ▁che ▁restitui sce ▁le ▁assenze ▁pres o ▁un ▁dato ▁anno ▁scolastico ▁e ▁utente ▁in ▁input ▁* ▁@ param ▁pIdUser ▁* ▁un ▁intero ▁che ▁rappresenta ▁l ' id ▁dell ' utente ▁* ▁@ param ▁pAcademicYear ▁* ▁un ▁intero ▁che ▁rappresenta ▁l ' anno ▁accademico ▁* ▁@ return ▁una ▁collec zione ▁di ▁assenze ▁( vuota ▁se ▁l ' utente ▁non ▁ha ▁a vuto ▁assenze ▁) ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁* ▁@ throws ▁Invalid ValueException ▁*/ ▁public ▁sy nc hro nized ▁Collection < Absence > ▁getAbsence ByIDUserAnd AcademicYear ( int ▁pIdUser , ▁int ▁pAcademicYear ) ▁throws ▁Entity N otFoundException , ▁Connection Exception , ▁SQLException , ▁Invalid ValueException { ▁Collection < Absence > ▁result = new ▁Vector < Absence >(); ▁Connection ▁connect ▁= ▁null ; ▁try ▁{ ▁// ▁Se ▁non ▁ Ã ▁ ̈ ▁stato ▁fornito ▁l ' id ▁restitui amo ▁un ▁codice ▁di ▁errore ▁if ▁( pAcademicYear ▁<= ▁ 1970) ▁throw ▁new ▁Entity N otFoundException (" Data ▁tr oppo ▁vecchia "); ▁// ▁id em ▁per ▁l ' id ▁user ▁if ▁( pIdUser <=0) ▁throw ▁new ▁Entity N otFoundException (" Utente ▁non ▁trovato "); ▁/* ▁* ▁Prepar iamo ▁la ▁stringa ▁SQL ▁per ▁recuperare ▁le ▁informazioni ▁* ▁corrispondent i ▁alla ▁classe ▁dell ' id ▁passato ▁*/ ▁String ▁tSql ▁= ▁" SELECT ▁* ▁FR OM ▁" ▁+ ▁ManagerRegister . TAB LE _ ABSENCE ▁+ ▁" ▁W HER E ▁accademic _ year ▁= ▁" ▁+ ▁Utility . is Null ( pAcademicYear ) ▁+ ▁" ▁ AND ▁id _ user ▁= ▁" ▁+ ▁Utility . is Null ( pIdUser ); ▁// ▁Otten iamo ▁una ▁ Connessione ▁al ▁DataBase ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect ▁== ▁null ) ▁throw ▁new ▁Connection Exception (); ▁// ▁Inv iamo ▁la ▁Query ▁al ▁DataBase ▁ResultSet ▁tRs ▁= ▁Utility . query Operation ( connect , ▁tSql ); ▁while ( tRs . next ()) ▁{ ▁result . add ( load Absence From Rs ( tRs )); ▁} ▁return ▁result ; ▁} finally { ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁M etodo ▁che ▁restitui sce ▁una ▁colle zione ▁di ▁note ▁per ▁un ▁dato ▁utente ▁ed ▁un ▁dato ▁anno ▁scolastico ▁* ▁@ param ▁pIdUser ▁* ▁un ▁intero ▁che ▁rappresenta ▁l ' id ▁dell ' utente ▁* ▁@ param ▁pAcademicYear ▁* ▁un ▁intero ▁che ▁rappresenta ▁l ' anno ▁accademico ▁* ▁@ return ▁una ▁colle zione ▁di ▁note , ▁ vuota ▁se ▁l ' utente ▁non ▁ne ▁ha ▁ricevut e ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁* ▁@ throws ▁Invalid ValueException ▁*/ ▁public ▁sy nc hro nized ▁Collection < Note > ▁ getNoteByI DUserAnd AcademicYear ( int ▁pIdUser , ▁int ▁pAcademicYear ) ▁throws ▁Entity N otFoundException , ▁Connection Exception , ▁SQLException , ▁Invalid ValueException { ▁Collection < Note > ▁result = new ▁Vector < Note >(); ▁Connection ▁connect ▁= ▁null ; ▁try ▁{ ▁// ▁Se ▁non ▁ Ã ▁ ̈ ▁stato ▁fornito ▁l ' id ▁restitui amo ▁un ▁codice ▁di ▁errore ▁if ▁( pAcademicYear ▁<= ▁ 1970) ▁throw ▁new ▁Entity N otFoundException (" Data ▁tr oppo ▁vecchia "); ▁// ▁id em ▁per ▁l ' id ▁user ▁if ▁( pIdUser <=0) ▁throw ▁new ▁Entity N otFoundException (" Utente ▁non ▁trovato "); ▁/* ▁* ▁Prepar iamo ▁la ▁stringa ▁SQL ▁per ▁recuperare ▁le ▁informazioni ▁* ▁corrispondent i ▁alla ▁classe ▁dell ' id ▁passato ▁*/ ▁String ▁tSql ▁= ▁" SELECT ▁* ▁FR OM ▁" ▁+ ▁ManagerRegister . TAB LE _ NOTE ▁+ ▁" ▁W HER E ▁accademic _ year ▁= ▁" ▁+ ▁Utility . is Null ( pAcademicYear ) ▁+ ▁" ▁ AND ▁id _ user ▁= ▁" ▁+ ▁Utility . is Null ( pIdUser ); ▁// ▁Otten iamo ▁una ▁ Connessione ▁al ▁DataBase ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect ▁== ▁null ) ▁throw ▁new ▁Connection Exception (); ▁// ▁Inv iamo ▁la ▁Query ▁al ▁DataBase ▁ResultSet ▁tRs ▁= ▁Utility . query Operation ( connect , ▁tSql ); ▁while ( tRs . next ()) ▁{ ▁result . add ( load Note From Rs ( tRs )); ▁} ▁return ▁result ; ▁} finally { ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁M etodo ▁che ▁restitui sce ▁l ' assenza ▁di ▁una ▁dato ▁studente ▁in ▁un ▁dato ▁giorno ▁* ▁@ param ▁pIdUser ▁* ▁un ▁intero ▁che ▁rappresenta ▁l ' id ▁dell o ▁studente ▁* ▁@ param ▁pDate ▁* ▁una ▁stringa ▁che ▁rappresenta ▁la ▁data ▁formatta ta ▁per ▁il ▁database ▁* ▁@ return ▁un ▁oggetto ▁di ▁tipo ▁Absence , ▁opp ure ▁null ▁se ▁lo ▁studente ▁era ▁presente ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁* ▁@ throws ▁Invalid ValueException ▁*/ ▁public ▁sy nc hro nized ▁Absence ▁getAbsence ByIDUserAnd Date ( int ▁pIdUser , ▁Date ▁pDate ) ▁throws ▁Entity N otFoundException , ▁Connection Exception , ▁SQLException , ▁Invalid ValueException { ▁Absence ▁result = new ▁Absence (); ▁Connection ▁connect ▁= ▁null ; ▁try ▁{ ▁// TODO ▁controlli ▁sull a ▁formatta zione ▁della ▁stringa ▁// ▁id em ▁per ▁l ' id ▁user ▁if ▁( pIdUser <=0) ▁throw ▁new ▁Entity N otFoundException (" Utente ▁non ▁trovato "); ▁/* ▁* ▁Prepar iamo ▁la ▁stringa ▁SQL ▁per ▁recuperare ▁le ▁informazioni ▁* ▁corrispondent i ▁alla ▁classe ▁dell ' id ▁passato ▁*/ ▁String ▁tSql ▁= ▁" SELECT ▁* ▁FR OM ▁" ▁+ ▁ManagerRegister . TAB LE _ ABSENCE ▁+ ▁" ▁W HER E ▁date _ absence ▁= ▁" ▁+ ▁Utility . is Null ( pDate ) ▁+ ▁" ▁ AND ▁id _ user ▁= ▁" ▁+ ▁Utility . is Null ( pIdUser ); ▁// ▁Otten iamo ▁una ▁ Connessione ▁al ▁DataBase ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect ▁== ▁null ) ▁throw ▁new ▁Connection Exception (); ▁// ▁Inv iamo ▁la ▁Query ▁al ▁DataBase ▁ResultSet ▁tRs ▁= ▁Utility . query Operation ( connect , ▁tSql ); ▁if ( tRs . next ()) ▁{ ▁result = load Absence From Rs ( tRs ); ▁} else ▁{ ▁result = null ; ▁} ▁return ▁result ; ▁} finally { ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁M etodo ▁che ▁restitui sce ▁il ▁ritardo ▁di ▁una ▁dato ▁studente ▁in ▁un ▁dato ▁giorno ▁* ▁@ param ▁pIdUser ▁* ▁un ▁intero ▁che ▁rappresenta ▁l ' id ▁dell o ▁studente ▁* ▁@ param ▁pDate ▁* ▁una ▁stringa ▁che ▁rappresenta ▁la ▁data ▁formatta ta ▁per ▁il ▁database ▁* ▁@ return ▁un ▁oggetto ▁di ▁tipo ▁Delay , ▁opp ure ▁null ▁se ▁lo ▁studente ▁era ▁in ▁orario ▁o ▁assente ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁* ▁@ throws ▁Invalid ValueException ▁*/ ▁public ▁sy nc hro nized ▁Delay ▁getDelayByI DUserAnd Date ( int ▁pIdUser , ▁Date ▁pDate ) ▁throws ▁Entity N otFoundException , ▁Connection Exception , ▁SQLException , ▁Invalid ValueException { ▁Delay ▁result = new ▁Delay (); ▁Connection ▁connect ▁= ▁null ; ▁try ▁{ ▁// TODO ▁controlli ▁sull a ▁formatta zione ▁della ▁stringa ▁// ▁id em ▁per ▁l ' id ▁user ▁if ▁( pIdUser <=0) ▁throw ▁new ▁Entity N otFoundException (" Utente ▁non ▁trovato "); ▁/* ▁* ▁Prepar iamo ▁la ▁stringa ▁SQL ▁per ▁recuperare ▁le ▁informazioni ▁* ▁corrispondent i ▁alla ▁classe ▁dell ' id ▁passato ▁*/ ▁String ▁tSql ▁= ▁" SELECT ▁* ▁FR OM ▁" ▁+ ▁ManagerRegister . TAB LE _ DELAY ▁+ ▁" ▁W HER E ▁date _ delay ▁= ▁" ▁+ ▁Utility . is Null ( pDate ) ▁+ ▁" ▁ AND ▁id _ user ▁= ▁" ▁+ ▁Utility . is Null ( pIdUser ); ▁// ▁Otten iamo ▁una ▁ Connessione ▁al ▁DataBase ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect ▁== ▁null ) ▁throw ▁new ▁Connection Exception (); ▁// ▁Inv iamo ▁la ▁Query ▁al ▁DataBase ▁ResultSet ▁tRs ▁= ▁Utility . query Operation ( connect , ▁tSql ); ▁if ( tRs . next ()) ▁{ ▁result = load Delay From Rs ( tRs ); ▁} else ▁{ ▁result = null ; ▁} ▁return ▁result ; ▁} finally { ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁public ▁sy nc hro nized ▁Collection < RegisterLine > ▁get Register ByClass IDA ndDate ( int ▁ pClassID , ▁Date ▁pDate ) ▁throws ▁Entity N otFoundException , ▁Connection Exception , ▁SQLException , ▁Invalid ValueException { ▁Collection < RegisterLine > ▁result ▁= ▁new ▁Vector < RegisterLine >(); ▁ManagerUser ▁mg ▁= ▁ManagerUser . get Instance (); ▁Collection < UserListItem > ▁students ▁= ▁mg . get StudentsByClass roomId ( pClassID ); ▁for ▁( UserListItem ▁ x ▁ : ▁students ){ ▁RegisterLine ▁temp ▁= ▁new ▁RegisterLine (); ▁temp . set Student ( x ); ▁temp . set Absence ( this . getAbsence ByIDUserAnd Date ( x . getId (), ▁pDate )); ▁temp . set Delay ( this . getDelay ByIDUserAnd Date ( x . getId (), ▁pDate )); ▁result . add ( temp ); ▁} ▁return ▁result ; ▁} ▁/** ▁* ▁M etodo ▁che ▁verifica ▁se ▁c ' è ▁un ' assenza ▁in ▁una ▁line a ▁del ▁registro ▁* ▁@ param ▁pRegisterLine ▁* ▁un ▁oggetto ▁di ▁tipo ▁RegisterLine ▁* ▁@ return ▁true ▁se ▁c ' è ▁un ' assenza ▁nella ▁line a ▁di ▁registro ▁passata , ▁altrimenti ▁false ▁*/ ▁public ▁boolean ▁has Absence ( RegisterLine ▁pRegisterLine ){ ▁if ( pRegisterLine . getAbsence ()== null ) return ▁false ; ▁return ▁true ; ▁} ▁/** ▁* ▁M etodo ▁che ▁verifica ▁se ▁c ' è ▁un ▁ritardo ▁in ▁una ▁line a ▁del ▁registro ▁* ▁@ param ▁pRegisterLine ▁* ▁un ▁oggetto ▁di ▁tipo ▁RegisterLine ▁* ▁@ return ▁true ▁se ▁c ' è ▁un ▁ritardo ▁nella ▁line a ▁di ▁registro ▁passata , ▁altrimenti ▁false ▁*/ ▁public ▁boolean ▁has Delay ( RegisterLine ▁pRegisterLine ){ ▁if ( pRegisterLine . getDelay ()== null ) return ▁false ; ▁return ▁true ; ▁} ▁/** ▁* ▁Con sente ▁la ▁lettura ▁di ▁un ▁ solo ▁record ▁dal ▁Result ▁Set ▁* ▁@ param ▁pRs ▁* ▁Il ▁result ▁set ▁da ▁cui ▁ estra rre ▁l ' oggetto ▁Absence ▁* ▁@ throws ▁SQLException ▁* ▁@ throws ▁Invalid ValueException ▁*/ ▁private ▁Absence ▁load Absence From Rs ( ResultSet ▁pRs ) ▁throws ▁SQLException , ▁Invalid ValueException { ▁Absence ▁absence ▁= ▁new ▁Absence (); ▁absence . setId Absence ( pRs . getInt (" id _ absence ") ); ▁absence . setId User ( pRs . getInt (" id _ user ") ); ▁absence . set DateAbsence ( ( Date ) pRs . getDate (" date _ absence ") ); ▁absence . set IdJustify ( pRs . getInt (" id _ justify ") ); ▁absence . s etAcademicYear ( pRs . getInt (" accademic _ year ") ); ▁return ▁absence ; ▁} ▁/** ▁* ▁Con sente ▁la ▁lettura ▁di ▁un ▁ solo ▁record ▁dal ▁Result ▁Set ▁* ▁@ param ▁pRs ▁* ▁Il ▁result ▁set ▁da ▁cui ▁ estra rre ▁l ' oggetto ▁Justify ▁* ▁@ throws ▁SQLException ▁* ▁@ throws ▁Invalid ValueException ▁*/ ▁private ▁Justify ▁load Justify From Rs ( ResultSet ▁pRs ) ▁throws ▁SQLException , ▁Invalid ValueException { ▁Justify ▁justify ▁= ▁new ▁Justify (); ▁justify . set IdJustify ( pRs . getInt (" id _ justify ") ); ▁justify . setId User ( pRs . getInt (" id _ user ") ); ▁justify . set DateJustify ( ( Date ) pRs . getDate (" date _ justify ") ); ▁justify . s etAcademicYear ( pRs . getInt (" accademic _ year ") ); ▁return ▁justify ; ▁} ▁/** ▁* ▁Con sente ▁la ▁lettura ▁di ▁un ▁ solo ▁record ▁dal ▁Result ▁Set ▁* ▁@ param ▁pRs ▁* ▁Il ▁result ▁set ▁da ▁cui ▁ estra rre ▁l ' oggetto ▁Note ▁* ▁@ throws ▁SQLException ▁* ▁@ throws ▁Invalid ValueException ▁*/ ▁private ▁Note ▁load Note From Rs ( ResultSet ▁pRs ) ▁throws ▁SQLException , ▁Invalid ValueException { ▁Note ▁note = ▁new ▁Note (); ▁note . set IdNote ( pRs . getInt (" id _ note ") ); ▁note . setId User ( pRs . getInt (" id _ user ") ); ▁note . set DateNote ( ( Date ) pRs . getDate (" date _ note ") ); ▁note . set Description ( pRs . getString (" description ") ); ▁note . set Teacher ( pRs . getString (" teacher ") ); ▁note . s etAcademicYear ( pRs . getInt (" accademic _ year ") ); ▁return ▁note ; ▁} ▁/** ▁* ▁Con sente ▁la ▁lettura ▁di ▁un ▁ solo ▁record ▁dal ▁Result ▁Set ▁* ▁@ param ▁pRs ▁* ▁Il ▁result ▁set ▁da ▁cui ▁ estra rre ▁l ' oggetto ▁Delay ▁* ▁@ throws ▁SQLException ▁* ▁@ throws ▁Invalid ValueException ▁*/ ▁private ▁Delay ▁load Delay From Rs ( ResultSet ▁pRs ) ▁throws ▁SQLException , ▁Invalid ValueException { ▁Delay ▁delay ▁= ▁new ▁Delay (); ▁delay . set IdDelay ( pRs . getInt (" id _ delay ") ); ▁delay . setId User ( pRs . getInt (" id _ user ") ); ▁delay . set DateDelay ( ( Date ) pRs . getDate (" date _ delay ") ); ▁delay . set TimeDelay ( pRs . getString (" time _ delay ") ); ▁delay . s etAcademicYear ( pRs . getInt (" accademic _ year ") ); ▁return ▁delay ; ▁} ▁}