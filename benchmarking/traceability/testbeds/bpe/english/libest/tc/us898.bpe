▁/* ---------------- -- ---------------- ---------------- ---------------- ▁* ▁us 898 . c ▁- ▁Unit ▁Test s ▁for ▁User ▁S tory ▁ 898 ▁- ▁Client ▁re - enroll ▁* ▁* ▁October , ▁2013 ▁* ▁* ▁Copy right ▁( c ) ▁2013 , ▁2016 ▁by ▁ cisco ▁System s , ▁Inc . ▁* ▁All ▁rights ▁ reserved . ▁* -- ---------------- ---------------- ---------------- ---------------- ▁*/ ▁# include ▁< s td io . h > ▁# if ndef ▁WI N 32 ▁# include ▁< uni s td . h > ▁# endif ▁# include ▁< est . h > ▁# include ▁< est _ ossl _ util . h > ▁# include ▁" test _ util s . h " ▁# include ▁" st _ server . h " ▁# include ▁< openssl / ssl . h > ▁# include ▁< openssl / x 509 v 3 . h > ▁# if def ▁HAV E _ C UNIT ▁# include ▁" CUnit / Basic . h " ▁# include ▁" CUnit / A utomat ed . h " ▁# endif ▁static ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁static ▁int ▁cacerts _ len ▁= ▁0; ▁# define ▁US 898_ SERVER _ PORT ▁2989 8 ▁# define ▁US 898_ SERVER _ IP ▁"127.0.0.1" ▁# define ▁US 898_ UID ▁" estuser " ▁# define ▁US 898_ PWD ▁" estpwd " ▁# if ndef ▁WI N 32 ▁# define ▁US 898_ CACERTS ▁" CA / estCA / cacert . crt " ▁# define ▁US 898_ TRUST _ CERTS ▁" CA / trustedcerts . crt " ▁# define ▁US 898_ SERVER _ CERTKEY ▁" CA / estCA / private / estserver cert and key . pem " ▁# define ▁US 898_ TC 2 _ CERT _ TXT ▁" US 898/ tc 2- new - cert . txt " ▁# define ▁US 898_ TC 2 _ CERT _ B 64 ▁" US 898/ tc 2- new - cert . pkcs 7 b 64" ▁# define ▁US 898_ TC 2 _ CERT _ PK 7 ▁" US 898/ tc 2- new - cert . pkcs 7 " ▁# define ▁US 898_ TC 2 _ CERT _ PEM ▁" US 898/ tc 2- new - cert . pem " ▁# define ▁US 898_ TC 10_ CSR ▁" US 898/ tc 10_ csr . pem " ▁# define ▁US 898_ TC 10_ KEY ▁" US 898/ tc 10_ key . pem " ▁# define ▁US 898_ TC 10_ CERT ▁" US 898/ tc 10_ cert . pem " ▁# define ▁US 898_ TC 11_ KEY ▁" US 898/ tc 11_ key . pem " ▁# define ▁US 898_ TC 11_ CERT ▁" US 898/ tc 11_ cert . pem " ▁# else ▁# define ▁US 898_ CACERTS ▁" CA \\ estCA \\ cacert . crt " ▁# define ▁US 898_ TRUST _ CERTS ▁" CA \\ trustedcerts . crt " ▁# define ▁US 898_ SERVER _ CERTKEY ▁" CA \\ estCA \\ private \\ estserver cert and key . pem " ▁# define ▁US 898_ TC 2 _ CERT _ TXT ▁" US 898 \\ tc 2- new - cert . txt " ▁# define ▁US 898_ TC 2 _ CERT _ B 64 ▁" US 898 \\ tc 2- new - cert . pkcs 7 b 64" ▁# define ▁US 898_ TC 2 _ CERT _ PK 7 ▁" US 898 \\ tc 2- new - cert . pkcs 7 " ▁# define ▁US 898_ TC 2 _ CERT _ PEM ▁" US 898 \\ tc 2- new - cert . pem " ▁# define ▁US 898_ TC 10_ CSR ▁" US 898 \\ tc 10_ csr . pem " ▁# define ▁US 898_ TC 10_ KEY ▁" US 898 \\ tc 10_ key . pem " ▁# define ▁US 898_ TC 10_ CERT ▁" US 898 \\ tc 10_ cert . pem " ▁# define ▁US 898_ TC 11_ KEY ▁" US 898 \\ tc 11_ key . pem " ▁# define ▁US 898_ TC 11_ CERT ▁" US 898 \\ tc 11_ cert . pem " ▁static ▁ CRI TICA L _ SE CTION ▁logger _ critical _ section ; ▁static ▁void ▁us 898_ logger _ stderr ▁( char ▁* format , ▁va _ list ▁l ) ▁{ ▁ Enter CriticalSection (& logger _ critical _ section ); ▁vf printf ( stderr , ▁format , ▁l ); ▁f flu sh ( stderr ); ▁ Leav eCriticalSection (& logger _ critical _ section ); ▁} ▁# endif ▁static ▁void ▁us 898_ clean ▁( void ) ▁{ ▁char ▁cmd [20 0 ] ; ▁/* ▁* ▁These ▁are ▁all ▁temp or ary ▁file s ▁created ▁* ▁by ▁the ▁vari ous ▁test ▁cases . ▁*/ ▁# if ndef ▁WI N 32 ▁ s printf ( cmd , ▁" rm ▁% s ", ▁US 898_ TC 2 _ CERT _ TXT ); ▁system ( cmd ); ▁ s printf ( cmd , ▁" rm ▁% s ", ▁US 898_ TC 2 _ CERT _ B 64 ); ▁system ( cmd ); ▁ s printf ( cmd , ▁" rm ▁% s ", ▁US 898_ TC 2 _ CERT _ PK 7 ); ▁system ( cmd ); ▁ s printf ( cmd , ▁" rm ▁% s ", ▁US 898_ TC 2 _ CERT _ PEM ); ▁system ( cmd ); ▁ s printf ( cmd , ▁" rm ▁% s ", ▁US 898_ TC 10_ CERT ); ▁system ( cmd ); ▁ s printf ( cmd , ▁" rm ▁% s ", ▁US 898_ TC 10_ KEY ); ▁system ( cmd ); ▁ s printf ( cmd , ▁" rm ▁% s ", ▁US 898_ TC 10_ CSR ); ▁system ( cmd ); ▁# else ▁ s printf ( cmd , ▁" del ▁% s ", ▁US 898_ TC 2 _ CERT _ TXT ); ▁system ( cmd ); ▁ s printf ( cmd , ▁" del ▁% s ", ▁US 898_ TC 2 _ CERT _ B 64 ); ▁system ( cmd ); ▁ s printf ( cmd , ▁" del ▁% s ", ▁US 898_ TC 2 _ CERT _ PK 7 ); ▁system ( cmd ); ▁ s printf ( cmd , ▁" del ▁% s ", ▁US 898_ TC 2 _ CERT _ PEM ); ▁system ( cmd ); ▁ s printf ( cmd , ▁" del ▁% s ", ▁US 898_ TC 10_ CERT ); ▁system ( cmd ); ▁ s printf ( cmd , ▁" del ▁% s ", ▁US 898_ TC 10_ KEY ); ▁system ( cmd ); ▁ s printf ( cmd , ▁" del ▁% s ", ▁US 898_ TC 10_ CSR ); ▁system ( cmd ); ▁# endif ▁} ▁/* ▁* ▁This ▁start s ▁an ▁instance ▁of ▁the ▁EST ▁server ▁running ▁on ▁* ▁a ▁separate ▁thread . ▁We ▁use ▁this ▁to ▁test ▁the ▁* ▁client ▁side ▁API ▁in ▁this ▁ module . ▁*/ ▁static ▁int ▁us 898_ start _ server ▁( int ▁manual _ enroll , ▁int ▁nid ) ▁{ ▁int ▁rv ; ▁rv ▁= ▁st _ start ( US 898_ SERVER _ PORT , ▁US 898_ SERVER _ CERTKEY , ▁US 898_ SERVER _ CERTKEY , ▁" estrealm ", ▁US 898_ CACERTS , ▁US 898_ TRUST _ CERTS , ▁" US 898/ est Example CA . cnf ", ▁manual _ enroll , ▁0, ▁nid ); ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁initialize s ▁this ▁test ▁* ▁suite . ▁This ▁can ▁be ▁used ▁to ▁allocate ▁data ▁or ▁open ▁any ▁* ▁ resources ▁required ▁for ▁all ▁the ▁test ▁cases . ▁*/ ▁static ▁int ▁us 898_ init _ suite ▁( void ) ▁{ ▁int ▁rv ; ▁# if def ▁WI N 32 ▁Initialize CriticalSection ▁ (& logger _ critical _ section ); ▁est _ init _ logger ( EST _ LOG _ L VL _ INFO , ▁& us 898_ logger _ stderr ); ▁# endif ▁/* ▁* ▁ Read ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( US 898_ CACERTS , ▁& cacerts ); ▁if ▁( cacerts _ len ▁< = ▁0) ▁{ ▁return ▁1; ▁} ▁us 898_ clean (); ▁/* ▁* ▁Start ▁an ▁instance ▁of ▁the ▁EST ▁server ▁with ▁* ▁automatic ▁enrollment ▁enabled . ▁*/ ▁rv ▁= ▁us 898_ start _ server (0, ▁0); ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁uninitialize s ▁this ▁test ▁* ▁suite . ▁This ▁can ▁be ▁used ▁to ▁de allocate ▁data ▁or ▁close ▁any ▁* ▁ resources ▁that ▁we re ▁used ▁for ▁the ▁test ▁cases . ▁*/ ▁static ▁int ▁us 898_ destroy _ suite ▁( void ) ▁{ ▁st _ stop (); ▁free ( cacerts ); ▁return ▁0; ▁} ▁static ▁E VP _ PKEY ▁* ▁generate _ private _ key ▁( void ) ▁{ ▁RSA ▁* rsa ▁= ▁RSA _ new (); ▁B IG NUM ▁* bn ▁= ▁BN _ new (); ▁E VP _ PKEY ▁* pkey ; ▁/* ▁* ▁create ▁an ▁RSA ▁ keypair ▁and ▁assign ▁them ▁to ▁a ▁ PKEY ▁and ▁return ▁it . ▁*/ ▁BN _ set _ word ( bn , ▁0 x 1000 1); ▁RSA _ generate _ key _ ex ( rsa , ▁1024 , ▁bn , ▁NULL ); ▁pkey ▁= ▁E VP _ PKEY _ new (); ▁if ▁( pkey == NULL ) ▁{ ▁ printf ("\ nError ▁allocat ing ▁ PKEY ▁structure ▁for ▁new ▁key ▁pair \ n "); ▁return ▁NULL ; ▁} ▁if ▁(! E VP _ PKEY _ set 1 _ RSA ( pkey , ▁rsa )) ▁{ ▁ printf ("\ nError ▁assign ing ▁RSA ▁key ▁pair ▁to ▁ PKEY ▁structure \ n "); ▁return ▁NULL ; ▁} ▁RSA _ free ( rsa ); ▁BN _ free ( bn ); ▁return ▁( pkey ); ▁} ▁/* ▁* ▁C allback ▁function ▁passed ▁to ▁est _ client _ init () ▁*/ ▁static ▁int ▁client _ manual _ cert _ verify ( X 509 ▁* cur _ cert , ▁int ▁openssl _ cert _ error ) ▁{ ▁BIO ▁* bio _ err ; ▁bio _ err = BIO _ new _ fp ( stderr , BIO _ NO CLOSE ); ▁int ▁approve ▁= ▁0; ▁if ▁( openssl _ cert _ error ▁== ▁X 509_ V _ ERR _ U NABLE _ TO _ GET _ CRL ) ▁{ ▁return ▁ (1); ▁} ▁/* ▁* ▁ Print ▁out ▁the ▁specific s ▁of ▁this ▁cert ▁*/ ▁ printf ("% s : ▁OpenSSL / EST ▁server ▁cert ▁verification ▁failed ▁with ▁the ▁following ▁error : ▁openssl _ cert _ error ▁= ▁% d ▁(% s ) \ n ", ▁ _ _ FUNCTION _ _ , ▁openssl _ cert _ error , ▁X 509_ verify _ cert _ error _ string ( openssl _ cert _ error )); ▁ printf (" Fail ing ▁Cert :\ n "); ▁X 509_ print _ fp ( stdout , cur _ cert ); ▁/* ▁* ▁ Next ▁call ▁print s ▁out ▁the ▁signature ▁which ▁can ▁be ▁used ▁as ▁the ▁fingerprint ▁* ▁This ▁fingerprint ▁can ▁be ▁checked ▁against ▁the ▁an ticipat ed ▁value ▁to ▁determine ▁* ▁whether ▁or ▁not ▁the ▁server ' s ▁cert ▁should ▁be ▁approved . ▁*/ ▁// ▁X 509_ signature _ print ( bio _ err , ▁cur _ cert -> sig _ alg , ▁cur _ cert -> signature ); ▁BIO _ free ( bio _ err ); ▁return ▁approve ; ▁} ▁/* ▁* ▁This ▁function ▁perform s ▁a ▁basic ▁simple ▁enroll ▁using ▁* ▁a ▁UID / PWD ▁to ▁identify ▁the ▁client ▁to ▁the ▁server . ▁This ▁* ▁is ▁used ▁for ▁a ▁variet ▁of ▁test ▁cases ▁in ▁this ▁ module . ▁*/ ▁static ▁void ▁us 898_ test 1 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁int ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁PKCS 7 ▁* p 7 ▁= ▁NULL ; ▁BIO ▁* b 64, ▁* out ; ▁X 509 ▁* cert ▁= ▁NULL ; ▁STA CK _ OF ( X 509 ) ▁* certs ▁= ▁NULL ; ▁int ▁i ; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁LOG _ FUNC _ NM ; ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁US 898_ UID , ▁US 898_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 898_ SERVER _ IP , ▁US 898_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ private _ key (); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ectx , ▁" TC - US 898-1 ", ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁return ; ▁/* ▁* ▁Retrieve ▁the ▁cert ▁that ▁was ▁given ▁to ▁us ▁by ▁the ▁EST ▁server ▁*/ ▁if ▁( rv ▁== ▁EST _ ERR _ NONE ) ▁{ ▁new _ cert ▁= ▁malloc ( pkcs 7_ len ); ▁CU _ ASSERT ( new _ cert ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ copy _ enrolled _ cert ( ectx , ▁new _ cert ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Convert ▁the ▁cert ▁to ▁an ▁X 509 . ▁Be ▁warn ed ▁this ▁is ▁* ▁pure ▁hack ery . ▁*/ ▁b 64 ▁= ▁BIO _ new ( BIO _ f _ base 64 ()); ▁out ▁= ▁BIO _ new _ mem _ buf ( new _ cert , ▁pkcs 7_ len ); ▁out ▁= ▁BIO _ push ( b 64, ▁out ); ▁p 7 ▁= ▁d 2 i _ PKCS 7_ bio ( out , NULL ); ▁CU _ ASSERT ( p 7 ▁ != ▁NULL ); ▁BIO _ free _ all ( out ); ▁i = OBJ _ obj 2 nid ( p 7-> type ); ▁switch ▁( i ) ▁{ ▁case ▁NID _ pkcs 7_ signed : ▁certs ▁= ▁p 7-> d . sign -> cert ; ▁break ; ▁case ▁NID _ pkcs 7_ signed And Enveloped : ▁certs ▁= ▁p 7-> d . signed _ and _ e nveloped -> cert ; ▁break ; ▁default : ▁break ; ▁} ▁CU _ ASSERT ( certs ▁ != ▁NULL ); ▁if ▁(! certs ) ▁return ; ▁/* ▁our ▁new ▁cert ▁should ▁be ▁the ▁one ▁and ▁only ▁* ▁cert ▁in ▁the ▁pkcs 7 ▁blob . ▁We ▁should n ' t ▁have ▁to ▁* ▁iterate ▁through ▁the ▁full ▁list ▁to ▁find ▁it . ▁*/ ▁cert ▁= ▁sk _ X 509_ value ( certs , ▁0); ▁CU _ ASSERT ( cert ▁ != ▁NULL ); ▁/* ▁* ▁W ow , ▁that ' s ▁a ▁lo t ▁of ▁work , ▁but ▁we ▁finally ▁have ▁the ▁X 509 . ▁* ▁( d on ' t ▁you ▁just ▁lo ve ▁OpenSSL !!! ) ▁* ▁ Now ▁that ▁we ▁have ▁an ▁X 509 ▁representation ▁of ▁the ▁cert , ▁* ▁let ' s ▁try ▁to ▁re - enroll ▁this ▁cert ▁with ▁the ▁CA ▁*/ ▁rv ▁= ▁est _ client _ reenroll ( ectx , ▁cert , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Cleanup ▁*/ ▁if ▁( cert ) ▁X 509_ free ( cert ); ▁E VP _ PKEY _ free ( key ); ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁est _ destroy ( ectx ); ▁} ▁/* ▁* ▁This ▁test ▁case ▁uses ▁an ▁existing ▁expired ▁cert ▁and ▁* ▁attempts ▁to ▁re - enroll ▁it . ▁The ▁expired ▁certs ▁contains ▁* ▁seve ral ▁X 509 ▁extensions . ▁We ▁verify ▁the ▁new ▁issued ▁* ▁cert ▁preserve s ▁these ▁extensions ▁using ▁grep . ▁Note , ▁* ▁pres e rv ing ▁these ▁extensions ▁requires ▁the ▁OpenSSL ▁CA ▁* ▁to ▁enable ▁the ▁" copy _ extensions " ▁k no b ▁in ▁the ▁OpenSSL ▁* ▁config ▁file . ▁This ▁is ▁wh y ▁this ▁test ▁suite ▁uses ▁a ▁* ▁unique ▁copy ▁of ▁est Example CA . cnf . ▁*/ ▁static ▁void ▁us 898_ test 2 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁un signed ▁char ▁* key _ raw ; ▁int ▁key _ len ; ▁un signed ▁char ▁* cert _ raw ; ▁int ▁cert _ len ; ▁int ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁X 509 ▁* cert ▁= ▁NULL ; ▁BIO ▁* in ; ▁char ▁cmd [20 0 ] ; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁LOG _ FUNC _ NM ; ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁US 898_ UID , ▁US 898_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 898_ SERVER _ IP , ▁US 898_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁*/ ▁key _ len ▁= ▁read _ binary _ file (" US 898/ key - expired . pem ", ▁& key _ raw ); ▁CU _ ASSERT ( key _ len ▁> ▁0); ▁key ▁= ▁est _ load _ key ( key _ raw , ▁key _ len , ▁EST _ FORMAT _ PEM ); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁free ( key _ raw ); ▁/* ▁* ▁ Read ▁in ▁the ▁old ▁cert ▁*/ ▁cert _ len ▁= ▁read _ binary _ file (" US 898/ cert - expired . pem ", ▁& cert _ raw ); ▁CU _ ASSERT ( cert _ len ▁> ▁0); ▁in ▁= ▁BIO _ new _ mem _ buf ( cert _ raw , ▁cert _ len ); ▁CU _ ASSERT ( in ▁ != ▁NULL ); ▁if ▁(! in ) ▁return ; ▁cert ▁= ▁PEM _ read _ bio _ X 509_ AU X ( in , ▁NULL , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( cert ▁ != ▁NULL ); ▁if ▁(! cert ) ▁return ; ▁BIO _ free _ all ( in ); ▁free ( cert _ raw ); ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Enroll ▁an ▁expired ▁cert ▁that ▁contains ▁x 509 ▁extensions . ▁*/ ▁rv ▁= ▁est _ client _ reenroll ( ectx , ▁cert , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Retrieve ▁the ▁cert ▁that ▁was ▁given ▁to ▁us ▁by ▁the ▁EST ▁server ▁*/ ▁if ▁( rv ▁== ▁EST _ ERR _ NONE ) ▁{ ▁new _ cert ▁= ▁malloc ( pkcs 7_ len ); ▁CU _ ASSERT ( new _ cert ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ copy _ enrolled _ cert ( ectx , ▁new _ cert ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁ Save ▁the ▁cert ▁to ▁a ▁local ▁file ▁*/ ▁rv ▁= ▁write _ binary _ file ( US 898_ TC 2 _ CERT _ B 64, ▁new _ cert , ▁pkcs 7_ len ); ▁CU _ ASSERT ( rv ▁== ▁1); ▁/* ▁* ▁Base ▁64 ▁decode ▁the ▁cert ▁response ▁*/ ▁ s printf ( cmd , ▁" openssl ▁base 64 ▁- d ▁- in ▁% s ▁- out ▁% s ", ▁US 898_ TC 2 _ CERT _ B 64, ▁US 898_ TC 2 _ CERT _ PK 7 ); ▁rv ▁= ▁system ( cmd ); ▁CU _ ASSERT ( rv ▁== ▁0); ▁/* ▁* ▁Convert ▁the ▁pkcs 7 ▁cert ▁to ▁a ▁PEM ▁cert ▁*/ ▁ s printf ( cmd , ▁" openssl ▁pkcs 7 ▁- in ▁% s ▁- inform ▁DER ▁- print _ certs ▁- out ▁% s ", ▁US 898_ TC 2 _ CERT _ PK 7, ▁US 898_ TC 2 _ CERT _ PEM ); ▁rv ▁= ▁system ( cmd ); ▁CU _ ASSERT ( rv ▁== ▁0); ▁/* ▁* ▁Convert ▁PEM ▁cert ▁to ▁a ▁text ual ▁representation ▁of ▁the ▁cert ▁*/ ▁ s printf ( cmd , ▁" openssl ▁x 509 ▁- text ▁- in ▁% s ▁> ▁% s ", ▁US 898_ TC 2 _ CERT _ PEM , ▁US 898_ TC 2 _ CERT _ TXT ); ▁rv ▁= ▁system ( cmd ); ▁CU _ ASSERT ( rv ▁== ▁0); ▁/* ▁* ▁Verify ▁the ▁ jimbob ▁ DNS ▁extension ▁was ▁p reserved ▁*/ ▁rv ▁= ▁grep ( US 898_ TC 2 _ CERT _ TXT , ▁" jimbob "); ▁CU _ ASSERT ( rv ▁== ▁0); ▁/* ▁* ▁Verify ▁the ▁ bobcat ▁ DNS ▁extension ▁was ▁p reserved ▁*/ ▁rv ▁= ▁grep ( US 898_ TC 2 _ CERT _ TXT , ▁" bobcat "); ▁CU _ ASSERT ( rv ▁== ▁0); ▁/* ▁* ▁Verify ▁the ▁IP ▁address ▁extension ▁was ▁p reserved ▁*/ ▁rv ▁= ▁grep ( US 898_ TC 2 _ CERT _ TXT , " 17 2 "); ▁CU _ ASSERT ( rv ▁== ▁0); ▁/* ▁* ▁Verify ▁the ▁ Repudiation ▁key ▁usage ▁extension ▁was ▁p reserved ▁*/ ▁rv ▁= ▁grep ( US 898_ TC 2 _ CERT _ TXT , " Repudiation "); ▁CU _ ASSERT ( rv ▁== ▁0); ▁/* ▁* ▁Verify ▁the ▁public ▁key ▁was ▁p reserved ▁*/ ▁rv ▁= ▁grep ( US 898_ TC 2 _ CERT _ TXT , ▁" 0 0 : e 3 : ca : 38 : 65 : f b : 9 c : 46: a 6 : 22: b 1 : b e : 17 : b c : 50 "); ▁CU _ ASSERT ( rv ▁== ▁0); ▁/* ▁* ▁Clean ▁up ▁*/ ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁est _ destroy ( ectx ); ▁} ▁/* ▁* ▁Test ▁the ▁re - enroll ▁API ▁to ▁ensure ▁it ▁gracefully ▁* ▁handle s ▁a ▁null ▁X 509 ▁cert ▁pointer . ▁*/ ▁static ▁void ▁us 898_ test 3 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁int ▁rv ; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁LOG _ FUNC _ NM ; ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁US 898_ UID , ▁US 898_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 898_ SERVER _ IP , ▁US 898_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ private _ key (); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁re - enroll ▁using ▁a ▁null ▁x 509 ▁pointer . ▁*/ ▁rv ▁= ▁est _ client _ reenroll ( ectx , ▁NULL , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NO _ CERT ); ▁/* ▁* ▁Clean ▁up ▁*/ ▁E VP _ PKEY _ free ( key ); ▁est _ destroy ( ectx ); ▁} ▁/* ▁* ▁Test ▁the ▁re - enroll ▁API ▁to ▁ensure ▁it ▁gracefully ▁* ▁handle s ▁a ▁null ▁E VP _ PKEY ▁pointer . ▁*/ ▁static ▁void ▁us 898_ test 4 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁int ▁rv ; ▁X 509 ▁* cert ▁= ▁NULL ; ▁un signed ▁char ▁* cert _ raw ; ▁int ▁cert _ len ; ▁BIO ▁* in ; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁LOG _ FUNC _ NM ; ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁US 898_ UID , ▁US 898_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 898_ SERVER _ IP , ▁US 898_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁ Read ▁in ▁an ▁old ▁cert ▁that ▁we ▁can ▁use ▁for ▁re - enroll ▁*/ ▁cert _ len ▁= ▁read _ binary _ file (" US 898/ cert - expired . pem ", ▁& cert _ raw ); ▁CU _ ASSERT ( cert _ len ▁> ▁0); ▁in ▁= ▁BIO _ new _ mem _ buf ( cert _ raw , ▁cert _ len ); ▁CU _ ASSERT ( in ▁ != ▁NULL ); ▁if ▁(! in ) ▁return ; ▁cert ▁= ▁PEM _ read _ bio _ X 509_ AU X ( in , ▁NULL , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( cert ▁ != ▁NULL ); ▁if ▁(! cert ) ▁return ; ▁BIO _ free _ all ( in ); ▁free ( cert _ raw ); ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁re - enroll ▁using ▁a ▁null ▁E VP _ KEY ▁pointer . ▁*/ ▁rv ▁= ▁est _ client _ reenroll ( ectx , ▁cert , ▁& pkcs 7_ len , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NO _ KEY ); ▁/* ▁* ▁Clean ▁up ▁*/ ▁X 509_ free ( cert ); ▁est _ destroy ( ectx ); ▁} ▁/* ▁* ▁This ▁test ▁attempts ▁to ▁re - enroll ▁a ▁corrupted ▁cert ▁* ▁The ▁public ▁key ▁in ▁the ▁cert ▁is ▁has ▁been ▁corrupted . ▁*/ ▁static ▁void ▁us 898_ test 5 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁un signed ▁char ▁* key _ raw ; ▁int ▁key _ len ; ▁un signed ▁char ▁* cert _ raw ; ▁int ▁cert _ len ; ▁int ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁X 509 ▁* cert ▁= ▁NULL ; ▁BIO ▁* in ; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁LOG _ FUNC _ NM ; ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁US 898_ UID , ▁US 898_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 898_ SERVER _ IP , ▁US 898_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁*/ ▁key _ len ▁= ▁read _ binary _ file (" US 898/ key - corrupt . pem ", ▁& key _ raw ); ▁CU _ ASSERT ( key _ len ▁> ▁0); ▁key ▁= ▁est _ load _ key ( key _ raw , ▁key _ len , ▁EST _ FORMAT _ PEM ); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁free ( key _ raw ); ▁/* ▁* ▁ Read ▁in ▁the ▁old ▁cert ▁*/ ▁cert _ len ▁= ▁read _ binary _ file (" US 898/ cert - corrupt . pem ", ▁& cert _ raw ); ▁CU _ ASSERT ( cert _ len ▁> ▁0); ▁in ▁= ▁BIO _ new _ mem _ buf ( cert _ raw , ▁cert _ len ); ▁CU _ ASSERT ( in ▁ != ▁NULL ); ▁if ▁(! in ) ▁return ; ▁cert ▁= ▁PEM _ read _ bio _ X 509_ AU X ( in , ▁NULL , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( cert ▁ != ▁NULL ); ▁if ▁(! cert ) ▁return ; ▁BIO _ free _ all ( in ); ▁free ( cert _ raw ); ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Enroll ▁an ▁expired ▁cert ▁that ▁contains ▁x 509 ▁extensions . ▁*/ ▁rv ▁= ▁est _ client _ reenroll ( ectx , ▁cert , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ CLIENT _ INVALID _ KEY ); ▁/* ▁* ▁Clean ▁up ▁*/ ▁est _ destroy ( ectx ); ▁} ▁/* ▁* ▁This ▁test ▁attempts ▁to ▁re - enroll ▁an ▁expired ▁cert ▁* ▁while ▁the ▁EST ▁server ▁is ▁configured ▁for ▁manual ▁* ▁approval . ▁The ▁server ▁will ▁send ▁back ▁a ▁retry - after ▁* ▁response . ▁*/ ▁static ▁void ▁us 898_ test 6 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁un signed ▁char ▁* key _ raw ; ▁int ▁key _ len ; ▁un signed ▁char ▁* cert _ raw ; ▁int ▁cert _ len ; ▁int ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁X 509 ▁* cert ▁= ▁NULL ; ▁BIO ▁* in ; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁LOG _ FUNC _ NM ; ▁/* ▁* ▁S top ▁the ▁server . ▁*/ ▁st _ stop (); ▁/* ▁* ▁Re start ▁the ▁server ▁with ▁manual ▁approval ▁enabled ▁*/ ▁rv ▁= ▁us 898_ start _ server ( 1, ▁0); ▁CU _ ASSERT ( rv ▁== ▁0); ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁US 898_ UID , ▁US 898_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 898_ SERVER _ IP , ▁US 898_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁*/ ▁key _ len ▁= ▁read _ binary _ file (" US 898/ key - expired . pem ", ▁& key _ raw ); ▁CU _ ASSERT ( key _ len ▁> ▁0); ▁key ▁= ▁est _ load _ key ( key _ raw , ▁key _ len , ▁EST _ FORMAT _ PEM ); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁free ( key _ raw ); ▁/* ▁* ▁ Read ▁in ▁the ▁old ▁cert ▁*/ ▁cert _ len ▁= ▁read _ binary _ file (" US 898/ cert - expired . pem ", ▁& cert _ raw ); ▁CU _ ASSERT ( cert _ len ▁> ▁0); ▁in ▁= ▁BIO _ new _ mem _ buf ( cert _ raw , ▁cert _ len ); ▁CU _ ASSERT ( in ▁ != ▁NULL ); ▁if ▁(! in ) ▁return ; ▁cert ▁= ▁PEM _ read _ bio _ X 509_ AU X ( in , ▁NULL , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( cert ▁ != ▁NULL ); ▁if ▁(! cert ) ▁return ; ▁BIO _ free _ all ( in ); ▁free ( cert _ raw ); ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Enroll ▁an ▁expired ▁cert ▁that ▁contains ▁x 509 ▁extensions . ▁*/ ▁rv ▁= ▁est _ client _ reenroll ( ectx , ▁cert , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ CA _ ENROLL _ RETRY ); ▁/* ▁* ▁Clean ▁up ▁*/ ▁est _ destroy ( ectx ); ▁/* ▁* ▁S top ▁the ▁server . ▁*/ ▁st _ stop (); ▁/* ▁* ▁Re start ▁the ▁server ▁with ▁manual ▁approval ▁disabled ▁*/ ▁rv ▁= ▁us 898_ start _ server (0, ▁0); ▁CU _ ASSERT ( rv ▁== ▁0); ▁} ▁/* ▁* ▁Verify ▁that ▁a ▁bogus ▁user ▁ID / password ▁fails ▁when ▁* ▁using ▁HTTP ▁basic ▁auth . ▁*/ ▁static ▁void ▁us 898_ test 7 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁un signed ▁char ▁* key _ raw ; ▁int ▁key _ len ; ▁un signed ▁char ▁* cert _ raw ; ▁int ▁cert _ len ; ▁int ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁X 509 ▁* cert ▁= ▁NULL ; ▁BIO ▁* in ; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁LOG _ FUNC _ NM ; ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁" h o a g ie ", ▁" c h i li ", ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 898_ SERVER _ IP , ▁US 898_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁*/ ▁key _ len ▁= ▁read _ binary _ file (" US 898/ key - expired . pem ", ▁& key _ raw ); ▁CU _ ASSERT ( key _ len ▁> ▁0); ▁key ▁= ▁est _ load _ key ( key _ raw , ▁key _ len , ▁EST _ FORMAT _ PEM ); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁free ( key _ raw ); ▁/* ▁* ▁ Read ▁in ▁the ▁old ▁cert ▁*/ ▁cert _ len ▁= ▁read _ binary _ file (" US 898/ cert - expired . pem ", ▁& cert _ raw ); ▁CU _ ASSERT ( cert _ len ▁> ▁0); ▁in ▁= ▁BIO _ new _ mem _ buf ( cert _ raw , ▁cert _ len ); ▁CU _ ASSERT ( in ▁ != ▁NULL ); ▁if ▁(! in ) ▁return ; ▁cert ▁= ▁PEM _ read _ bio _ X 509_ AU X ( in , ▁NULL , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( cert ▁ != ▁NULL ); ▁if ▁(! cert ) ▁return ; ▁BIO _ free _ all ( in ); ▁free ( cert _ raw ); ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Enroll ▁an ▁expired ▁cert ▁that ▁contains ▁x 509 ▁extensions . ▁*/ ▁rv ▁= ▁est _ client _ reenroll ( ectx , ▁cert , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ AUTH _ FAIL ); ▁est _ destroy ( ectx ); ▁} ▁/* ▁* ▁Verify ▁that ▁a ▁good ▁user ▁ID / password ▁passes ▁when ▁* ▁using ▁HTTP ▁digest ▁auth . ▁*/ ▁static ▁void ▁us 898_ test 8 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁un signed ▁char ▁* key _ raw ; ▁int ▁key _ len ; ▁un signed ▁char ▁* cert _ raw ; ▁int ▁cert _ len ; ▁int ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁X 509 ▁* cert ▁= ▁NULL ; ▁BIO ▁* in ; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁LOG _ FUNC _ NM ; ▁/* ▁* ▁E nable ▁HTTP ▁digest ▁authentication ▁*/ ▁st _ enable _ http _ digest _ auth (); ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁US 898_ UID , ▁US 898_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 898_ SERVER _ IP , ▁US 898_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁*/ ▁key _ len ▁= ▁read _ binary _ file (" US 898/ key - expired . pem ", ▁& key _ raw ); ▁CU _ ASSERT ( key _ len ▁> ▁0); ▁key ▁= ▁est _ load _ key ( key _ raw , ▁key _ len , ▁EST _ FORMAT _ PEM ); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁free ( key _ raw ); ▁/* ▁* ▁ Read ▁in ▁the ▁old ▁cert ▁*/ ▁cert _ len ▁= ▁read _ binary _ file (" US 898/ cert - expired . pem ", ▁& cert _ raw ); ▁CU _ ASSERT ( cert _ len ▁> ▁0); ▁in ▁= ▁BIO _ new _ mem _ buf ( cert _ raw , ▁cert _ len ); ▁CU _ ASSERT ( in ▁ != ▁NULL ); ▁if ▁(! in ) ▁return ; ▁cert ▁= ▁PEM _ read _ bio _ X 509_ AU X ( in , ▁NULL , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( cert ▁ != ▁NULL ); ▁if ▁(! cert ) ▁return ; ▁BIO _ free _ all ( in ); ▁free ( cert _ raw ); ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Enroll ▁an ▁expired ▁cert ▁that ▁contains ▁x 509 ▁extensions . ▁*/ ▁rv ▁= ▁est _ client _ reenroll ( ectx , ▁cert , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁est _ destroy ( ectx ); ▁/* ▁* ▁Re - enable ▁HTTP ▁basic ▁authentication ▁*/ ▁st _ enable _ http _ basic _ auth (); ▁} ▁/* ▁* ▁Verify ▁that ▁a ▁bogus ▁user ▁ID / password ▁fails ▁when ▁* ▁using ▁HTTP ▁digest ▁auth . ▁*/ ▁static ▁void ▁us 898_ test 9 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁un signed ▁char ▁* key _ raw ; ▁int ▁key _ len ; ▁un signed ▁char ▁* cert _ raw ; ▁int ▁cert _ len ; ▁int ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁X 509 ▁* cert ▁= ▁NULL ; ▁BIO ▁* in ; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁int ▁http _ status ; ▁LOG _ FUNC _ NM ; ▁/* ▁* ▁E nable ▁HTTP ▁digest ▁authentication ▁*/ ▁st _ enable _ http _ digest _ auth (); ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁" j do e ", ▁" p an ther s ", ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 898_ SERVER _ IP , ▁US 898_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁*/ ▁key _ len ▁= ▁read _ binary _ file (" US 898/ key - expired . pem ", ▁& key _ raw ); ▁CU _ ASSERT ( key _ len ▁> ▁0); ▁key ▁= ▁est _ load _ key ( key _ raw , ▁key _ len , ▁EST _ FORMAT _ PEM ); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁free ( key _ raw ); ▁/* ▁* ▁ Read ▁in ▁the ▁old ▁cert ▁*/ ▁cert _ len ▁= ▁read _ binary _ file (" US 898/ cert - expired . pem ", ▁& cert _ raw ); ▁CU _ ASSERT ( cert _ len ▁> ▁0); ▁in ▁= ▁BIO _ new _ mem _ buf ( cert _ raw , ▁cert _ len ); ▁CU _ ASSERT ( in ▁ != ▁NULL ); ▁if ▁(! in ) ▁return ; ▁cert ▁= ▁PEM _ read _ bio _ X 509_ AU X ( in , ▁NULL , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( cert ▁ != ▁NULL ); ▁if ▁(! cert ) ▁return ; ▁BIO _ free _ all ( in ); ▁free ( cert _ raw ); ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Enroll ▁an ▁expired ▁cert ▁that ▁contains ▁x 509 ▁extensions . ▁*/ ▁rv ▁= ▁est _ client _ reenroll ( ectx , ▁cert , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ AUTH _ FAIL ); ▁/* ▁* ▁Check ▁the ▁HTTP ▁status ▁code ▁from ▁the ▁reenroll ▁operation ▁*/ ▁http _ status ▁= ▁est _ client _ get _ last _ http _ status ( ectx ); ▁CU _ ASSERT ( http _ status ▁== ▁401 ); ▁est _ destroy ( ectx ); ▁/* ▁* ▁Re - enable ▁HTTP ▁basic ▁authentication ▁*/ ▁st _ enable _ http _ basic _ auth (); ▁} ▁/* ▁* ▁Verify ▁the ▁server ▁fails ▁authentication ▁when ▁the ▁* ▁client ▁send s ▁a ▁valid ▁identity ▁cert ▁but ▁does n ' t ▁* ▁provide ▁HTTP ▁auth ▁credentials . ▁*/ ▁static ▁void ▁us 898_ test 10 ▁( void ) ▁{ ▁char ▁cmd [20 0 ] ; ▁int ▁rv ; ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁un signed ▁char ▁* key _ raw ; ▁int ▁key _ len ; ▁un signed ▁char ▁* cert _ raw ; ▁int ▁cert _ len ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁X 509 ▁* cert ▁= ▁NULL ; ▁BIO ▁* in ; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁LOG _ FUNC _ NM ; ▁/* ▁* ▁Create ▁a ▁CSR ▁*/ ▁ s printf ( cmd , ▁" openssl ▁req ▁- new ▁- node s ▁- out ▁% s ▁- new key ▁rsa : 2048 ▁- key out ▁% s ▁- subj ▁/ CN = 127 . 0 . 0 . 1 ▁" ▁" - config ▁CA / est Example CA . cnf ", ▁US 898_ TC 10_ CSR , ▁US 898_ TC 10_ KEY ); ▁rv ▁= ▁system ( cmd ); ▁CU _ ASSERT ( rv ▁== ▁0); ▁/* ▁* ▁Sign ▁the ▁CSR ▁using ▁our ▁local ▁CA ▁*/ ▁ s printf ( cmd , ▁" openssl ▁ca ▁- out ▁% s ▁- b atch ▁- config ▁CA / est Example CA . cnf ▁- in file s ▁% s ", ▁US 898_ TC 10_ CERT , ▁US 898_ TC 10_ CSR ); ▁rv ▁= ▁system ( cmd ); ▁CU _ ASSERT ( rv ▁== ▁0); ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁*/ ▁key _ len ▁= ▁read _ binary _ file ( US 898_ TC 10_ KEY , ▁& key _ raw ); ▁CU _ ASSERT ( key _ len ▁> ▁0); ▁key ▁= ▁est _ load _ key ( key _ raw , ▁key _ len , ▁EST _ FORMAT _ PEM ); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁free ( key _ raw ); ▁/* ▁* ▁ Read ▁in ▁the ▁old ▁cert ▁*/ ▁cert _ len ▁= ▁read _ binary _ file ( US 898_ TC 10_ CERT , ▁& cert _ raw ); ▁CU _ ASSERT ( cert _ len ▁> ▁0); ▁in ▁= ▁BIO _ new _ mem _ buf ( cert _ raw , ▁cert _ len ); ▁CU _ ASSERT ( in ▁ != ▁NULL ); ▁if ▁(! in ) ▁return ; ▁cert ▁= ▁PEM _ read _ bio _ X 509_ AU X ( in , ▁NULL , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( cert ▁ != ▁NULL ); ▁if ▁(! cert ) ▁return ; ▁BIO _ free _ all ( in ); ▁free ( cert _ raw ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁the ▁certificate ▁* ▁No ▁HTTP ▁auth ▁credentials ▁are ▁provided . ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁NULL , ▁NULL , ▁cert , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 898_ SERVER _ IP , ▁US 898_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Enroll ▁a ▁cert , ▁should ▁fail ▁because ▁we ▁* ▁did n ' t ▁provide ▁valid ▁HTTP ▁auth ▁credentials ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ectx , ▁" TC - US 898-1 0 ", ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ AUTH _ FAIL ); ▁/* ▁* ▁Re - Enroll ▁the ▁cert , ▁should ▁work ▁since ▁* ▁we ▁provide ▁a ▁valid ▁cert ▁to ▁identify ▁ourselves ▁* ▁and ▁HTTP ▁auth ▁is n ' t ▁required ▁for ▁re - enroll ▁even ▁when ▁* ▁the ▁server ▁has ▁enabled ▁HTTP ▁auth . ▁*/ ▁rv ▁= ▁est _ client _ reenroll ( ectx , ▁cert , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁est _ destroy ( ectx ); ▁} ▁/* ▁* ▁Verify ▁the ▁server ▁fails ▁authentication ▁when ▁the ▁* ▁client ▁send s ▁an ▁expired ▁id ent y ▁cert ▁and ▁uses ▁* ▁valid ▁HTTP ▁auth ▁credentials . ▁*/ ▁static ▁void ▁us 898_ test 11 ▁( void ) ▁{ ▁int ▁rv ; ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁un signed ▁char ▁* key _ raw ; ▁int ▁key _ len ; ▁un signed ▁char ▁* cert _ raw ; ▁int ▁cert _ len ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁X 509 ▁* cert ▁= ▁NULL ; ▁BIO ▁* in ; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁LOG _ FUNC _ NM ; ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁*/ ▁key _ len ▁= ▁read _ binary _ file ( US 898_ TC 11_ KEY , ▁& key _ raw ); ▁CU _ ASSERT ( key _ len ▁> ▁0); ▁key ▁= ▁est _ load _ key ( key _ raw , ▁key _ len , ▁EST _ FORMAT _ PEM ); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁free ( key _ raw ); ▁/* ▁* ▁ Read ▁in ▁the ▁old ▁cert ▁*/ ▁cert _ len ▁= ▁read _ binary _ file ( US 898_ TC 11_ CERT , ▁& cert _ raw ); ▁CU _ ASSERT ( cert _ len ▁> ▁0); ▁in ▁= ▁BIO _ new _ mem _ buf ( cert _ raw , ▁cert _ len ); ▁CU _ ASSERT ( in ▁ != ▁NULL ); ▁if ▁(! in ) ▁return ; ▁cert ▁= ▁PEM _ read _ bio _ X 509_ AU X ( in , ▁NULL , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( cert ▁ != ▁NULL ); ▁if ▁(! cert ) ▁return ; ▁BIO _ free _ all ( in ); ▁free ( cert _ raw ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁the ▁expired ▁certificate ▁* ▁and ▁valid ▁HTTP ▁auth ▁credentials . ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁US 898_ UID , ▁US 898_ PWD , ▁cert , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 898_ SERVER _ IP , ▁US 898_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ SSL _ CONNECT ); ▁/* ▁* ▁Re - Enroll ▁the ▁cert ▁*/ ▁rv ▁= ▁est _ client _ reenroll ( ectx , ▁cert , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ SSL _ CONNECT ); ▁est _ destroy ( ectx ); ▁} ▁int ▁us 898_ add _ suite ▁( void ) ▁{ ▁# if def ▁HAV E _ C UNIT ▁CU _ pSuite ▁pSuite ▁= ▁NULL ; ▁/* ▁add ▁a ▁suite ▁to ▁the ▁ registry ▁*/ ▁pSuite ▁= ▁CU _ add _ suite (" us 898_ client _ reenroll ", ▁us 898_ init _ suite , ▁us 898_ destroy _ suite ); ▁if ▁( NULL ▁== ▁pSuite ) ▁{ ▁CU _ cleanup _ registry (); ▁return ▁CU _ get _ error (); ▁} ▁/* ▁* ▁Add ▁the ▁tests ▁to ▁the ▁suite ▁*/ ▁if ▁( ( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" Simple ▁enroll ▁and ▁re - enroll ", ▁us 898_ test 1)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" Re - enroll ▁expired ▁cert ▁with ▁extensions ", ▁us 898_ test 2)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" Re - enroll ▁using ▁NULL ▁cert ", ▁us 898_ test 3)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" Re - enroll ▁using ▁NULL ▁key ", ▁us 898_ test 4)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" Re - enroll ▁using ▁corrupted ▁X 509 ▁cert ", ▁us 898_ test 5)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" Re - enroll ▁retry - after ", ▁us 898_ test 6)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" Re - enroll ▁invalid ▁UID / PWD ▁Basic ", ▁us 898_ test 7)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" Re - enroll ▁valid ▁UID / PWD ▁Digest ", ▁us 898_ test 8)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" Re - enroll ▁invalid ▁UID / PWD ▁Digest ", ▁us 898_ test 9)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" Re - enroll ▁valid ▁certificate ▁no ▁HTTP ▁auth ", ▁us 898_ test 10)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" Re - enroll ▁expired ▁certificate ▁with ▁HTTP ▁auth ", ▁us 898_ test 11)) ) ▁{ ▁CU _ cleanup _ registry (); ▁return ▁CU _ get _ error (); ▁} ▁return ▁CU E _ SUCCESS ; ▁# endif ▁}