▁/* ---------------- -- ---------------- ---------------- ---------------- ▁* ▁us 1159 . c ▁- ▁Unit ▁Test s ▁for ▁User ▁S tory ▁ 1159 ▁- ▁CSR ▁Attributes ▁enforce ▁* ▁* ▁October , ▁2014 ▁* ▁* ▁Copy right ▁( c ) ▁2014 , ▁2016 ▁by ▁ cisco ▁System s , ▁Inc . ▁* ▁All ▁rights ▁ reserved . ▁* -- ---------------- ---------------- ---------------- ---------------- ▁*/ ▁# include ▁< s td io . h > ▁# if ndef ▁WI N 32 ▁# include ▁< uni s td . h > ▁# endif ▁# include ▁< est . h > ▁# include ▁" test _ util s . h " ▁# include ▁< openssl / ssl . h > ▁# include ▁< openssl / x 509 v 3 . h > ▁# include ▁" st _ server . h " ▁# if def ▁HAV E _ C UNIT ▁# include ▁" CUnit / Basic . h " ▁# include ▁" CUnit / A utomat ed . h " ▁# endif ▁# if ndef ▁WI N 32 ▁# define ▁US 1159_ CACERTS ▁" CA / estCA / cacert . crt " ▁# define ▁US 1159_ CACERT ▁" CA / estCA / cacert . crt " ▁# define ▁US 1159_ SERVER _ CERT ▁" CA / estCA / private / estserver cert and key . pem " ▁# define ▁US 1159_ SERVER _ KEY ▁" CA / estCA / private / estserver cert and key . pem " ▁# else ▁# define ▁US 1159_ CACERTS ▁" CA \\ estCA \\ cacert . crt " ▁# define ▁US 1159_ CACERT ▁" CA \\ estCA \\ cacert . crt " ▁# define ▁US 1159_ SERVER _ CERT ▁" CA \\ estCA \\ private \\ estserver cert and key . pem " ▁# define ▁US 1159_ SERVER _ KEY ▁" CA \\ estCA \\ private \\ estserver cert and key . pem " ▁# endif ▁# define ▁US 1159_ UID ▁" estuser " ▁# define ▁US 1159_ PWD ▁" estpwd " ▁# define ▁US 1159_ SERVER _ PORT ▁15 897 ▁# define ▁US 1159_ SERVER _ IP ▁"127.0.0.1" ▁# define ▁US 1159_ ATTR _ POP _ ONLY ▁" MA s GCS qGS Ib 3 DQEJBw == \0" ▁# define ▁US 1159_ ATTR _ CN _ ONLY ▁" MA UGA 1 UE A w == \0" ▁# define ▁US 1159_ ATTR _ TEST ▁" MHE GBysGAQEBARY wI g YDiDcBMR s T GV Bhc nNl IF NF VC Bhc yA yL jk 5 OS 4 xIGRhdGE w LA YDiDcCMS UGA 4 g 3 AwYDiDcEE xlQ YXJ z ZSB T RV QgY XMg Mi 45 OTkuMiBkYXRhBg U r g Q QA I gYDVQQ D Bg g q hk j OP QQD A g == \0" ▁extern ▁EST _ CTX ▁* ectx ; ▁static ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁static ▁int ▁cacerts _ len ▁= ▁0; ▁static ▁char ▁* attrs ; ▁static ▁un signed ▁char ▁* ▁handle _ csrattrs _ request ▁( int ▁* csr _ len , ▁char ▁* path _ seg , ▁void ▁* app _ data ) ▁{ ▁un signed ▁char ▁* csr _ data ; ▁* csr _ len ▁= ▁str len ( attrs ); ▁csr _ data ▁= ▁malloc (* csr _ len ▁+ ▁1); ▁strncpy ( ( char ▁* ) ▁csr _ data , ▁attrs , ▁* csr _ len ); ▁csr _ data [ * csr _ len ] ▁= ▁0; ▁return ▁( csr _ data ); ▁} ▁static ▁void ▁us 1159_ clean ▁( void ) ▁{ ▁} ▁int ▁us 1159_ start _ server ▁( ) ▁{ ▁int ▁rv ▁= ▁0; ▁/* ▁* ▁Start ▁an ▁EST ▁server ▁ acting ▁as ▁the ▁CA ▁*/ ▁rv ▁= ▁st _ start ( US 1159_ SERVER _ PORT , ▁US 1159_ SERVER _ CERT , ▁US 1159_ SERVER _ KEY , ▁" estrealm ", ▁US 1159_ CACERT , ▁" CA / trustedcerts . crt ", ▁" CA / est Example CA . cnf ", ▁0, ▁// ▁manual ▁enroll ▁0, ▁// ▁disable ▁PoP ▁0); ▁// ▁ ecdhe ▁nid ▁info ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁ printf ("\ nU nable ▁to ▁start ▁EST ▁server ▁for ▁US 1159 . \ n "); ▁return ▁rv ; ▁} ▁st _ enable _ csrattr _ enforce (); ▁rv ▁= ▁est _ set _ csr _ cb ( ectx , ▁& handle _ csrattrs _ request ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁ printf ("\ nU nable ▁to ▁set ▁EST ▁CSR ▁Attributes ▁callback ▁for ▁US 1159 . \ n "); ▁return ▁( rv ); ▁} ▁SL EEP (1); ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁initialize s ▁this ▁test ▁* ▁suite . ▁This ▁can ▁be ▁used ▁to ▁allocate ▁data ▁or ▁open ▁any ▁* ▁ resources ▁required ▁for ▁all ▁the ▁test ▁cases . ▁*/ ▁static ▁int ▁us 1159_ init _ suite ▁( void ) ▁{ ▁int ▁rv ; ▁us 1159_ clean (); ▁ printf ( ▁"\ n Start ing ▁server ▁for ▁CSR ▁attributes ▁enforce ment ▁ unit ▁tests ▁( US 1159 ) . \ n "); ▁attrs ▁= ▁US 1159_ ATTR _ POP _ ONLY ; ▁est _ init _ logger ( EST _ LOG _ L VL _ INFO , ▁NULL ); ▁/* ▁* ▁ Read ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( US 1159_ CACERTS , ▁& cacerts ); ▁if ▁( cacerts _ len ▁< = ▁0) ▁{ ▁return ▁1; ▁} ▁/* ▁* ▁Start ▁an ▁instance ▁of ▁the ▁EST ▁server ▁with ▁* ▁automatic ▁enrollment ▁enabled . ▁*/ ▁rv ▁= ▁us 1159_ start _ server (); ▁return ▁rv ; ▁} ▁void ▁us 1159_ stop _ server ▁( ) ▁{ ▁st _ stop (); ▁SL EEP ( 2 ); ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁uninitialize s ▁this ▁test ▁* ▁suite . ▁This ▁can ▁be ▁used ▁to ▁de allocate ▁data ▁or ▁close ▁any ▁* ▁ resources ▁that ▁we re ▁used ▁for ▁the ▁test ▁cases . ▁*/ ▁static ▁int ▁us 1159_ destroy _ suite ▁( void ) ▁{ ▁us 1159_ stop _ server (); ▁free ( cacerts ); ▁ printf (" Completed ▁CSR ▁attributes ▁enforce ment ▁ unit ▁tests . \ n "); ▁return ▁0; ▁} ▁static ▁E VP _ PKEY ▁* ▁generate _ private _ key ▁( void ) ▁{ ▁RSA ▁* rsa ▁= ▁RSA _ new (); ▁B IG NUM ▁* bn ▁= ▁BN _ new (); ▁E VP _ PKEY ▁* pkey ; ▁/* ▁* ▁create ▁an ▁RSA ▁ keypair ▁and ▁assign ▁them ▁to ▁a ▁ PKEY ▁and ▁return ▁it . ▁*/ ▁BN _ set _ word ( bn , ▁0 x 1000 1); ▁RSA _ generate _ key _ ex ( rsa , ▁1024 , ▁bn , ▁NULL ); ▁pkey ▁= ▁E VP _ PKEY _ new (); ▁if ▁( pkey ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁allocat ing ▁ PKEY ▁structure ▁for ▁new ▁key ▁pair \ n "); ▁return ▁NULL ; ▁} ▁if ▁(! E VP _ PKEY _ set 1 _ RSA ( pkey , ▁rsa )) ▁{ ▁ printf ("\ nError ▁assign ing ▁RSA ▁key ▁pair ▁to ▁ PKEY ▁structure \ n "); ▁return ▁NULL ; ▁} ▁RSA _ free ( rsa ); ▁BN _ free ( bn ); ▁return ▁( pkey ); ▁} ▁/* ▁* ▁This ▁function ▁generate s ▁an ▁EC ▁public / private ▁key ▁* ▁pair ▁that ▁will ▁be ▁used ▁with ▁the ▁certificate ▁* ▁we ▁provision . ▁*/ ▁static ▁E VP _ PKEY ▁* ▁generate _ ec _ private _ key ▁( int ▁nid ) ▁{ ▁EC _ KEY ▁* eckey ; ▁EC _ GROUP ▁* group ▁= ▁NULL ; ▁BIO ▁* out ; ▁un signed ▁char ▁* t data ; ▁un signed ▁char ▁* key _ data ; ▁int ▁key _ len ; ▁BIO ▁* keyin ; ▁E VP _ PKEY ▁* new _ priv _ key ; ▁int ▁as n 1 _ flag ▁= ▁O PEN SSL _ EC _ NAME D _ CUR VE ; ▁point _ conversion _ form _ t ▁form ▁= ▁P O INT _ CON VERSION _ UN COMPRE SSED ; ▁/* ▁* ▁Generate ▁an ▁EC ▁key ▁*/ ▁group ▁= ▁EC _ GROUP _ new _ by _ curve _ name ( nid ▁/* NID _ X 9 _ 62 _ prime 256 v 1 */ ); ▁EC _ GROUP _ set _ asn 1 _ flag ( group , ▁as n 1 _ flag ); ▁EC _ GROUP _ set _ po int _ conversion _ form ( group , ▁form ); ▁eckey ▁= ▁EC _ KEY _ new (); ▁EC _ KEY _ set _ group ( eckey , ▁group ); ▁if ▁(! EC _ KEY _ generate _ key ( eckey )) ▁{ ▁ printf (" Failed ▁to ▁generate ▁EC ▁key \ n "); ▁return ▁NULL ; ▁} ▁out ▁= ▁BIO _ new ( BIO _ s _ mem ()); ▁PEM _ write _ bio _ EC PK Parameters ( out , ▁group ); ▁PEM _ write _ bio _ EC PrivateKey ( out , ▁eckey , ▁NULL , ▁NULL , ▁0, ▁NULL , ▁NULL ); ▁key _ len ▁= ▁BIO _ get _ mem _ data ( out , ▁& t data ); ▁key _ data ▁= ▁malloc ( key _ len ▁+ ▁1); ▁memcpy ( key _ data , ▁t data , ▁key _ len ); ▁EC _ KEY _ free ( eckey ); ▁BIO _ free ( out ); ▁/* ▁* ▁read ▁it ▁back ▁in ▁to ▁an ▁E VP _ PKEY ▁struct ▁*/ ▁keyin ▁= ▁BIO _ new ( BIO _ s _ mem ()); ▁keyin ▁= ▁BIO _ new _ mem _ buf ( key _ data , ▁key _ len ); ▁/* ▁* ▁This ▁read s ▁in ▁the ▁private ▁key ▁file , ▁which ▁is ▁expected ▁to ▁be ▁a ▁PEM ▁* ▁encoded ▁private ▁key . ▁If ▁using ▁DER ▁encoding , ▁you ▁woul d ▁invoke ▁* ▁d 2 i _ PrivateKey _ bio () ▁instead . ▁*/ ▁new _ priv _ key ▁= ▁PEM _ read _ bio _ PrivateKey ( keyin , ▁NULL , ▁NULL , ▁NULL ); ▁if ▁( new _ priv _ key ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁while ▁reading ▁PEM ▁encoded ▁private ▁key \ n "); ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁NULL ; ▁} ▁BIO _ free ( keyin ); ▁free ( key _ data ); ▁return ▁( new _ priv _ key ); ▁} ▁/* ▁* ▁This ▁test ▁attempts ▁does ▁a ▁simple ▁enroll ▁with ▁the ▁* ▁client ▁provid ing ▁no ▁CSR ▁attributes ▁other ▁than ▁* ▁ c hallengePassword . ▁The ▁enroll ▁should ▁succeed . ▁*/ ▁static ▁void ▁us 1159_ test 1 ▁( void ) ▁{ ▁EST _ CTX ▁* ctx ; ▁E VP _ PKEY ▁* key ; ▁int ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁LOG _ FUNC _ NM ▁ ; ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ctx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁NULL ); ▁CU _ ASSERT ( ctx ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ force _ pop ( ctx ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ctx , ▁US 1159_ UID , ▁US 1159_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ctx , ▁US 1159_ SERVER _ IP , ▁US 1159_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ private _ key (); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ctx , ▁" Test ▁ 1", ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Retrieve ▁the ▁cert ▁that ▁was ▁given ▁to ▁us ▁by ▁the ▁EST ▁server ▁*/ ▁if ▁( rv ▁== ▁EST _ ERR _ NONE ) ▁{ ▁new _ cert ▁= ▁malloc ( pkcs 7_ len ); ▁CU _ ASSERT ( new _ cert ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ copy _ enrolled _ cert ( ctx , ▁new _ cert ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Cleanup ▁*/ ▁E VP _ PKEY _ free ( key ); ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁est _ destroy ( ctx ); ▁} ▁/* ▁* ▁This ▁routine ▁build s ▁a ▁PKCS 10 ▁CSR . ▁*/ ▁static ▁EST _ ERROR ▁populate _ x 509_ request ▁( X 509_ REQ ▁* req , ▁E VP _ PKEY ▁* pkey , ▁char ▁* cn ) ▁{ ▁X 509_ NAME ▁* subj ; ▁int ▁rv ; ▁/* ▁set up ▁version ▁number ▁*/ ▁rv ▁= ▁X 509_ REQ _ set _ version ( req , ▁0 L ); ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ X 509_ VER ); ▁} ▁/* ▁* ▁Add ▁Common ▁Name ▁entry ▁*/ ▁ subj ▁= ▁X 509_ REQ _ get _ subject _ name ( req ); ▁rv ▁= ▁X 509_ NAME _ add _ entry _ by _ txt ( subj , ▁" CN ", ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁cn , ▁-1, ▁-1, ▁0); ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ X 509_ CN ); ▁} ▁/* ▁* ▁Add ▁serial ▁number ▁Name ▁entry ▁*/ ▁rv ▁= ▁X 509_ NAME _ add _ entry _ by _ NID ( subj , ▁NID _ s erialNumber , ▁MB STRING _ ASC , ▁( un signed ▁char *) ▁" 12 34 99 99 B ", ▁-1, ▁-1, ▁0); ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ X 509_ CN ); ▁} ▁/* ▁* ▁Add ▁all ▁the ▁other ▁attributes ▁that ▁the ▁server ▁will ▁be ▁expect ing ▁*/ ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ txt ( req , ▁" 1 . 3 . 6 . 1 . 1 . 1 . 1 . 2 2 ", ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁" dummy m a c ", ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ UNKNOWN ); ▁} ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ txt ( req , ▁"2.999. 1", ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁" dummy ", ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ UNKNOWN ); ▁} ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ txt ( req , ▁"2.999. 2 ", ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁" dummy ", ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ UNKNOWN ); ▁} ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ txt ( req , ▁"2.999. 3 ", ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁" dummy ", ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ UNKNOWN ); ▁} ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ txt ( req , ▁"2.999. 4", ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁" dummy ", ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ UNKNOWN ); ▁} ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ txt ( req , ▁" 1 . 2 . 8 40 . 10 0 45 . 2.1 ", ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁" 1 . 3 . 13 2.0 . 3 4", ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ UNKNOWN ); ▁} ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ txt ( req , ▁" 1 . 2 . 8 40 . 10 0 45 . 4 . 3 . 3 ", ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁"", ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ UNKNOWN ); ▁} ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ NID ( req , ▁NID _ s erialNumber , ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁"123456789 A ", ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ UNKNOWN ); ▁} ▁/* ▁* ▁Set ▁the ▁public ▁key ▁on ▁the ▁request ▁*/ ▁rv ▁= ▁X 509_ REQ _ set _ pub key ( req , ▁pkey ); ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ X 509_ PUBKEY ); ▁} ▁X 509_ REQ _ print _ fp ( stderr , ▁req ); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁# if ▁0 ▁/* ▁* ▁Sign ▁an ▁X 509 ▁certificate ▁request ▁using ▁the ▁digest ▁and ▁the ▁key ▁passed . ▁* ▁Returns ▁OpenSSL ▁error ▁code ▁from ▁X 509_ REQ _ sign _ ctx (); ▁*/ ▁static ▁int ▁sign _ X 509_ REQ ( X 509_ REQ ▁* x , ▁E VP _ PKEY ▁* pkey , ▁const ▁E VP _ MD ▁* md ) ▁{ ▁int ▁rv ; ▁E VP _ PKEY _ CTX ▁* pkctx ▁= ▁NULL ; ▁E VP _ MD _ CTX ▁ mctx ; ▁E VP _ MD _ CTX _ init (& mctx ); ▁if ▁(! E VP _ Digest Sign Init (& mctx , ▁& pkctx , ▁md , ▁NULL , ▁pkey )) ▁{ ▁return ▁0; ▁} ▁/* ▁* ▁ Encode ▁using ▁DER ▁( ASN . 1) ▁* ▁* ▁We ▁have ▁to ▁set ▁the ▁modified ▁flag ▁on ▁the ▁X 509_ REQ ▁because ▁* ▁OpenSSL ▁keep s ▁a ▁cached ▁copy ▁of ▁the ▁DER ▁encoded ▁data ▁in ▁some ▁* ▁cases . ▁Sett ing ▁this ▁flag ▁tell s ▁OpenSSL ▁to ▁run ▁the ▁ASN ▁* ▁encoding ▁again ▁r ather ▁than ▁using ▁the ▁cached ▁copy . ▁*/ ▁x -> req _ info -> enc . modified ▁= ▁1; ▁rv ▁= ▁X 509_ REQ _ sign _ ctx ( x , ▁& mctx ); ▁E VP _ MD _ CTX _ cleanup (& mctx ); ▁return ▁( rv ); ▁} ▁# endif ▁/* ▁* ▁This ▁test ▁attempts ▁does ▁a ▁simple ▁enroll ▁with ▁the ▁* ▁client ▁provid ing ▁all ▁the ▁required ▁CSR ▁attributes ▁in ▁* ▁the ▁CSR . ▁The ▁enroll ▁should ▁succeed . ▁*/ ▁static ▁void ▁us 1159_ test 2 ▁( void ) ▁{ ▁X 509_ REQ ▁* req ▁= ▁NULL ; ▁E VP _ PKEY ▁* key ▁= ▁NULL ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁int ▁rv ; ▁EST _ CTX ▁* ctx ▁= ▁NULL ; ▁LOG _ FUNC _ NM ▁ ; ▁/* ▁* ▁This ▁sets ▁the ▁full ▁list ▁of ▁attributes ▁on ▁the ▁server ▁*/ ▁attrs ▁= ▁US 1159_ ATTR _ TEST ; ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ ec _ private _ key ( NID _ secp 384 r 1); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁req ▁= ▁X 509_ REQ _ new (); ▁CU _ ASSERT ( req ▁ != ▁NULL ); ▁rv ▁= ▁populate _ x 509_ request ( req , ▁key , ▁" Test ▁2 "); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁# if ▁0 ▁/* ▁* ▁Sign ▁the ▁request ▁*/ ▁ossl _ rv ▁= ▁sign _ X 509_ REQ ( req , ▁key , ▁E VP _ sha 256 ()); ▁CU _ ASSERT ( ossl _ rv ▁== ▁0); ▁if ▁(! ossl _ rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁} ▁# endif ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ctx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁NULL ); ▁CU _ ASSERT ( ctx ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ force _ pop ( ctx ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ctx , ▁US 1159_ UID , ▁US 1159_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ctx , ▁US 1159_ SERVER _ IP , ▁US 1159_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll _ csr ( ctx , ▁req , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Retrieve ▁the ▁cert ▁that ▁was ▁given ▁to ▁us ▁by ▁the ▁EST ▁server ▁*/ ▁if ▁( rv ▁== ▁EST _ ERR _ NONE ) ▁{ ▁new _ cert ▁= ▁malloc ( pkcs 7_ len ); ▁CU _ ASSERT ( new _ cert ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ copy _ enrolled _ cert ( ctx , ▁new _ cert ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Cleanup ▁*/ ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁if ▁( ctx ) ▁est _ destroy ( ctx ); ▁if ▁( req ) ▁X 509_ REQ _ free ( req ); ▁if ▁( key ) ▁E VP _ PKEY _ free ( key ); ▁} ▁/* ▁* ▁This ▁test ▁attempts ▁does ▁a ▁simple ▁enroll ▁with ▁the ▁* ▁client ▁provid ing ▁all ▁the ▁required ▁CSR ▁attributes ▁in ▁* ▁the ▁CSR ▁except ▁that ▁the ▁52 1 - bit ▁curve ▁is ▁used . ▁The ▁enroll ▁* ▁should ▁fail ▁since ▁the ▁server ▁CSR ▁attrs ▁specify ▁to ▁* ▁use ▁the ▁ 384 - bit ▁curve . ▁*/ ▁static ▁void ▁us 1159_ test 3 ▁( void ) ▁{ ▁X 509_ REQ ▁* req ▁= ▁NULL ; ▁E VP _ PKEY ▁* key ▁= ▁NULL ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁int ▁rv ; ▁EST _ CTX ▁* ctx ▁= ▁NULL ; ▁LOG _ FUNC _ NM ▁ ; ▁/* ▁* ▁This ▁sets ▁the ▁full ▁list ▁of ▁attributes ▁on ▁the ▁server ▁*/ ▁attrs ▁= ▁US 1159_ ATTR _ TEST ; ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ ec _ private _ key ( NID _ secp 5 21 r 1); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁req ▁= ▁X 509_ REQ _ new (); ▁CU _ ASSERT ( req ▁ != ▁NULL ); ▁rv ▁= ▁populate _ x 509_ request ( req , ▁key , ▁" Test ▁3 "); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ctx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁NULL ); ▁CU _ ASSERT ( ctx ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ force _ pop ( ctx ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ctx , ▁US 1159_ UID , ▁US 1159_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ctx , ▁US 1159_ SERVER _ IP , ▁US 1159_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll _ csr ( ctx , ▁req , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ HTTP _ BAD _ REQ ); ▁/* ▁* ▁Cleanup ▁*/ ▁if ▁( ctx ) ▁est _ destroy ( ctx ); ▁if ▁( req ) ▁X 509_ REQ _ free ( req ); ▁if ▁( key ) ▁E VP _ PKEY _ free ( key ); ▁} ▁/* ▁* ▁This ▁test ▁attempts ▁does ▁a ▁simple ▁enroll ▁with ▁the ▁* ▁client ▁provid ing ▁all ▁the ▁required ▁CSR ▁attributes ▁in ▁* ▁the ▁CSR ▁except ▁that ▁SHA - 384 ▁is ▁used ▁for ▁the ▁* ▁signature . ▁The ▁enroll ▁should ▁fail ▁since ▁the ▁server ▁* ▁CSR ▁attrs ▁require ▁SHA - 256 . ▁*/ ▁static ▁void ▁us 1159_ test 4 ▁( void ) ▁{ ▁X 509_ REQ ▁* req ▁= ▁NULL ; ▁E VP _ PKEY ▁* key ▁= ▁NULL ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁int ▁rv ; ▁EST _ CTX ▁* ctx ▁= ▁NULL ; ▁LOG _ FUNC _ NM ▁ ; ▁/* ▁* ▁This ▁sets ▁the ▁full ▁list ▁of ▁attributes ▁on ▁the ▁server ▁*/ ▁attrs ▁= ▁US 1159_ ATTR _ TEST ; ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ ec _ private _ key ( NID _ secp 384 r 1); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁req ▁= ▁X 509_ REQ _ new (); ▁CU _ ASSERT ( req ▁ != ▁NULL ); ▁rv ▁= ▁populate _ x 509_ request ( req , ▁key , ▁" Test ▁3 "); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ctx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁NULL ); ▁CU _ ASSERT ( ctx ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ force _ pop ( ctx ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Change ▁to ▁SHA - 384 ▁for ▁the ▁signature ▁*/ ▁rv ▁= ▁est _ client _ set _ sign _ digest ( ctx , ▁NID _ sha 384 ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ctx , ▁US 1159_ UID , ▁US 1159_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ctx , ▁US 1159_ SERVER _ IP , ▁US 1159_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll _ csr ( ctx , ▁req , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ HTTP _ BAD _ REQ ); ▁/* ▁* ▁Cleanup ▁*/ ▁if ▁( ctx ) ▁est _ destroy ( ctx ); ▁if ▁( req ) ▁X 509_ REQ _ free ( req ); ▁if ▁( key ) ▁E VP _ PKEY _ free ( key ); ▁} ▁/* ▁* ▁This ▁test ▁attempts ▁does ▁a ▁simple ▁enroll ▁when ▁the ▁* ▁server ▁has ▁no ▁CSR ▁attributes ▁configured ▁to ▁only ▁* ▁require ▁the ▁CommonName . ▁The ▁CSR ▁attributes ▁on ▁* ▁the ▁server ▁are ▁configured ▁through ▁the ▁static ▁API , ▁* ▁not ▁the ▁callback . ▁*/ ▁static ▁void ▁us 1159_ test 10 ▁( void ) ▁{ ▁E VP _ PKEY ▁* key ▁= ▁NULL ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁int ▁rv ; ▁EST _ CTX ▁* ctx ▁= ▁NULL ; ▁LOG _ FUNC _ NM ▁ ; ▁/* ▁* ▁Disabl e ▁the ▁CSR ▁attr ▁callback ▁on ▁the ▁server ▁context ▁*/ ▁rv ▁= ▁est _ set _ csr _ cb ( ectx , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Con f igu re ▁the ▁static ▁CSR ▁attributes ▁value ▁*/ ▁rv ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁US 1159_ ATTR _ CN _ ONLY , ▁str len ( US 1159_ ATTR _ CN _ ONLY )); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ private _ key (); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ctx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁NULL ); ▁CU _ ASSERT ( ctx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ctx , ▁US 1159_ UID , ▁US 1159_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁rv ▁= ▁est _ client _ force _ pop ( ctx ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ctx , ▁US 1159_ SERVER _ IP , ▁US 1159_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Enroll ▁a ▁new ▁cert ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ctx , ▁" Test ▁10 ", ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Cleanup ▁*/ ▁if ▁( ctx ) ▁est _ destroy ( ctx ); ▁if ▁( key ) ▁E VP _ PKEY _ free ( key ); ▁} ▁/* ▁* ▁This ▁test ▁attempts ▁does ▁a ▁simple ▁enroll ▁with ▁the ▁* ▁client ▁provid ing ▁all ▁the ▁required ▁CSR ▁attributes ▁in ▁* ▁the ▁CSR . ▁The ▁client ▁also ▁provide s ▁a ▁large ▁* ▁qua ntity ▁of ▁additional ▁attr i ut es . ▁*/ ▁static ▁void ▁us 1159_ test 20 ▁( void ) ▁{ ▁X 509_ REQ ▁* req ▁= ▁NULL ; ▁E VP _ PKEY ▁* key ▁= ▁NULL ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁int ▁rv ; ▁EST _ CTX ▁* ctx ▁= ▁NULL ; ▁int ▁i ; ▁char ▁t _ attr _ str [ 50 ] ; ▁LOG _ FUNC _ NM ▁ ; ▁/* ▁* ▁This ▁sets ▁the ▁full ▁list ▁of ▁attributes ▁on ▁the ▁server ▁*/ ▁attrs ▁= ▁US 1159_ ATTR _ TEST ; ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ ec _ private _ key ( NID _ secp 384 r 1); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁req ▁= ▁X 509_ REQ _ new (); ▁CU _ ASSERT ( req ▁ != ▁NULL ); ▁rv ▁= ▁populate _ x 509_ request ( req , ▁key , ▁" Test ▁20 "); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁J am ▁another ▁25 ▁attributes ▁into ▁the ▁request ▁* ▁We ▁could ▁do ▁more , ▁but ▁this ▁cause s ▁a ▁failure ▁on ▁the ▁EST ▁server ▁when ▁* ▁base 64 ▁decoding ▁the ▁CSR ▁du e ▁to ▁a ▁safe C ▁constraint . ▁The ▁max ▁string ▁* ▁size ▁in ▁safe C ▁defaults ▁to ▁4096 ▁bytes . ▁*/ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁25 ; ▁i ++) ▁{ ▁ s printf ( t _ attr _ str , ▁" 2 . 899 . % d ", ▁i ); ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ txt ( req , ▁t _ attr _ str , ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁" what ever ", ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁} ▁} ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ctx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁NULL ); ▁CU _ ASSERT ( ctx ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ force _ pop ( ctx ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ctx , ▁US 1159_ UID , ▁US 1159_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ctx , ▁US 1159_ SERVER _ IP , ▁US 1159_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll _ csr ( ctx , ▁req , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Retrieve ▁the ▁cert ▁that ▁was ▁given ▁to ▁us ▁by ▁the ▁EST ▁server ▁*/ ▁if ▁( rv ▁== ▁EST _ ERR _ NONE ) ▁{ ▁new _ cert ▁= ▁malloc ( pkcs 7_ len ); ▁CU _ ASSERT ( new _ cert ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ copy _ enrolled _ cert ( ctx , ▁new _ cert ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Cleanup ▁*/ ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁if ▁( ctx ) ▁est _ destroy ( ctx ); ▁if ▁( req ) ▁X 509_ REQ _ free ( req ); ▁if ▁( key ) ▁E VP _ PKEY _ free ( key ); ▁} ▁/* ▁* ▁This ▁test ▁attempts ▁does ▁a ▁simple ▁enroll ▁with ▁the ▁* ▁client ▁provid ing ▁all ▁the ▁required ▁CSR ▁attributes ▁in ▁* ▁the ▁CSR . ▁The ▁client ▁also ▁provide s ▁an ▁attribute ▁with ▁* ▁a ▁ very ▁long ▁name ▁and ▁value . ▁*/ ▁static ▁void ▁us 1159_ test 21 ▁( void ) ▁{ ▁X 509_ REQ ▁* req ▁= ▁NULL ; ▁E VP _ PKEY ▁* key ▁= ▁NULL ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁int ▁rv ; ▁EST _ CTX ▁* ctx ▁= ▁NULL ; ▁LOG _ FUNC _ NM ▁ ; ▁/* ▁* ▁This ▁sets ▁the ▁full ▁list ▁of ▁attributes ▁on ▁the ▁server ▁*/ ▁attrs ▁= ▁US 1159_ ATTR _ TEST ; ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ ec _ private _ key ( NID _ secp 384 r 1); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁req ▁= ▁X 509_ REQ _ new (); ▁CU _ ASSERT ( req ▁ != ▁NULL ); ▁rv ▁= ▁populate _ x 509_ request ( req , ▁key , ▁" Test ▁ 21 "); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Add ▁an ▁attribute ▁with ▁a ▁long ▁value ▁*/ ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ txt ( req , ▁" 2.993.8 ", ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁" This ▁is ▁an ▁attribute ▁with ▁a ▁ very ▁long ▁value ▁that ▁could ▁potential ly ▁cause ▁a ▁problem ▁on ▁the ▁EST ▁server . ▁ 01234567890 123456789012345 678901234567890 123456789012345 678901234567890 123456789012345 678901234567890 123456789012345 678901234567890 123456789012345 678901234567890 123456789012345 678901234567890 123456789012345 678901234567890 123456789012345 67890123456789" , ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁} ▁/* ▁* ▁Add ▁an ▁attribute ▁with ▁a ▁long ▁name ▁*/ ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ txt ( req , ▁" 2.993.8 . 82 8 .85 . 8 142.9999.2.1883. 2.993.8 . 82 8 .85 . 8 142.9999.2.1883. 2.993.8 . 82 8 .85 . 8 142.9999.2.1883. 2.993.8 . 82 8 .85 . 8 142.9999.2.1883. 2.993.8 . 82 8 .85 . 8 142.9999.2.1883. 7", ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁" 0 12 34 56 7 89 ", ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁} ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ctx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁NULL ); ▁CU _ ASSERT ( ctx ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ force _ pop ( ctx ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ctx , ▁US 1159_ UID , ▁US 1159_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ctx , ▁US 1159_ SERVER _ IP , ▁US 1159_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll _ csr ( ctx , ▁req , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Retrieve ▁the ▁cert ▁that ▁was ▁given ▁to ▁us ▁by ▁the ▁EST ▁server ▁*/ ▁if ▁( rv ▁== ▁EST _ ERR _ NONE ) ▁{ ▁new _ cert ▁= ▁malloc ( pkcs 7_ len ); ▁CU _ ASSERT ( new _ cert ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ copy _ enrolled _ cert ( ctx , ▁new _ cert ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Cleanup ▁*/ ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁if ▁( ctx ) ▁est _ destroy ( ctx ); ▁if ▁( req ) ▁X 509_ REQ _ free ( req ); ▁if ▁( key ) ▁E VP _ PKEY _ free ( key ); ▁} ▁/* ▁* ▁This ▁test ▁attempts ▁does ▁a ▁simple ▁enroll ▁when ▁the ▁* ▁server ▁has ▁no ▁CSR ▁attributes ▁configured ▁with ▁* ▁PoP ▁enabled . ▁*/ ▁static ▁void ▁us 1159_ test 50 ▁( void ) ▁{ ▁E VP _ PKEY ▁* key ▁= ▁NULL ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁int ▁rv ; ▁EST _ CTX ▁* ctx ▁= ▁NULL ; ▁LOG _ FUNC _ NM ▁ ; ▁st _ enable _ pop (); ▁/* ▁* ▁Disabl e ▁the ▁CSR ▁attr ▁callback ▁on ▁the ▁server ▁context ▁*/ ▁rv ▁= ▁est _ set _ csr _ cb ( ectx , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ ec _ private _ key ( NID _ secp 384 r 1); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ctx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁NULL ); ▁CU _ ASSERT ( ctx ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ force _ pop ( ctx ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ctx , ▁US 1159_ UID , ▁US 1159_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ctx , ▁US 1159_ SERVER _ IP , ▁US 1159_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Enroll ▁a ▁new ▁cert ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ctx , ▁" Test ▁50 ", ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Cleanup ▁*/ ▁if ▁( ctx ) ▁est _ destroy ( ctx ); ▁if ▁( key ) ▁E VP _ PKEY _ free ( key ); ▁} ▁/* ▁* ▁This ▁test ▁attempts ▁does ▁a ▁simple ▁enroll ▁when ▁the ▁* ▁server ▁has ▁no ▁CSR ▁attributes ▁configured ▁with ▁* ▁PoP ▁disabled . ▁*/ ▁static ▁void ▁us 1159_ test 5 1 ▁( void ) ▁{ ▁E VP _ PKEY ▁* key ▁= ▁NULL ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁int ▁rv ; ▁EST _ CTX ▁* ctx ▁= ▁NULL ; ▁LOG _ FUNC _ NM ▁ ; ▁st _ disable _ pop (); ▁/* ▁* ▁Disabl e ▁the ▁CSR ▁attr ▁callback ▁on ▁the ▁server ▁context ▁*/ ▁rv ▁= ▁est _ set _ csr _ cb ( ectx , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ ec _ private _ key ( NID _ secp 384 r 1); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ctx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁NULL ); ▁CU _ ASSERT ( ctx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ctx , ▁US 1159_ UID , ▁US 1159_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ctx , ▁US 1159_ SERVER _ IP , ▁US 1159_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Enroll ▁a ▁new ▁cert ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ctx , ▁" Test ▁5 1", ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Cleanup ▁*/ ▁if ▁( ctx ) ▁est _ destroy ( ctx ); ▁if ▁( key ) ▁E VP _ PKEY _ free ( key ); ▁} ▁/* ▁The ▁main () ▁function ▁for ▁setting ▁up ▁and ▁running ▁the ▁tests . ▁* ▁Returns ▁a ▁CU E _ SUCCESS ▁on ▁successful ▁running , ▁another ▁* ▁ CUnit ▁error ▁code ▁on ▁failure . ▁*/ ▁int ▁us 1159_ add _ suite ▁( void ) ▁{ ▁# if def ▁HAV E _ C UNIT ▁CU _ pSuite ▁pSuite ▁= ▁NULL ; ▁/* ▁add ▁a ▁suite ▁to ▁the ▁ registry ▁*/ ▁pSuite ▁= ▁CU _ add _ suite (" us 1159_ csr _ attr _ enforce ", ▁us 1159_ init _ suite , ▁us 1159_ destroy _ suite ); ▁if ▁( NULL ▁== ▁pSuite ) ▁{ ▁CU _ cleanup _ registry (); ▁return ▁CU _ get _ error (); ▁} ▁/* ▁add ▁the ▁tests ▁to ▁the ▁suite ▁*/ ▁/* ▁NOTE ▁- ▁OR DER ▁IS ▁ IMPORTANT ▁- ▁MUST ▁TEST ▁f read () ▁ AFTER ▁f printf () ▁*/ ▁if ▁( ( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" No ▁attributes ▁required ▁w / pop ", ▁us 1159_ test 1)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" All ▁attributes ▁provided ▁w / pop ", ▁us 1159_ test 2)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EC ▁public ▁key ▁w rong ▁curve ▁w / pop ", ▁us 1159_ test 3)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" W rong ▁hash ▁algorithm ▁in ▁signature ▁w / pop ", ▁us 1159_ test 4)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" CN ▁only ▁using ▁static ▁config ▁w / pop ", ▁us 1159_ test 10)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" A ▁lo t ▁of ▁attributes ▁w / pop ", ▁us 1159_ test 20 )) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" Long ▁attribute ▁w / pop ", ▁us 1159_ test 2 1)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" No ▁CSR ▁attrs ▁on ▁server ▁w / pop ", ▁us 1159_ test 50 )) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" No ▁CSR ▁attrs ▁on ▁server ▁w / o ▁pop ", ▁us 1159_ test 5 1)) ) ▁{ ▁CU _ cleanup _ registry (); ▁return ▁CU _ get _ error (); ▁} ▁return ▁CU E _ SUCCESS ; ▁# endif ▁}