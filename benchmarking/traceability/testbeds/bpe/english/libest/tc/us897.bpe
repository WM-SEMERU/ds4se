▁/* ---------------- -- ---------------- ---------------- ---------------- ▁* ▁us 897 . c ▁- ▁Unit ▁Test s ▁for ▁User ▁S tory ▁ 897 ▁- ▁Client ▁CACerts ▁* ▁* ▁June , ▁2013 ▁* ▁* ▁Copy right ▁( c ) ▁2013 , ▁2016 ▁by ▁ cisco ▁System s , ▁Inc . ▁* ▁All ▁rights ▁ reserved . ▁* -- ---------------- ---------------- ---------------- ---------------- ▁*/ ▁# include ▁< s td io . h > ▁# if ndef ▁WI N 32 ▁# include ▁< uni s td . h > ▁# endif ▁# include ▁< est . h > ▁# if def ▁HAV E _ C UNIT ▁# include ▁" CUnit / Basic . h " ▁# include ▁" CUnit / A utomat ed . h " ▁# endif ▁# include ▁"../../ util / test _ util s . h " ▁# include ▁" st _ server . h " ▁/* ▁* ▁max ▁command ▁line ▁length ▁when ▁generat ing ▁system ▁commands ▁*/ ▁# define ▁EST _ UT _ MAX _ CMD _ LEN ▁256 ▁# define ▁EST _ CA _ MAX ▁20 0000 ▁/* ▁* ▁The ▁CA ▁certificate ▁used ▁to ▁verify ▁the ▁EST ▁server . ▁Gra b ▁it ▁from ▁the ▁server ' s ▁directory ▁*/ ▁/* ▁# define ▁CLIENT _ UT _ CACERT ▁"../../ example / server / estCA / cacert . crt " ▁*/ ▁# define ▁US 897_ SERVER _ PORT ▁2989 7 ▁# define ▁CLIENT _ UT _ PUBKEY ▁" . / est _ client _ ut _ keypair " ▁# define ▁US 897_ SERVER _ IP ▁"127.0.0.1" ▁# define ▁US 897_ UID ▁" estuser " ▁# define ▁US 897_ PWD ▁" estpwd " ▁# if ndef ▁WI N 32 ▁# define ▁CLIENT _ UT _ CACERT ▁" CA / estCA / cacert . crt " ▁# define ▁US 897_ CACERTS ▁" CA / estCA / cacert . crt " ▁# define ▁US 897_ TRUST _ CERTS ▁" CA / trustedcerts . crt " ▁# define ▁US 897_ SERVER _ CERTKEY ▁" CA / estCA / private / estserver cert and key . pem " ▁# define ▁US 897_ CACERTS _ SING LE _ CHAIN _ MULT _ CERTS ▁" US 897/ single chain _ 10 certs _ trusted . crt " ▁# define ▁US 897_ CACERTS _ SING LE _ CHAIN _ MULT _ CERTS _ ONE _ MISSING ▁" US 897/ single chain _ 9 certs _ m is s ing cert . crt " ▁# define ▁US 897_ CACERTS _ SING LE _ CHAIN _ EXPIRED ▁" US 897/ single chain _ expired . crt " ▁# define ▁US 897_ CACERTS _ MULT I _ CHAIN _ CRL S ▁" US 897/ trusted CH a in 10 Revoke d De p th 6 Implicit 10 and cacert . crt " ▁# else ▁# define ▁CLIENT _ UT _ CACERT ▁" CA \\ estCA / cacert . crt " ▁# define ▁US 897_ CACERTS ▁" CA \\ estCA \\ cacert . crt " ▁# define ▁US 897_ TRUST _ CERTS ▁" CA \\ trustedcerts . crt " ▁# define ▁US 897_ SERVER _ CERTKEY ▁" CA \\ estCA \\ private \\ estserver cert and key . pem " ▁# define ▁US 897_ CACERTS _ SING LE _ CHAIN _ MULT _ CERTS ▁" US 897\\ single chain _ 10 certs _ trusted . crt " ▁# define ▁US 897_ CACERTS _ SING LE _ CHAIN _ MULT _ CERTS _ ONE _ MISSING ▁" US 897\\ single chain _ 9 certs _ m is s ing cert . crt " ▁# define ▁US 897_ CACERTS _ SING LE _ CHAIN _ EXPIRED ▁" US 897\\ single chain _ expired . crt " ▁# define ▁US 897_ CACERTS _ MULT I _ CHAIN _ CRL S ▁" US 897\\ trusted CH a in 10 Revoke d De p th 6 Implicit 10 and cacert . crt " ▁# endif ▁static ▁void ▁us 897_ clean ▁( void ) ▁{ ▁} ▁static ▁int ▁us 897_ start _ server ▁( int ▁manual _ enroll , ▁int ▁nid ) ▁{ ▁int ▁rv ; ▁rv ▁= ▁st _ start ( US 897_ SERVER _ PORT , ▁US 897_ SERVER _ CERTKEY , ▁US 897_ SERVER _ CERTKEY , ▁" US 897 ▁test ▁realm ", ▁US 897_ CACERTS , ▁US 897_ TRUST _ CERTS , ▁" CA / est Example CA . cnf ", ▁manual _ enroll , ▁0, ▁nid ); ▁SL EEP (1); ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁initialize s ▁this ▁test ▁* ▁suite . ▁* ▁1 . ▁Generate ▁the ▁ keypair ▁to ▁be ▁used ▁for ▁this ▁EST ▁Client ▁ UT ▁suite ▁*/ ▁static ▁int ▁us 897_ init _ suite ▁( void ) ▁{ ▁int ▁rv ▁= ▁0; ▁char ▁cmd [ EST _ UT _ MAX _ CMD _ LEN ] ; ▁ printf (" Start ing ▁EST ▁Client ▁ unit ▁tests . ▁PDB \ n "); ▁/* ▁* ▁gen ▁the ▁ keypair ▁to ▁be ▁used ▁for ▁EST ▁Client ▁testing ▁*/ ▁ snprintf ( cmd , ▁EST _ UT _ MAX _ CMD _ LEN , ▁" openssl ▁ec param ▁- name ▁prime 256 v 1 ▁- gen key ▁- out ▁% s ", ▁CLIENT _ UT _ PUBKEY ); ▁ printf ("% s \ n ", ▁cmd ); ▁rv ▁= ▁system ( cmd ); ▁/* ▁* ▁start ▁the ▁server ▁for ▁the ▁tests ▁that ▁need ▁to ▁t alk ▁to ▁a ▁server ▁*/ ▁us 897_ clean (); ▁/* ▁* ▁Start ▁an ▁instance ▁of ▁the ▁EST ▁server ▁*/ ▁rv ▁= ▁us 897_ start _ server (0, ▁0); ▁SL EEP ( 2 ); ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁uninitialize s ▁this ▁test ▁* ▁suite . ▁This ▁can ▁be ▁used ▁to ▁de allocate ▁data ▁or ▁close ▁any ▁* ▁ resources ▁that ▁we re ▁used ▁for ▁the ▁test ▁cases . ▁*/ ▁static ▁int ▁us 897_ destroy _ suite ▁( void ) ▁{ ▁st _ stop (); ▁return ▁0; ▁} ▁/* ▁* ▁C allback ▁function ▁passed ▁to ▁est _ client _ init () ▁*/ ▁static ▁int ▁client _ manual _ cert _ verify ( X 509 ▁* cur _ cert , ▁int ▁openssl _ cert _ error ) ▁{ ▁BIO ▁* bio _ err ; ▁bio _ err = BIO _ new _ fp ( stderr , BIO _ NO CLOSE ); ▁int ▁approve ▁= ▁0; ▁/* ▁* ▁ Print ▁out ▁the ▁specific s ▁of ▁this ▁cert ▁*/ ▁ printf ("% s : ▁OpenSSL / EST ▁server ▁cert ▁verification ▁failed ▁with ▁the ▁following ▁error : ▁openssl _ cert _ error ▁= ▁% d ▁(% s ) \ n ", ▁ _ _ FUNCTION _ _ , ▁openssl _ cert _ error , ▁X 509_ verify _ cert _ error _ string ( openssl _ cert _ error )); ▁ printf (" Fail ing ▁Cert :\ n "); ▁X 509_ print _ fp ( stdout , cur _ cert ); ▁/* ▁* ▁ Next ▁call ▁print s ▁out ▁the ▁signature ▁which ▁can ▁be ▁used ▁as ▁the ▁fingerprint ▁* ▁This ▁fingerprint ▁can ▁be ▁checked ▁against ▁the ▁an ticipat ed ▁value ▁to ▁determine ▁* ▁whether ▁or ▁not ▁the ▁server ' s ▁cert ▁should ▁be ▁approved . ▁*/ ▁X 509_ signature _ print ( bio _ err , ▁cur _ cert -> sig _ alg , ▁cur _ cert -> signature ); ▁if ▁( openssl _ cert _ error ▁== ▁X 509_ V _ ERR _ U NABLE _ TO _ GET _ CRL ) ▁{ ▁approve ▁= ▁1; ▁} ▁BIO _ free ( bio _ err ); ▁return ▁approve ; ▁} ▁/* ▁* ▁This ▁test ▁case ▁initialize s ▁an ▁EST ▁client ▁context ▁* ▁using ▁local ▁CA ▁certs , ▁no ▁client ▁cert , ▁and ▁a ▁valid ▁public ▁key , ▁* ▁no ▁userid ▁and ▁password . ▁*/ ▁static ▁void ▁us 897_ test 1 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁un signed ▁char ▁* pkey ▁= ▁NULL ; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁EST _ ERROR ▁rc ; ▁E VP _ PKEY ▁* priv _ key ; ▁SL EEP (1); ▁/* ▁* ▁ Read ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁CU _ ASSERT ( cacerts _ len ▁> ▁0); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁file ▁*/ ▁priv _ key ▁= ▁read _ private _ key ( CLIENT _ UT _ PUBKEY ); ▁if ▁( priv _ key ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁while ▁reading ▁private ▁key ▁file ▁% s \ n ", ▁CLIENT _ UT _ PUBKEY ); ▁return ; ▁} ▁est _ init _ logger ( EST _ LOG _ L VL _ INFO , ▁NULL ); ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁rc ▁= ▁est _ client _ set _ auth ( ectx , ▁"", ▁"", ▁NULL , ▁priv _ key ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁if ▁( ectx ) ▁{ ▁est _ destroy ( ectx ); ▁} ▁if ▁( cacerts ) ▁{ ▁free ( cacerts ); ▁} ▁if ▁( pkey ) ▁{ ▁free ( pkey ); ▁} ▁} ▁/* ▁* ▁This ▁test ▁case ▁initialize s ▁an ▁EST ▁client ▁context ▁* ▁using ▁no ▁local ▁CA ▁certs . ▁This ▁is ▁expected ▁to ▁be ▁a ▁successful ▁initialization ▁* ▁since ▁the ▁local ▁CA ▁trust ▁anchor ▁certs ▁are ▁not ▁mandatory . ▁*/ ▁static ▁void ▁us 897_ test 2 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁un signed ▁char ▁* pkey ▁= ▁NULL ; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁E VP _ PKEY ▁* priv _ key ; ▁SL EEP (1); ▁/* ▁* ▁ Read ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁CU _ ASSERT ( cacerts _ len ▁> ▁0); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁file ▁*/ ▁priv _ key ▁= ▁read _ private _ key ( CLIENT _ UT _ PUBKEY ); ▁if ▁( priv _ key ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁while ▁reading ▁private ▁key ▁file ▁% s \ n ", ▁CLIENT _ UT _ PUBKEY ); ▁return ; ▁} ▁ectx ▁= ▁est _ client _ init ( NULL , ▁0, ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁if ▁( ectx ) ▁{ ▁est _ destroy ( ectx ); ▁} ▁if ▁( cacerts ) ▁{ ▁free ( cacerts ); ▁} ▁if ▁( pkey ) ▁{ ▁free ( pkey ); ▁} ▁} ▁/* ▁* ▁This ▁test ▁case ▁initialize s ▁an ▁EST ▁client ▁context ▁* ▁using ▁a ▁local ▁CA ▁cert , ▁no ▁client ▁cert , ▁* ▁and ▁a ▁valid ▁public ▁key , ▁no ▁userid ▁and ▁password . ▁*/ ▁static ▁void ▁us 897_ test 3 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁un signed ▁char ▁* pkey ▁= ▁NULL ; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁EST _ ERROR ▁rc ; ▁E VP _ PKEY ▁* priv _ key ; ▁SL EEP (1); ▁/* ▁* ▁ Read ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁CU _ ASSERT ( cacerts _ len ▁> ▁0); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁file ▁*/ ▁priv _ key ▁= ▁read _ private _ key ( CLIENT _ UT _ PUBKEY ); ▁if ▁( priv _ key ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁while ▁reading ▁private ▁key ▁file ▁% s \ n ", ▁CLIENT _ UT _ PUBKEY ); ▁return ; ▁} ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁rc ▁= ▁est _ client _ set _ auth ( ectx , ▁"", ▁"", ▁NULL , ▁priv _ key ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁if ▁( ectx ) ▁{ ▁est _ destroy ( ectx ); ▁} ▁if ▁( cacerts ) ▁{ ▁free ( cacerts ); ▁} ▁if ▁( pkey ) ▁{ ▁free ( pkey ); ▁} ▁} ▁# if ▁0 ▁/* ▁* ▁This ▁test ▁case ▁initialize s ▁an ▁EST ▁client ▁context ▁* ▁using ▁explict ▁CA ▁certs , ▁no ▁client ▁cert , ▁and ▁a ▁valid ▁public ▁key , ▁* ▁no ▁userid ▁and ▁password . ▁*/ ▁static ▁void ▁us 897_ test 3 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁un signed ▁char ▁* pkey ▁= ▁NULL ; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁EST _ ERROR ▁rc ; ▁E VP _ PKEY ▁* priv _ key ; ▁/* ▁* ▁ Read ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁CU _ ASSERT ( cacerts _ len ▁> ▁0); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁file ▁*/ ▁priv _ key ▁= ▁read _ private _ key ( CLIENT _ UT _ PUBKEY ); ▁if ▁( priv _ key ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁while ▁reading ▁private ▁key ▁file ▁% s \ n ", ▁CLIENT _ UT _ PUBKEY ); ▁return ; ▁} ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁rc ▁= ▁est _ client _ set _ auth ( ectx , ▁"", ▁"", ▁NULL , ▁priv _ key ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁if ▁( ectx ) ▁{ ▁est _ destroy ( ectx ); ▁} ▁if ▁( cacerts ) ▁{ ▁free ( cacerts ); ▁} ▁if ▁( pkey ) ▁{ ▁free ( pkey ); ▁} ▁} ▁# endif ▁/* ▁* ▁This ▁test ▁case ▁initialize s ▁an ▁EST ▁client ▁context ▁* ▁using ▁explict ▁CA ▁certs , ▁no ▁client ▁cert , ▁a ▁public ▁key , ▁* ▁and ▁a ▁userid ▁and ▁password . ▁*/ ▁static ▁void ▁us 897_ test 6 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁un signed ▁char ▁* pkey ▁= ▁NULL ; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁EST _ ERROR ▁rc ; ▁E VP _ PKEY ▁* priv _ key ; ▁SL EEP (1); ▁/* ▁* ▁ Read ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁CU _ ASSERT ( cacerts _ len ▁> ▁0); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁file ▁*/ ▁priv _ key ▁= ▁read _ private _ key ( CLIENT _ UT _ PUBKEY ); ▁if ▁( priv _ key ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁while ▁reading ▁private ▁key ▁file ▁% s \ n ", ▁CLIENT _ UT _ PUBKEY ); ▁return ; ▁} ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁rc ▁= ▁est _ client _ set _ auth ( ectx , ▁" USER ", ▁" PASSWORD ", ▁NULL , ▁priv _ key ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁if ▁( ectx ) ▁{ ▁est _ destroy ( ectx ); ▁} ▁if ▁( cacerts ) ▁{ ▁free ( cacerts ); ▁} ▁if ▁( pkey ) ▁{ ▁free ( pkey ); ▁} ▁} ▁/* ▁* ▁This ▁test ▁case ▁initialize s ▁an ▁EST ▁client ▁context ▁* ▁using ▁explict ▁CA ▁certs , ▁no ▁client ▁cert , ▁a ▁public ▁key , ▁* ▁and ▁a ▁userid ▁and ▁ NO ▁password . ▁*/ ▁static ▁void ▁us 897_ test 7 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁un signed ▁char ▁* pkey ▁= ▁NULL ; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁EST _ ERROR ▁rc ; ▁E VP _ PKEY ▁* priv _ key ; ▁SL EEP (1); ▁/* ▁* ▁ Read ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁CU _ ASSERT ( cacerts _ len ▁> ▁0); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁file ▁*/ ▁priv _ key ▁= ▁read _ private _ key ( CLIENT _ UT _ PUBKEY ); ▁if ▁( priv _ key ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁while ▁reading ▁private ▁key ▁file ▁% s \ n ", ▁CLIENT _ UT _ PUBKEY ); ▁return ; ▁} ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁rc ▁= ▁est _ client _ set _ auth ( ectx , ▁" USER ", ▁NULL , ▁NULL , ▁priv _ key ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ INVALID _ PARAMETERS ); ▁if ▁( ectx ) ▁{ ▁est _ destroy ( ectx ); ▁} ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁rc ▁= ▁est _ client _ set _ auth ( ectx , ▁NULL , ▁" PASSWORD ", ▁NULL , ▁priv _ key ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ INVALID _ PARAMETERS ); ▁if ▁( ectx ) ▁{ ▁est _ destroy ( ectx ); ▁} ▁if ▁( cacerts ) ▁{ ▁free ( cacerts ); ▁} ▁if ▁( pkey ) ▁{ ▁free ( pkey ); ▁} ▁} ▁/* ▁* ▁This ▁test ▁case ▁tests ▁the ▁set ▁server ▁with ▁valid ▁parameters ▁*/ ▁static ▁void ▁us 897_ test 9 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁un signed ▁char ▁* pkey ▁= ▁NULL ; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁EST _ ERROR ▁rc ▁= ▁EST _ ERR _ NONE ; ▁E VP _ PKEY ▁* priv _ key ; ▁SL EEP (1); ▁/* ▁* ▁ Read ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁file ▁*/ ▁priv _ key ▁= ▁read _ private _ key ( CLIENT _ UT _ PUBKEY ); ▁if ▁( priv _ key ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁while ▁reading ▁private ▁key ▁file ▁% s \ n ", ▁CLIENT _ UT _ PUBKEY ); ▁return ; ▁} ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁rc ▁= ▁est _ client _ set _ auth ( ectx , ▁"", ▁"", ▁NULL , ▁priv _ key ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ set _ server ( ectx , ▁US 897_ SERVER _ IP , ▁US 897_ SERVER _ PORT , ▁NULL ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁if ▁( ectx ) ▁{ ▁est _ destroy ( ectx ); ▁} ▁if ▁( cacerts ) ▁{ ▁free ( cacerts ); ▁} ▁if ▁( pkey ) ▁{ ▁free ( pkey ); ▁} ▁} ▁/* ▁* ▁This ▁test ▁case ▁tests ▁the ▁set ▁server ▁with ▁invalid ▁parameters ▁*/ ▁static ▁void ▁us 897_ test 10 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁un signed ▁char ▁* pkey ▁= ▁NULL ; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁EST _ ERROR ▁rc ▁= ▁EST _ ERR _ NONE ; ▁char ▁* server _ name _ too _ long ▁= ▁"123456789 01234567890 123456789012345 678901234567890" \ ▁"123456789 01234567890 123456789012345 678901234567890" \ ▁"123456789 01234567890 123456789012345 678901234567890" \ ▁"123456789 01234567890 123456789012345 678901234567890" \ ▁" 1234567890 123456789012345 678901234567890 1234567890123456 "; ▁E VP _ PKEY ▁* priv _ key ; ▁SL EEP (1); ▁/* ▁* ▁ Read ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁file ▁*/ ▁priv _ key ▁= ▁read _ private _ key ( CLIENT _ UT _ PUBKEY ); ▁if ▁( priv _ key ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁while ▁reading ▁private ▁key ▁file ▁% s \ n ", ▁CLIENT _ UT _ PUBKEY ); ▁return ; ▁} ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁rc ▁= ▁est _ client _ set _ auth ( ectx , ▁"", ▁"", ▁NULL , ▁priv _ key ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Null ▁server ▁name ▁*/ ▁rc ▁= ▁est _ client _ set _ server ( ectx , ▁NULL , ▁US 897_ SERVER _ PORT , ▁NULL ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ INVALID _ SERVER _ NAME ); ▁/* ▁* ▁server ▁too ▁long ▁*/ ▁rc ▁= ▁est _ client _ set _ server ( ectx , ▁server _ name _ too _ long , ▁US 897_ SERVER _ PORT , ▁NULL ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ INVALID _ SERVER _ NAME ); ▁/* ▁* ▁port ▁num ▁ less ▁than ▁0 ▁*/ ▁rc ▁= ▁est _ client _ set _ server ( ectx , ▁US 897_ SERVER _ IP , ▁-1, ▁NULL ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ INVALID _ PORT _ NUM ); ▁/* ▁* ▁port ▁num ▁greate r ▁than ▁max ▁*/ ▁rc ▁= ▁est _ client _ set _ server ( ectx , ▁US 897_ SERVER _ IP , ▁65536 , ▁NULL ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ INVALID _ PORT _ NUM ); ▁if ▁( ectx ) ▁{ ▁est _ destroy ( ectx ); ▁} ▁if ▁( cacerts ) ▁{ ▁free ( cacerts ); ▁} ▁if ▁( pkey ) ▁{ ▁free ( pkey ); ▁} ▁} ▁/* ▁* ▁This ▁test ▁case ▁tests ▁the ▁Get ▁CACerts ▁request ▁* ▁*/ ▁static ▁void ▁us 897_ test 11 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁un signed ▁char ▁* pkey ▁= ▁NULL ; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁EST _ ERROR ▁rc ▁= ▁EST _ ERR _ NONE ; ▁un signed ▁char ▁* retrieved _ cacerts ▁= ▁NULL ; ▁int ▁retrieved _ cacerts _ len ▁= ▁0; ▁E VP _ PKEY ▁* priv _ key ; ▁SL EEP (1); ▁/* ▁* ▁ Read ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁CU _ ASSERT ( cacerts _ len ▁> ▁0); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁file ▁*/ ▁priv _ key ▁= ▁read _ private _ key ( CLIENT _ UT _ PUBKEY ); ▁if ▁( priv _ key ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁while ▁reading ▁private ▁key ▁file ▁% s \ n ", ▁CLIENT _ UT _ PUBKEY ); ▁return ; ▁} ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁rc ▁= ▁est _ client _ set _ auth ( ectx , ▁"", ▁"", ▁NULL , ▁priv _ key ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁est _ client _ set _ server ( ectx , ▁US 897_ SERVER _ IP , ▁US 897_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁issue ▁the ▁get ▁ca ▁certs ▁request ▁*/ ▁rc ▁= ▁est _ client _ get _ cacerts ( ectx , ▁& retrieved _ cacerts _ len ); ▁/* ▁* ▁should ▁be ▁successful , ▁and ▁should ▁have ▁obtained ▁a ▁valid ▁buffer ▁* ▁containing ▁the ▁CA ▁certs ▁*/ ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( retrieved _ cacerts _ len ▁> ▁0); ▁retrieved _ cacerts ▁= ▁malloc ( retrieved _ cacerts _ len ); ▁rc ▁= ▁est _ client _ copy _ cacerts ( ectx , ▁retrieved _ cacerts ); ▁/* ▁* ▁output ▁the ▁retrieved ▁ca ▁certs ▁and ▁compare ▁to ▁what ▁they ▁should ▁be ▁*/ ▁if ▁( retrieved _ cacerts ) ▁{ ▁ printf ("\ nR etrieved ▁CA ▁Certs ▁buffer :\ n ▁% s \ n ", ▁retrieved _ cacerts ); ▁ printf (" Retrieve d ▁CA ▁certs ▁buffer ▁length : ▁% d \ n ", ▁retrieved _ cacerts _ len ); ▁} ▁free ( retrieved _ cacerts ); ▁/* ▁* ▁make ▁sure ▁that ▁the ▁context ▁is ▁no ▁long er ▁valid ▁and ▁the ▁EST ▁client ▁is ▁* ▁back ▁to ▁the ▁uninitialize d ▁state ▁*/ ▁rc ▁= ▁est _ client _ get _ cacerts ( ectx , ▁& retrieved _ cacerts _ len ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ CLIENT _ NOT _ INITIALIZED ); ▁if ▁( ectx ) ▁{ ▁est _ destroy ( ectx ); ▁} ▁if ▁( cacerts ) ▁{ ▁free ( cacerts ); ▁} ▁if ▁( pkey ) ▁{ ▁free ( pkey ); ▁} ▁} ▁/* ▁* ▁This ▁test ▁case ▁tests ▁the ▁Get ▁CACerts ▁request ▁with ▁invalid ▁input ▁parameters ▁* ▁*/ ▁static ▁void ▁us 897_ test 12 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁un signed ▁char ▁* pkey ▁= ▁NULL ; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁EST _ ERROR ▁rc ▁= ▁EST _ ERR _ NONE ; ▁E VP _ PKEY ▁* priv _ key ; ▁SL EEP (1); ▁/* ▁* ▁ Read ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁CU _ ASSERT ( cacerts _ len ▁> ▁0); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁file ▁*/ ▁priv _ key ▁= ▁read _ private _ key ( CLIENT _ UT _ PUBKEY ); ▁if ▁( priv _ key ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁while ▁reading ▁private ▁key ▁file ▁% s \ n ", ▁CLIENT _ UT _ PUBKEY ); ▁return ; ▁} ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁rc ▁= ▁est _ client _ set _ auth ( ectx , ▁"", ▁"", ▁NULL , ▁priv _ key ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁est _ client _ set _ server ( ectx , ▁US 897_ SERVER _ IP , ▁US 897_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁issue ▁the ▁get ▁ca ▁certs ▁request ▁*/ ▁rc ▁= ▁est _ client _ get _ cacerts ( ectx , ▁NULL ); ▁/* ▁* ▁should ▁be ▁successful , ▁and ▁should ▁have ▁obtained ▁a ▁valid ▁buffer ▁* ▁containing ▁the ▁CA ▁certs ▁*/ ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ INVALID _ PARAMETERS ); ▁if ▁( ectx ) ▁{ ▁est _ destroy ( ectx ); ▁} ▁if ▁( cacerts ) ▁{ ▁free ( cacerts ); ▁} ▁if ▁( pkey ) ▁{ ▁free ( pkey ); ▁} ▁} ▁/* ▁* ▁This ▁test ▁case ▁tests ▁the ▁CA ▁cert ▁response ▁verification ▁function . ▁It ▁will ▁* ▁verify ▁a ▁CA cert ▁response ▁containing ▁a ▁single ▁certificate ▁*/ ▁static ▁void ▁us 897_ test 13 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁un signed ▁char ▁* pkey ▁= ▁NULL ; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁EST _ ERROR ▁rc ▁= ▁EST _ ERR _ NONE ; ▁E VP _ PKEY ▁* priv _ key ; ▁un signed ▁char ▁* retrieved _ cacerts ▁= ▁NULL ; ▁int ▁retrieved _ cacerts _ len ▁= ▁0; ▁/* ▁* ▁S top ▁the ▁existing ▁server . ▁Need ▁to ▁ensure ▁that ▁the ▁server ▁* ▁is ▁using ▁a ▁specific ▁CA ▁cert ▁chain . ▁*/ ▁st _ stop (); ▁SL EEP ( 2 ); ▁/* ▁* ▁Spi n ▁up ▁a ▁new ▁instance ▁of ▁the ▁EST ▁server ▁* ▁using ▁a ▁CA ▁cert ▁chain ▁that ▁contains ▁just ▁one ▁cert ▁*/ ▁rc ▁= ▁st _ start ( US 897_ SERVER _ PORT , ▁US 897_ SERVER _ CERTKEY , ▁US 897_ SERVER _ CERTKEY , ▁" US 897 ▁test ▁realm ", ▁US 897_ CACERTS , ▁US 897_ TRUST _ CERTS , ▁" CA / est Example CA . cnf ", ▁0, ▁0, ▁0); ▁CU _ ASSERT ( rc ▁== ▁0); ▁if ▁( rc ) ▁return ; ▁SL EEP (1); ▁/* ▁* ▁ Read ▁in ▁the startup ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁CU _ ASSERT ( cacerts _ len ▁> ▁0); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁file ▁*/ ▁priv _ key ▁= ▁read _ private _ key ( CLIENT _ UT _ PUBKEY ); ▁if ▁( priv _ key ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁while ▁reading ▁private ▁key ▁file ▁% s \ n ", ▁CLIENT _ UT _ PUBKEY ); ▁return ; ▁} ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁rc ▁= ▁est _ client _ set _ auth ( ectx , ▁"", ▁"", ▁NULL , ▁priv _ key ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁est _ client _ set _ server ( ectx , ▁US 897_ SERVER _ IP , ▁US 897_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁issue ▁the ▁get ▁ca ▁certs ▁request ▁*/ ▁rc ▁= ▁est _ client _ get _ cacerts ( ectx , ▁& retrieved _ cacerts _ len ); ▁/* ▁* ▁should ▁be ▁successful , ▁and ▁should ▁have ▁obtained ▁a ▁valid ▁length ▁* ▁for ▁the ▁size ▁of ▁the ▁CA ▁certs ▁buffer ▁*/ ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( retrieved _ cacerts _ len ▁> ▁0); ▁retrieved _ cacerts ▁= ▁malloc ( retrieved _ cacerts _ len ); ▁rc ▁= ▁est _ client _ copy _ cacerts ( ectx , ▁retrieved _ cacerts ); ▁/* ▁* ▁output ▁the ▁retrieved ▁ca ▁certs ▁and ▁compare ▁to ▁what ▁they ▁should ▁be ▁*/ ▁if ▁( retrieved _ cacerts ) ▁{ ▁ printf ("\ nR etrieved ▁CA ▁Certs ▁buffer :\ n ▁% s \ n ", ▁retrieved _ cacerts ); ▁ printf (" Retrieve d ▁CA ▁certs ▁buffer ▁length : ▁% d \ n ", ▁retrieved _ cacerts _ len ); ▁} ▁free ( retrieved _ cacerts ); ▁if ▁( ectx ) ▁{ ▁est _ destroy ( ectx ); ▁} ▁if ▁( cacerts ) ▁{ ▁free ( cacerts ); ▁} ▁if ▁( pkey ) ▁{ ▁free ( pkey ); ▁} ▁} ▁/* ▁* ▁This ▁test ▁case ▁tests ▁the ▁CA ▁cert ▁response ▁verification ▁function . ▁It ▁will ▁* ▁verify ▁a ▁CA cert ▁response ▁containing ▁a ▁single ▁chain ▁with ▁multiple ▁certs ▁*/ ▁static ▁void ▁us 897_ test 14 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁un signed ▁char ▁* pkey ▁= ▁NULL ; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁EST _ ERROR ▁rc ▁= ▁EST _ ERR _ NONE ; ▁E VP _ PKEY ▁* priv _ key ; ▁un signed ▁char ▁* retrieved _ cacerts ▁= ▁NULL ; ▁int ▁retrieved _ cacerts _ len ▁= ▁0; ▁/* ▁* ▁S top ▁the ▁existing ▁server . ▁Need ▁to ▁ensure ▁that ▁the ▁server ▁* ▁is ▁using ▁a ▁specific ▁CA ▁cert ▁chain . ▁*/ ▁st _ stop (); ▁SL EEP ( 2 ); ▁/* ▁* ▁Spi n ▁up ▁a ▁new ▁instance ▁of ▁the ▁EST ▁server ▁* ▁using ▁a ▁CA ▁cert ▁chain ▁that ▁contains ▁just ▁one ▁cert ▁*/ ▁rc ▁= ▁st _ start ( US 897_ SERVER _ PORT , ▁US 897_ SERVER _ CERTKEY , ▁US 897_ SERVER _ CERTKEY , ▁" US 897 ▁test ▁realm ", ▁US 897_ CACERTS _ SING LE _ CHAIN _ MULT _ CERTS , ▁US 897_ TRUST _ CERTS , ▁" CA / est Example CA . cnf ", ▁0, ▁0, ▁0); ▁CU _ ASSERT ( rc ▁== ▁0); ▁if ▁( rc ) ▁return ; ▁SL EEP (1); ▁/* ▁* ▁ Read ▁in ▁the startup ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁CU _ ASSERT ( cacerts _ len ▁> ▁0); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁file ▁*/ ▁priv _ key ▁= ▁read _ private _ key ( CLIENT _ UT _ PUBKEY ); ▁if ▁( priv _ key ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁while ▁reading ▁private ▁key ▁file ▁% s \ n ", ▁CLIENT _ UT _ PUBKEY ); ▁return ; ▁} ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁rc ▁= ▁est _ client _ set _ auth ( ectx , ▁"", ▁"", ▁NULL , ▁priv _ key ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁est _ client _ set _ server ( ectx , ▁US 897_ SERVER _ IP , ▁US 897_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁issue ▁the ▁get ▁ca ▁certs ▁request ▁*/ ▁rc ▁= ▁est _ client _ get _ cacerts ( ectx , ▁& retrieved _ cacerts _ len ); ▁/* ▁* ▁should ▁be ▁successful , ▁and ▁should ▁have ▁obtained ▁a ▁valid ▁length ▁* ▁for ▁the ▁size ▁of ▁the ▁CA ▁certs ▁buffer ▁*/ ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( retrieved _ cacerts _ len ▁> ▁0); ▁retrieved _ cacerts ▁= ▁malloc ( retrieved _ cacerts _ len ); ▁rc ▁= ▁est _ client _ copy _ cacerts ( ectx , ▁retrieved _ cacerts ); ▁/* ▁* ▁output ▁the ▁retrieved ▁ca ▁certs ▁and ▁compare ▁to ▁what ▁they ▁should ▁be ▁*/ ▁if ▁( retrieved _ cacerts ) ▁{ ▁ printf ("\ nR etrieved ▁CA ▁Certs ▁buffer :\ n ▁% s \ n ", ▁retrieved _ cacerts ); ▁ printf (" Retrieve d ▁CA ▁certs ▁buffer ▁length : ▁% d \ n ", ▁retrieved _ cacerts _ len ); ▁} ▁free ( retrieved _ cacerts ); ▁if ▁( ectx ) ▁{ ▁est _ destroy ( ectx ); ▁} ▁if ▁( cacerts ) ▁{ ▁free ( cacerts ); ▁} ▁if ▁( pkey ) ▁{ ▁free ( pkey ); ▁} ▁} ▁/* ▁* ▁This ▁test ▁case ▁tests ▁the ▁CA ▁cert ▁response ▁verification ▁function . ▁It ▁will ▁* ▁verify ▁a ▁CA cert ▁response ▁containing ▁a ▁single ▁chain ▁with ▁multiple ▁certs ▁and ▁* ▁a ▁missing ▁cert ▁in ▁the ▁chain . ▁*/ ▁static ▁void ▁us 897_ test 15 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁un signed ▁char ▁* pkey ▁= ▁NULL ; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁EST _ ERROR ▁rc ▁= ▁EST _ ERR _ NONE ; ▁E VP _ PKEY ▁* priv _ key ; ▁un signed ▁char ▁* retrieved _ cacerts ▁= ▁NULL ; ▁int ▁retrieved _ cacerts _ len ▁= ▁0; ▁/* ▁* ▁S top ▁the ▁existing ▁server . ▁Need ▁to ▁ensure ▁that ▁the ▁server ▁* ▁is ▁using ▁a ▁specific ▁CA ▁cert ▁chain . ▁*/ ▁st _ stop (); ▁SL EEP ( 2 ); ▁/* ▁* ▁Spi n ▁up ▁a ▁new ▁instance ▁of ▁the ▁EST ▁server ▁* ▁using ▁a ▁CA ▁cert ▁chain ▁that ▁contains ▁just ▁one ▁cert ▁*/ ▁rc ▁= ▁st _ start ( US 897_ SERVER _ PORT , ▁US 897_ SERVER _ CERTKEY , ▁US 897_ SERVER _ CERTKEY , ▁" US 897 ▁test ▁realm ", ▁US 897_ CACERTS _ SING LE _ CHAIN _ MULT _ CERTS _ ONE _ MISSING , ▁US 897_ TRUST _ CERTS , ▁" CA / est Example CA . cnf ", ▁0, ▁0, ▁0); ▁CU _ ASSERT ( rc ▁== ▁0); ▁if ▁( rc ) ▁return ; ▁SL EEP (1); ▁/* ▁* ▁ Read ▁in ▁the startup ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁CU _ ASSERT ( cacerts _ len ▁> ▁0); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁file ▁*/ ▁priv _ key ▁= ▁read _ private _ key ( CLIENT _ UT _ PUBKEY ); ▁if ▁( priv _ key ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁while ▁reading ▁private ▁key ▁file ▁% s \ n ", ▁CLIENT _ UT _ PUBKEY ); ▁return ; ▁} ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁rc ▁= ▁est _ client _ set _ auth ( ectx , ▁"", ▁"", ▁NULL , ▁priv _ key ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁est _ client _ set _ server ( ectx , ▁US 897_ SERVER _ IP , ▁US 897_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁issue ▁the ▁get ▁ca ▁certs ▁request ▁*/ ▁rc ▁= ▁est _ client _ get _ cacerts ( ectx , ▁& retrieved _ cacerts _ len ); ▁/* ▁* ▁should ▁be ▁successful , ▁and ▁should ▁have ▁obtained ▁a ▁valid ▁length ▁* ▁for ▁the ▁size ▁of ▁the ▁CA ▁certs ▁buffer ▁*/ ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ CACERT _ VERIFICATION ); ▁CU _ ASSERT ( retrieved _ cacerts _ len ▁== ▁0); ▁if ▁( retrieved _ cacerts _ len ) ▁{ ▁/* ▁* ▁Should n ' t ▁be ▁in ▁here , ▁but ▁if ▁we ▁are , ▁malloc ▁and ▁call ▁*/ ▁retrieved _ cacerts ▁= ▁malloc ( retrieved _ cacerts _ len ); ▁rc ▁= ▁est _ client _ copy _ cacerts ( ectx , ▁retrieved _ cacerts ); ▁/* ▁* ▁est ▁should ▁fail ▁indicat ing ▁that ▁there ' s ▁no ▁cert ▁to ▁provide ▁*/ ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NO _ CERTIFICATE ); ▁} ▁/* ▁* ▁output ▁the ▁retrieved ▁ca ▁certs ▁and ▁compare ▁to ▁what ▁they ▁should ▁be ▁*/ ▁if ▁( retrieved _ cacerts ) ▁{ ▁ printf ("\ nR etrieved ▁CA ▁Certs ▁buffer :\ n ▁% s \ n ", ▁retrieved _ cacerts ); ▁ printf (" Retrieve d ▁CA ▁certs ▁buffer ▁length : ▁% d \ n ", ▁retrieved _ cacerts _ len ); ▁} ▁free ( retrieved _ cacerts ); ▁if ▁( ectx ) ▁{ ▁est _ destroy ( ectx ); ▁} ▁if ▁( cacerts ) ▁{ ▁free ( cacerts ); ▁} ▁if ▁( pkey ) ▁{ ▁free ( pkey ); ▁} ▁} ▁/* ▁* ▁This ▁test ▁case ▁tests ▁the ▁CA ▁cert ▁response ▁verification ▁function . ▁It ▁will ▁* ▁verify ▁a ▁CA cert ▁response ▁containing ▁a ▁single ▁chain ▁with ▁multiple ▁certs ▁* ▁with ▁the ▁inter mediate ▁cert ▁expired . ▁*/ ▁static ▁void ▁us 897_ test 16 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁un signed ▁char ▁* pkey ▁= ▁NULL ; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁EST _ ERROR ▁rc ▁= ▁EST _ ERR _ NONE ; ▁E VP _ PKEY ▁* priv _ key ; ▁un signed ▁char ▁* retrieved _ cacerts ▁= ▁NULL ; ▁int ▁retrieved _ cacerts _ len ▁= ▁0; ▁/* ▁* ▁S top ▁the ▁existing ▁server . ▁Need ▁to ▁ensure ▁that ▁the ▁server ▁* ▁is ▁using ▁a ▁specific ▁CA ▁cert ▁chain . ▁*/ ▁st _ stop (); ▁SL EEP ( 2 ); ▁/* ▁* ▁Spi n ▁up ▁a ▁new ▁instance ▁of ▁the ▁EST ▁server ▁* ▁using ▁a ▁CA ▁cert ▁chain ▁that ▁contains ▁just ▁one ▁cert ▁*/ ▁rc ▁= ▁st _ start ( US 897_ SERVER _ PORT , ▁US 897_ SERVER _ CERTKEY , ▁US 897_ SERVER _ CERTKEY , ▁" US 897 ▁test ▁realm ", ▁US 897_ CACERTS _ SING LE _ CHAIN _ EXPIRED , ▁US 897_ TRUST _ CERTS , ▁" CA / est Example CA . cnf ", ▁0, ▁0, ▁0); ▁CU _ ASSERT ( rc ▁== ▁0); ▁if ▁( rc ) ▁return ; ▁SL EEP (1); ▁/* ▁* ▁ Read ▁in ▁the startup ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁CU _ ASSERT ( cacerts _ len ▁> ▁0); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁file ▁*/ ▁priv _ key ▁= ▁read _ private _ key ( CLIENT _ UT _ PUBKEY ); ▁if ▁( priv _ key ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁while ▁reading ▁private ▁key ▁file ▁% s \ n ", ▁CLIENT _ UT _ PUBKEY ); ▁return ; ▁} ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁rc ▁= ▁est _ client _ set _ auth ( ectx , ▁"", ▁"", ▁NULL , ▁priv _ key ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁est _ client _ set _ server ( ectx , ▁US 897_ SERVER _ IP , ▁US 897_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁issue ▁the ▁get ▁ca ▁certs ▁request ▁*/ ▁rc ▁= ▁est _ client _ get _ cacerts ( ectx , ▁& retrieved _ cacerts _ len ); ▁/* ▁* ▁should ▁be ▁successful , ▁and ▁should ▁have ▁obtained ▁a ▁valid ▁length ▁* ▁for ▁the ▁size ▁of ▁the ▁CA ▁certs ▁buffer ▁*/ ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ CACERT _ VERIFICATION ); ▁CU _ ASSERT ( retrieved _ cacerts _ len ▁== ▁0); ▁if ▁( retrieved _ cacerts _ len ) ▁{ ▁/* ▁* ▁Should n ' t ▁be ▁in ▁here , ▁but ▁if ▁we ▁are , ▁malloc ▁and ▁call ▁*/ ▁retrieved _ cacerts ▁= ▁malloc ( retrieved _ cacerts _ len ); ▁rc ▁= ▁est _ client _ copy _ cacerts ( ectx , ▁retrieved _ cacerts ); ▁/* ▁* ▁est ▁should ▁fail ▁indicat ing ▁that ▁there ' s ▁no ▁cert ▁to ▁provide ▁*/ ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NO _ CERTIFICATE ); ▁} ▁/* ▁* ▁output ▁the ▁retrieved ▁ca ▁certs ▁and ▁compare ▁to ▁what ▁they ▁should ▁be ▁*/ ▁if ▁( retrieved _ cacerts ) ▁{ ▁ printf ("\ nR etrieved ▁CA ▁Certs ▁buffer :\ n ▁% s \ n ", ▁retrieved _ cacerts ); ▁ printf (" Retrieve d ▁CA ▁certs ▁buffer ▁length : ▁% d \ n ", ▁retrieved _ cacerts _ len ); ▁} ▁free ( retrieved _ cacerts ); ▁if ▁( ectx ) ▁{ ▁est _ destroy ( ectx ); ▁} ▁if ▁( cacerts ) ▁{ ▁free ( cacerts ); ▁} ▁if ▁( pkey ) ▁{ ▁free ( pkey ); ▁} ▁} ▁/* ▁* ▁This ▁test ▁case ▁tests ▁the ▁CA ▁cert ▁response ▁verification ▁function . ▁It ▁will ▁* ▁verify ▁a ▁CA cert ▁response ▁containing ▁a ▁multiple ▁chain s ▁with ▁multiple ▁certs ▁and ▁* ▁a ▁CRL ▁block . ▁The ▁CRL s ▁should ▁be ▁ignored . ▁*/ ▁static ▁void ▁us 897_ test 17 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁un signed ▁char ▁* pkey ▁= ▁NULL ; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁EST _ ERROR ▁rc ▁= ▁EST _ ERR _ NONE ; ▁E VP _ PKEY ▁* priv _ key ; ▁un signed ▁char ▁* retrieved _ cacerts ▁= ▁NULL ; ▁int ▁retrieved _ cacerts _ len ▁= ▁0; ▁/* ▁* ▁S top ▁the ▁existing ▁server . ▁Need ▁to ▁ensure ▁that ▁the ▁server ▁* ▁is ▁using ▁a ▁specific ▁CA ▁cert ▁chain . ▁*/ ▁st _ stop (); ▁SL EEP ( 2 ); ▁/* ▁* ▁Spi n ▁up ▁a ▁new ▁instance ▁of ▁the ▁EST ▁server ▁* ▁using ▁a ▁CA ▁cert ▁chain ▁that ▁contains ▁just ▁one ▁cert ▁*/ ▁rc ▁= ▁st _ start ( US 897_ SERVER _ PORT , ▁US 897_ SERVER _ CERTKEY , ▁US 897_ SERVER _ CERTKEY , ▁" US 897 ▁test ▁realm ", ▁US 897_ CACERTS _ MULT I _ CHAIN _ CRL S , ▁US 897_ TRUST _ CERTS , ▁" CA / est Example CA . cnf ", ▁0, ▁0, ▁0); ▁CU _ ASSERT ( rc ▁== ▁0); ▁if ▁( rc ) ▁return ; ▁SL EEP (1); ▁/* ▁* ▁ Read ▁in ▁the ▁ startup ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁CU _ ASSERT ( cacerts _ len ▁> ▁0); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁file ▁*/ ▁priv _ key ▁= ▁read _ private _ key ( CLIENT _ UT _ PUBKEY ); ▁if ▁( priv _ key ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁while ▁reading ▁private ▁key ▁file ▁% s \ n ", ▁CLIENT _ UT _ PUBKEY ); ▁return ; ▁} ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁rc ▁= ▁est _ client _ set _ auth ( ectx , ▁"", ▁"", ▁NULL , ▁priv _ key ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁est _ client _ set _ server ( ectx , ▁US 897_ SERVER _ IP , ▁US 897_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁issue ▁the ▁get ▁ca ▁certs ▁request ▁*/ ▁rc ▁= ▁est _ client _ get _ cacerts ( ectx , ▁& retrieved _ cacerts _ len ); ▁/* ▁* ▁should ▁be ▁successful , ▁and ▁should ▁have ▁obtained ▁a ▁valid ▁length ▁* ▁for ▁the ▁size ▁of ▁the ▁CA ▁certs ▁buffer ▁*/ ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( retrieved _ cacerts _ len ▁> ▁0); ▁if ▁( retrieved _ cacerts _ len ) ▁{ ▁/* ▁* ▁Should n ' t ▁be ▁in ▁here , ▁but ▁if ▁we ▁are , ▁malloc ▁and ▁call ▁*/ ▁retrieved _ cacerts ▁= ▁malloc ( retrieved _ cacerts _ len ); ▁rc ▁= ▁est _ client _ copy _ cacerts ( ectx , ▁retrieved _ cacerts ); ▁/* ▁* ▁est ▁should ▁fail ▁indicat ing ▁that ▁there ' s ▁no ▁cert ▁to ▁provide ▁*/ ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁output ▁the ▁retrieved ▁ca ▁certs ▁and ▁compare ▁to ▁what ▁they ▁should ▁be ▁*/ ▁if ▁( retrieved _ cacerts ) ▁{ ▁ printf ("\ nR etrieved ▁CA ▁Certs ▁buffer :\ n ▁% s \ n ", ▁retrieved _ cacerts ); ▁ printf (" Retrieve d ▁CA ▁certs ▁buffer ▁length : ▁% d \ n ", ▁retrieved _ cacerts _ len ); ▁} ▁free ( retrieved _ cacerts ); ▁if ▁( ectx ) ▁{ ▁est _ destroy ( ectx ); ▁} ▁if ▁( cacerts ) ▁{ ▁free ( cacerts ); ▁} ▁if ▁( pkey ) ▁{ ▁free ( pkey ); ▁} ▁} ▁/* ▁* ▁This ▁test ▁case ▁tests ▁the ▁SSL ▁read ▁set ▁timeout ▁API . ▁* ▁The ▁setting ▁of ▁the ▁min , ▁the ▁max , ▁a ▁value ▁in ▁between , ▁and ▁a ▁value ▁* ▁be y ond ▁the ▁max . ▁*/ ▁static ▁void ▁us 897_ test 18 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁un signed ▁char ▁* pkey ▁= ▁NULL ; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁EST _ ERROR ▁rc ▁= ▁EST _ ERR _ NONE ; ▁E VP _ PKEY ▁* priv _ key ; ▁un signed ▁char ▁* retrieved _ cacerts ▁= ▁NULL ; ▁int ▁retrieved _ cacerts _ len ▁= ▁0; ▁/* ▁* ▁ Read ▁in ▁the ▁ startup ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁CU _ ASSERT ( cacerts _ len ▁> ▁0); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁file ▁*/ ▁priv _ key ▁= ▁read _ private _ key ( CLIENT _ UT _ PUBKEY ); ▁if ▁( priv _ key ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁while ▁reading ▁private ▁key ▁file ▁% s \ n ", ▁CLIENT _ UT _ PUBKEY ); ▁return ; ▁} ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁rc ▁= ▁est _ client _ set _ auth ( ectx , ▁"", ▁"", ▁NULL , ▁priv _ key ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁est _ client _ set _ server ( ectx , ▁US 897_ SERVER _ IP , ▁US 897_ SERVER _ PORT , ▁NULL ); ▁rc ▁= ▁est _ client _ set _ read _ timeout ( ectx , ▁EST _ SSL _ READ _ TIMEOUT _ MIN ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ set _ read _ timeout ( ectx , ▁EST _ SSL _ READ _ TIMEOUT _ MAX ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ set _ read _ timeout ( ectx , ▁EST _ SSL _ READ _ TIMEOUT _ MAX +1 ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ INVALID _ PARAMETERS ); ▁rc ▁= ▁est _ client _ set _ read _ timeout ( ectx , ▁2 ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁/* ▁ Now ▁proceed ▁on ▁with ▁a ▁GET ▁/ cacerts ▁to ▁verify ▁that ▁nothing ▁gets ▁ broken ▁*/ ▁/* ▁* ▁issue ▁the ▁get ▁ca ▁certs ▁request ▁*/ ▁rc ▁= ▁est _ client _ get _ cacerts ( ectx , ▁& retrieved _ cacerts _ len ); ▁/* ▁* ▁should ▁be ▁successful , ▁and ▁should ▁have ▁obtained ▁a ▁valid ▁length ▁* ▁for ▁the ▁size ▁of ▁the ▁CA ▁certs ▁buffer ▁*/ ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( retrieved _ cacerts _ len ▁> ▁0); ▁if ▁( retrieved _ cacerts _ len ) ▁{ ▁/* ▁* ▁Should n ' t ▁be ▁in ▁here , ▁but ▁if ▁we ▁are , ▁malloc ▁and ▁call ▁*/ ▁retrieved _ cacerts ▁= ▁malloc ( retrieved _ cacerts _ len ); ▁rc ▁= ▁est _ client _ copy _ cacerts ( ectx , ▁retrieved _ cacerts ); ▁/* ▁* ▁est ▁should ▁fail ▁indicat ing ▁that ▁there ' s ▁no ▁cert ▁to ▁provide ▁*/ ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁output ▁the ▁retrieved ▁ca ▁certs ▁and ▁compare ▁to ▁what ▁they ▁should ▁be ▁*/ ▁if ▁( retrieved _ cacerts ) ▁{ ▁ printf ("\ nR etrieved ▁CA ▁Certs ▁buffer :\ n ▁% s \ n ", ▁retrieved _ cacerts ); ▁ printf (" Retrieve d ▁CA ▁certs ▁buffer ▁length : ▁% d \ n ", ▁retrieved _ cacerts _ len ); ▁} ▁free ( retrieved _ cacerts ); ▁if ▁( ectx ) ▁{ ▁est _ destroy ( ectx ); ▁} ▁if ▁( cacerts ) ▁{ ▁free ( cacerts ); ▁} ▁if ▁( pkey ) ▁{ ▁free ( pkey ); ▁} ▁} ▁/* ▁The ▁main () ▁function ▁for ▁setting ▁up ▁and ▁running ▁the ▁tests . ▁* ▁Returns ▁a ▁CU E _ SUCCESS ▁on ▁successful ▁running , ▁another ▁* ▁ CUnit ▁error ▁code ▁on ▁failure . ▁*/ ▁int ▁us 897_ add _ suite ▁( void ) ▁{ ▁CU _ ErrorCode ▁CU _ error ; ▁# if def ▁HAV E _ C UNIT ▁CU _ pSuite ▁pSuite ▁= ▁NULL ; ▁/* ▁add ▁a ▁suite ▁to ▁the ▁ registry ▁*/ ▁pSuite ▁= ▁CU _ add _ suite (" us 897_ client _ cacerts ", ▁us 897_ init _ suite , ▁us 897_ destroy _ suite ); ▁if ▁( NULL ▁== ▁pSuite ) ▁{ ▁CU _ cleanup _ registry (); ▁return ▁CU _ get _ error (); ▁} ▁/* ▁add ▁the ▁tests ▁to ▁the ▁suite ▁*/ ▁/* ▁NOTE ▁- ▁OR DER ▁IS ▁ IMPORTANT ▁- ▁MUST ▁TEST ▁f read () ▁ AFTER ▁f printf () ▁*/ ▁if ▁( ( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Client ▁Init : ▁local ▁CA , ▁private ▁key ▁" , ▁us 897_ test 1)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Client ▁Init : ▁no ▁local ▁CA ", ▁us 897_ test 2)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Client ▁Init : ▁local ▁CA , ▁explicit ▁CA , ▁private ▁key ", ▁us 897_ test 3)) ▁|| ▁/* ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Client ▁Init : ▁local ▁CA , ▁explicit ▁CA , ▁client ▁CA , ▁private ▁key ", ▁us 897_ test 4)) ▁|| ▁*/ ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Client ▁Init : ▁local ▁CA , ▁userid / password ", ▁us 897_ test 6)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Client ▁Init : ▁local ▁CA , ▁userid / no ▁password ", ▁us 897_ test 7)) ▁|| ▁/* ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Client ▁Init : ▁local ▁CA , ▁no ▁userid / password ", ▁us 897_ test 8)) ▁|| ▁*/ ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Client ▁Set ▁Server : ▁correct ▁parameters ", ▁us 897_ test 9)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Client ▁Set ▁Server : ▁no ▁parameters ", ▁us 897_ test 10)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Client ▁CA ▁Certs : ▁ca _ cert ▁valid ▁parameters ", ▁us 897_ test 11)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Client ▁CA ▁Certs : ▁missing ▁ca _ cert ▁pointer s ", ▁us 897_ test 12)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Client ▁CA ▁Certs : ▁verify ▁chain - simple ▁chain - success ", ▁us 897_ test 1 3)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Client ▁CA ▁Certs : ▁verify ▁chain - mu ltip le ▁certs - success ", ▁us 897_ test 1 4)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Client ▁CA ▁Certs : ▁verify ▁chain - broken ▁chain - fail ", ▁us 897_ test 1 5)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Client ▁CA ▁Certs : ▁verify ▁chain - bad ▁date - fail ", ▁us 897_ test 16)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Client ▁CA ▁Certs : ▁verify ▁chain - mu ltip le ▁chain s - success ", ▁us 897_ test 17)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Client ▁SSL ▁read ▁timeout ▁API ", ▁us 897_ test 18)) ▁ ) ▁{ ▁CU _ error ▁= ▁CU _ get _ error (); ▁ printf ("% d \ n ", ▁CU _ error ); ▁CU _ cleanup _ registry (); ▁ printf ("% s \ n ", ▁CU _ get _ error _ msg ()); ▁return ▁CU _ get _ error (); ▁} ▁return ▁CU E _ SUCCESS ; ▁# endif ▁}