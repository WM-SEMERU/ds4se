▁/* ▁* ▁Utilit y ▁function ▁to ▁set ▁the ▁certificate ▁and ▁private ▁key ▁to ▁use ▁* ▁for ▁a ▁SSL ▁context . ▁* ▁* ▁Returns ▁0 ▁on ▁success ▁*/ ▁int ▁est _ client _ set _ cert _ and _ key ▁( SSL _ CTX ▁* ctx , ▁X 509 ▁* cert , ▁E VP _ PKEY ▁* key ) ▁{ ▁if ▁( SSL _ CTX _ use _ certificate ( ctx , ▁cert ) ▁< = ▁0) ▁{ ▁EST _ LOG _ ERR (" Error ▁setting ▁certificate "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁1; ▁} ▁if ▁( SSL _ CTX _ use _ PrivateKey ( ctx , ▁key ) ▁< = ▁0) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁set ▁private ▁key "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁1; ▁} ▁/* ▁* ▁Verify ▁the ▁key ▁matches ▁the ▁cert ▁*/ ▁if ▁(! SSL _ CTX _ check _ private _ key ( ctx )) ▁{ ▁EST _ LOG _ ERR (" P ri v ate ▁key ▁does ▁not ▁match ▁the ▁certificate ▁public ▁key "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁1; ▁} ▁return ▁0; ▁} ▁/* ▁* ▁Sign ▁an ▁X 509 ▁certificate ▁request ▁using ▁the ▁digest ▁and ▁the ▁key ▁passed . ▁* ▁Returns ▁OpenSSL ▁error ▁code ▁from ▁X 509_ REQ _ sign _ ctx (); ▁*/ ▁static ▁int ▁est _ client _ X 509_ REQ _ sign ▁( X 509_ REQ ▁* x , ▁E VP _ PKEY ▁* pkey , ▁const ▁E VP _ MD ▁* md ) ▁{ ▁int ▁rv ; ▁E VP _ PKEY _ CTX ▁* pkctx ▁= ▁NULL ; ▁E VP _ MD _ CTX ▁ mctx ; ▁E VP _ MD _ CTX _ init (& mctx ); ▁if ▁(! E VP _ Digest Sign Init (& mctx , ▁& pkctx , ▁md , ▁NULL , ▁pkey )) ▁{ ▁return ▁0; ▁} ▁/* ▁* ▁ Encode ▁using ▁DER ▁( ASN . 1) ▁* ▁* ▁We ▁have ▁to ▁set ▁the ▁modified ▁flag ▁on ▁the ▁X 509_ REQ ▁because ▁* ▁OpenSSL ▁keep s ▁a ▁cached ▁copy ▁of ▁the ▁DER ▁encoded ▁data ▁in ▁some ▁* ▁cases . ▁Sett ing ▁this ▁flag ▁tell s ▁OpenSSL ▁to ▁run ▁the ▁ASN ▁* ▁encoding ▁again ▁r ather ▁than ▁using ▁the ▁cached ▁copy . ▁*/ ▁x -> req _ info -> enc . modified ▁= ▁1; ▁rv ▁= ▁X 509_ REQ _ sign _ ctx ( x , ▁& mctx ); ▁E VP _ MD _ CTX _ cleanup (& mctx ); ▁return ▁( rv ); ▁} ▁/* ▁* ▁populate _ x 509_ request ▁will ▁build ▁an ▁x 509 ▁request ▁buffer . ▁It ▁does ▁this ▁by ▁* ▁calls ▁into ▁OpenSSL ▁to ▁insert ▁the ▁fields ▁of ▁the ▁x 509 ▁header . ▁* ▁* ▁ Parameters : ▁* ▁req : ▁pointer ▁to ▁the ▁buffer ▁that ▁is ▁to ▁hold ▁the ▁x 509 ▁request ▁header ▁* ▁pkey : ▁public ▁key ▁to ▁be ▁placed ▁into ▁the ▁x 509 ▁request ▁* ▁cn : ▁Common ▁Name ▁to ▁be ▁placed ▁into ▁the ▁x 509 ▁request ▁* ▁ c p : ▁challenge ▁password ▁to ▁be ▁placed ▁into ▁the ▁x 509 ▁header ▁* ▁* ▁Return ▁value : ▁* ▁EST _ ERR _ NONE ▁if ▁success ▁*/ ▁static ▁EST _ ERROR ▁populate _ x 509_ request ▁( EST _ CTX ▁* ctx , ▁X 509_ REQ ▁* req , ▁E VP _ PKEY ▁* pkey , ▁char ▁* cn , ▁char ▁* c p ) ▁{ ▁X 509_ NAME ▁* subj ; ▁/* ▁set up ▁version ▁number ▁*/ ▁if ▁(! X 509_ REQ _ set _ version ( req , ▁0 L )) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁set ▁X 509 ▁version "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁( EST _ ERR _ X 509_ VER ); ▁} ▁/* ▁* ▁Add ▁Common ▁Name ▁entry ▁*/ ▁ subj ▁= ▁X 509_ REQ _ get _ subject _ name ( req ); ▁if ▁(! X 509_ NAME _ add _ entry _ by _ txt ( subj , ▁" CN ", ▁MB STRING _ ASC , ▁( un signed ▁char *) cn , ▁-1, ▁-1, ▁0) ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁set ▁X 509 ▁common ▁name "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁( EST _ ERR _ X 509_ CN ); ▁} ▁/* ▁* ▁Add ▁ c hallengePassword ▁attribute ▁if ▁required ▁* ▁No ▁need ▁to ▁remove / add ▁attributes ▁here , ▁only ▁the ▁PoP ▁is ▁* ▁part ▁of ▁the ▁simple ▁enroll ▁flow . ▁*/ ▁if ▁( ctx -> csr _ pop _ required ▁|| ▁ctx -> client _ force _ pop ) ▁{ ▁EST _ LOG _ INFO (" Client ▁will ▁include ▁ c hallengePassword ▁in ▁CSR "); ▁if ▁(! X 509_ REQ _ add 1 _ attr _ by _ NID ( req , ▁NID _ pkcs 9 _ c hallengePassword , ▁MB STRING _ ASC , ▁( un signed ▁char *) c p , ▁-1) ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁set ▁X 509 ▁ c hallengePassword ▁attribute "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁( EST _ ERR _ X 509_ ATTR ); ▁} ▁} ▁/* ▁* ▁Set ▁the ▁public ▁key ▁on ▁the ▁request ▁*/ ▁if ▁(! X 509_ REQ _ set _ pub key ( req , ▁pkey )) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁set ▁public ▁key "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁( EST _ ERR _ X 509_ PUBKEY ); ▁} ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁This ▁function ▁will ▁generate ▁a ▁PKCS 10 ▁request . ▁* ▁* ▁ Parameters : ▁* ▁cn : ▁Common ▁Name ▁to ▁put ▁into ▁the ▁certificate . ▁* ▁ c p : ▁TLS ▁unique ▁ID ▁for ▁the ▁SSL ▁session , ▁become s ▁the ▁challenge ▁password ▁* ▁pkey : ▁Private ▁key ▁to ▁use ▁for ▁signing ▁the ▁request . ▁* ▁* ▁Return ▁value : ▁* ▁EST _ ERR _ NONE ▁if ▁success ▁*/ ▁static ▁EST _ ERROR ▁est _ generate _ pkcs 10 ▁( EST _ CTX ▁* ctx , ▁char ▁* cn , ▁char ▁* c p , ▁E VP _ PKEY ▁* pkey , ▁X 509_ REQ ▁** pkcs 10) ▁{ ▁X 509_ REQ ▁* req ▁= ▁NULL ; ▁EST _ ERROR ▁rv ; ▁int ▁ossl _ rv ▁= ▁0; ▁req ▁= ▁X 509_ REQ _ new (); ▁if ▁( req ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁allocate ▁X 509_ REQ "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁rv ▁= ▁populate _ x 509_ request ( ctx , ▁req , ▁pkey , ▁cn , ▁ c p ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁X 509_ REQ _ free ( req ); ▁return ▁( rv ); ▁} ▁/* ▁* ▁Sign ▁the ▁request ▁*/ ▁ossl _ rv ▁= ▁est _ client _ X 509_ REQ _ sign ( req , ▁pkey , ▁ctx -> signing _ digest ); ▁if ▁(! ossl _ rv ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁sign ▁X 509 ▁cert ▁request "); ▁X 509_ REQ _ free ( req ); ▁ossl _ dump _ ssl _ errors (); ▁return ▁( EST _ ERR _ X 509_ SIGN ); ▁} ▁* pkcs 10 ▁= ▁req ; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁This ▁function ▁is ▁a ▁callback ▁used ▁by ▁OpenSSL ' s ▁verify _ cert ▁function . ▁* ▁It ' s ▁called ▁at ▁the ▁end ▁of ▁a ▁cert ▁verification ▁to ▁allow ▁an ▁op port unit y ▁to ▁* ▁ g ather ▁more ▁information ▁regard ing ▁a ▁fail ing ▁cert ▁verification , ▁and ▁to ▁* ▁ possibly ▁change ▁the ▁result ▁of ▁the ▁verification . ▁* ▁* ▁This ▁callback ▁is ▁similar ▁to ▁the ▁ossl ▁routine , ▁but ▁does ▁not ▁alt er ▁* ▁the ▁verification ▁result . ▁*/ ▁static ▁int ▁est _ client _ cacert _ verify _ cb ▁( int ▁ok , ▁X 509_ STORE _ CTX ▁* ctx ) ▁{ ▁int ▁cert _ error ▁= ▁X 509_ STORE _ CTX _ get _ error ( ctx ); ▁X 509 ▁* current _ cert ▁= ▁X 509_ STORE _ CTX _ get _ current _ cert ( ctx ); ▁EST _ LOG _ INFO (" enter ▁function : ▁ok =% d ▁cert _ error =% d ", ▁ok , ▁cert _ error ); ▁if ▁(! ok ) ▁{ ▁if ▁( current _ cert ) ▁{ ▁X 509_ NAME _ print _ ex _ fp ( stdout , ▁X 509_ get _ subject _ name ( current _ cert ) , ▁0, ▁X N _ FLAG _ ONE L INE ); ▁ printf ("\ n "); ▁} ▁EST _ LOG _ INFO ("% s ▁error ▁% d ▁at ▁% d ▁ depth ▁lookup : ▁% s \ n ", ▁X 509_ STORE _ CTX _ get 0 _ parent _ ctx ( ctx ) ▁? ▁" [ CRL ▁path ] " ▁: ▁"", ▁cert _ error , ▁X 509_ STORE _ CTX _ get _ error _ depth ( ctx ) , ▁X 509_ verify _ cert _ error _ string ( cert _ error )); ▁} ▁return ▁( ok ); ▁} ▁/* ▁* ▁This ▁function ▁will ▁remove ▁CRL s ▁from ▁a ▁received ▁ cacert ▁response ▁buffer . ▁* ▁* ▁ Parameters : ▁* ▁ctx : ▁EST ▁Context ▁representing ▁this ▁session ▁* ▁cacerts : ▁pointer ▁to ▁the ▁buffer ▁hold ing ▁the ▁result ing ▁CA ▁certs ▁* ▁cacerts _ len : ▁length ▁of ▁the ▁cacerts ▁buffer ▁* ▁p 7 : ▁pointer ▁to ▁the ▁pkcs 7 ▁buffer ▁that ▁was ▁received ▁* ▁* ▁Return ▁value : ▁* ▁EST _ ERR _ NONE ▁if ▁success ▁*/ ▁static ▁EST _ ERROR ▁est _ client _ remove _ crls ▁( EST _ CTX ▁* ctx , ▁un signed ▁char ▁* cacerts , ▁int ▁* cacerts _ len , ▁PKCS 7 ▁* p 7 ) ▁{ ▁int ▁nid ▁= ▁0; ▁int ▁ crls _ found ▁= ▁0; ▁BIO ▁* b 64_ enc ▁= ▁NULL ; ▁BIO ▁* p 7 bio _ out ▁= ▁NULL ; ▁int ▁new _ cacerts _ len ▁= ▁0; ▁char ▁* new _ cacerts _ buf ▁= ▁NULL ; ▁int ▁count ▁= ▁0; ▁nid = OBJ _ obj 2 nid ( p 7-> type ); ▁switch ▁( nid ) ▁{ ▁case ▁NID _ pkcs 7_ signed : ▁if ▁( p 7-> d . sign -> crl ) ▁{ ▁sk _ X 509_ CRL _ pop _ free ( p 7-> d . sign -> crl , ▁X 509_ CRL _ free ); ▁p 7-> d . sign -> crl ▁= ▁NULL ; ▁ crls _ found ▁= ▁1; ▁} ▁break ; ▁case ▁NID _ pkcs 7_ signed And Enveloped : ▁if ▁( p 7-> d . signed _ and _ e nveloped -> crl ) ▁{ ▁sk _ X 509_ CRL _ pop _ free ( p 7-> d . signed _ and _ e nveloped -> crl , ▁X 509_ CRL _ free ); ▁p 7-> d . sign -> crl ▁= ▁NULL ; ▁ crls _ found ▁= ▁1; ▁} ▁break ; ▁default : ▁EST _ LOG _ ERR (" I nvalid ▁NID ▁value ▁on ▁PKCS 7 ▁structure "); ▁return ▁( EST _ ERR _ CACERT _ VERIFICATION ); ▁break ; ▁} ▁/* ▁* ▁If ▁CRL s ▁we re ▁removed , ▁then ▁the ▁original ▁PKCS 7 ▁buffer ▁needs ▁to ▁be ▁* ▁updated . ▁This ▁will ▁al way s ▁be ▁base 64 ▁encoded . ▁* ▁- ▁A llocate ▁the ▁BIO s , ▁* ▁- ▁ Write ▁the ▁PKCS 7 ▁struct ▁back ▁into ▁PEM ▁format , ▁* ▁- ▁Get ▁the ▁pointer ▁and ▁length ▁to ▁the ▁new ▁base 64 ▁PEM ▁encoded ▁buffer , ▁* ▁- ▁and ▁then ▁copy ▁it ▁into ▁the ▁original ▁buffer ▁that ▁was ▁passed ▁in . ▁* ▁S ince ▁the ▁CRL s ▁are ▁being ▁removed , ▁the ▁new ▁buffer ▁will ▁al way s ▁be ▁short er ▁* ▁and ▁will ▁fit ▁into ▁the ▁original ▁buffer . ▁*/ ▁if ▁( crls _ found ) ▁{ ▁EST _ LOG _ INFO (" CRL ( s ) ▁attached ▁with ▁the ▁CA ▁Certificates . ▁Re m ov ing ▁CRL ( s )"); ▁b 64_ enc ▁= ▁BIO _ new ( BIO _ f _ base 64 ()); ▁if ▁( b 64_ enc ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" BIO _ new ▁failed "); ▁ossl _ dump _ ssl _ errors (); ▁return ( EST _ ERR _ MALLOC ); ▁} ▁p 7 bio _ out ▁= ▁BIO _ new ( BIO _ s _ mem ()); ▁if ▁( p 7 bio _ out ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁access ▁the ▁CA ▁cert ▁buffer "); ▁ossl _ dump _ ssl _ errors (); ▁return ( EST _ ERR _ MALLOC ); ▁} ▁p 7 bio _ out ▁= ▁BIO _ push ( b 64_ enc , ▁p 7 bio _ out ); ▁mem zero _ s ( cacerts , ▁* cacerts _ len ); ▁count ▁= ▁i 2 d _ PKCS 7_ bio ( p 7 bio _ out , ▁p 7 ); ▁if ▁( count ▁== ▁0) ▁{ ▁EST _ LOG _ ERR (" PEM _ write _ bio _ PKCS 7 ▁failed "); ▁ossl _ dump _ ssl _ errors (); ▁BIO _ free _ all ( p 7 bio _ out ); ▁return ▁( EST _ ERR _ CACERT _ VERIFICATION ); ▁} ▁( void ) BIO _ flu sh ( p 7 bio _ out ); ▁/* ▁* ▁BIO _ get _ mem _ data ▁just ▁return s ▁the ▁pointer ▁and ▁length ▁to ▁the ▁data ▁* ▁contain ed ▁in ▁the ▁mem ▁BIO . ▁No th ing ▁is ▁allocated ▁and ▁passed ▁back ▁*/ ▁new _ cacerts _ len ▁= ▁( int ) ▁BIO _ get _ mem _ data ( p 7 bio _ out , ▁( char **)& new _ cacerts _ buf ); ▁if ▁( new _ cacerts _ len ▁< = ▁0) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁copy ▁PKCS 7 ▁data "); ▁ossl _ dump _ ssl _ errors (); ▁BIO _ free _ all ( p 7 bio _ out ); ▁return ▁( EST _ ERR _ CACERT _ VERIFICATION ); ▁} ▁/* ▁* ▁copy ▁the ▁new ▁buffer ▁back ▁into ▁the ▁old ▁buffer ▁*/ ▁memcpy _ s ( cacerts , ▁* cacerts _ len , ▁new _ cacerts _ buf , ▁new _ cacerts _ len ); ▁* cacerts _ len ▁= ▁new _ cacerts _ len ; ▁} ▁BIO _ free _ all ( p 7 bio _ out ); ▁return ▁EST _ ERR _ NONE ; ▁} ▁/* ▁* ▁This ▁function ▁will ▁decode ▁the ▁passed ▁base 64 ▁encoded ▁buffer ▁and ▁return ▁the ▁* ▁decoded ▁cacerts . ▁If ▁return ing ▁EST _ ERR _ NONE , ▁caller ▁is ▁responsible ▁for ▁* ▁free ing ▁the ▁cacerts _ decoded ▁buffer ▁*/ ▁static ▁EST _ ERROR ▁b 64_ decode _ cacerts ▁( un signed ▁char ▁* cacerts , ▁int ▁* cacerts _ len , ▁un signed ▁char ▁** cacerts _ decoded , ▁int ▁* cacerts _ decoded _ len ) ▁{ ▁BIO ▁* in ▁= ▁NULL ; ▁BIO ▁* b 64 ▁= ▁NULL ; ▁un signed ▁char ▁* decoded _ buf ; ▁int ▁decoded _ buf _ len ; ▁* cacerts _ decoded ▁= ▁NULL ; ▁* cacerts _ decoded _ len ▁= ▁0; ▁b 64 ▁= ▁BIO _ new ( BIO _ f _ base 64 ()); ▁if ▁( b 64 ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" BIO _ new ▁failed "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁/* ▁* ▁ De co d ing ▁will ▁al way s ▁take ▁up ▁ less ▁than ▁the ▁original ▁buffer . ▁*/ ▁in ▁= ▁BIO _ new _ mem _ buf ( cacerts , ▁* cacerts _ len ); ▁if ▁( in ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁access ▁the ▁CA ▁cert ▁buffer "); ▁ossl _ dump _ ssl _ errors (); ▁BIO _ free _ all ( b 64 ); ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁in ▁= ▁BIO _ push ( b 64, ▁in ); ▁decoded _ buf ▁= ▁malloc (* cacerts _ len ); ▁if ▁( decoded _ buf ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁allocate ▁CA ▁cert ▁buffer ▁for ▁decode "); ▁BIO _ free _ all ( in ); ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁decoded _ buf _ len ▁= ▁BIO _ read ( in , ▁decoded _ buf , ▁* cacerts _ len ); ▁* cacerts _ decoded ▁= ▁decoded _ buf ; ▁* cacerts _ decoded _ len ▁= ▁decoded _ buf _ len ; ▁BIO _ free _ all ( in ); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁If ▁return ing ▁EST _ ERR _ NONE , ▁caller ▁is ▁responsible ▁for ▁free ing ▁the ▁PKCS 7 ▁struct ▁*/ ▁static ▁EST _ ERROR ▁create _ PKCS 7 ▁( un signed ▁char ▁* cacerts _ decoded , ▁int ▁cacerts _ decoded _ len , ▁PKCS 7 ▁** pkcs 7 out ) ▁{ ▁BIO ▁* p 7 bio _ in ▁= ▁NULL ; ▁PKCS 7 ▁* pkcs 7 ▁= ▁NULL ; ▁/* ▁* ▁ Now ▁get ▁the ▁PKCS 7 ▁formatt ed ▁buffer ▁of ▁certificates ▁read ▁into ▁a ▁stack ▁of ▁* ▁X 509 ▁certs ▁*/ ▁p 7 bio _ in ▁= ▁BIO _ new _ mem _ buf ( cacerts _ decoded , ▁cacerts _ decoded _ len ); ▁if ▁( p 7 bio _ in ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁access ▁the ▁PKCS 7 ▁buffer "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁pkcs 7 ▁= ▁d 2 i _ PKCS 7_ bio ( p 7 bio _ in , NULL ); ▁if ▁( pkcs 7 ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁read ▁in ▁PKCS 7 ▁based ▁certificate ▁buffer "); ▁ossl _ dump _ ssl _ errors (); ▁BIO _ free _ all ( p 7 bio _ in ); ▁return ▁( EST _ ERR _ LO AD _ CACERTS ); ▁} ▁BIO _ free _ all ( p 7 bio _ in ); ▁* pkcs 7 out ▁= ▁pkcs 7 ; ▁return ▁EST _ ERR _ NONE ; ▁} ▁/* ▁* ▁This ▁function ▁is ▁invoked ▁when ▁the ▁CACerts ▁response ▁has ▁been ▁received . ▁The ▁* ▁cert ▁chain ▁is ▁ built ▁into ▁a ▁cert ▁store ▁and ▁then ▁ each ▁certificate ▁is ▁verified ▁* ▁against ▁this ▁store ▁e s sent i ally ▁verifying ▁the ▁cert ▁chain ▁against ▁itself ▁to ▁* ▁ensure ▁that ▁ each ▁inter mediate ▁can ▁be ▁verified ▁back ▁to ▁one ▁of ▁the ▁included ▁* ▁roo t ▁certs ▁in ▁the ▁CACerts ▁response . ▁If ▁CRL s ▁are ▁attached ▁these ▁will ▁be ▁* ▁removed ▁and ▁a ▁new ▁PKCS 7 ▁buffer ▁is ▁created . ▁* ▁* ▁ Parameters : ▁* ▁ctx : ▁EST ▁Context ▁representing ▁this ▁session ▁* ▁cacerts : ▁pointer ▁to ▁the ▁buffer ▁hold ing ▁the ▁received ▁CA ▁certs ▁* ▁cacerts _ len : ▁length ▁of ▁the ▁cacerts ▁buffer ▁* ▁* ▁Return ▁value : ▁* ▁EST _ ERR _ NONE ▁if ▁success ▁*/ ▁static ▁EST _ ERROR ▁verify _ cacert _ resp ▁( EST _ CTX ▁* ctx , ▁un signed ▁char ▁* cacerts , ▁int ▁* cacerts _ len ) ▁{ ▁int ▁rv ▁= ▁0; ▁int ▁failed ▁= ▁0; ▁EST _ ERROR ▁est _ rc ▁= ▁EST _ ERR _ NONE ; ▁X 509_ STORE ▁* trusted _ cacerts _ store ▁= ▁NULL ; ▁STA CK _ OF ( X 509 ) ▁* stack ▁= ▁NULL ; ▁X 509 ▁* current _ cert ▁= ▁NULL ; ▁int ▁i ; ▁un signed ▁char ▁* cacerts _ decoded ▁= ▁NULL ; ▁int ▁cacerts _ decoded _ len ▁= ▁0; ▁X 509_ STORE _ CTX ▁* store _ ctx ▁= ▁NULL ; ▁PKCS 7 ▁* pkcs 7 ▁= ▁NULL ; ▁if ▁( ctx ▁== ▁NULL ▁|| ▁cacerts ▁== ▁NULL ▁|| ▁cacerts _ len ▁== ▁0) ▁{ ▁EST _ LOG _ ERR (" I nvalid ▁parameter . ▁ctx ▁= ▁% x ▁cacerts ▁= ▁% x ▁cacerts _ len ▁= ▁% x ", ▁ctx , ▁cacerts , ▁cacerts _ len ); ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁/* ▁* ▁- ▁Base 64 ▁decode ▁the ▁incoming ▁ca ▁certs ▁buffer , ▁* ▁- ▁convert ▁to ▁a ▁PKCS 7 ▁structure , ▁* ▁- ▁extract ▁out ▁the ▁stack ▁of ▁certs . ▁*/ ▁rv ▁= ▁b 64_ decode _ cacerts ( cacerts , ▁cacerts _ len , ▁& cacerts _ decoded , ▁& cacerts _ decoded _ len ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" Base 64 ▁decode ▁of ▁received ▁CA ▁certs ▁failed "); ▁return ▁( rv ); ▁} ▁rv ▁= ▁create _ PKCS 7 ( cacerts _ decoded , ▁cacerts _ decoded _ len , ▁& pkcs 7 ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁build ▁PKCS 7 ▁structure ▁from ▁re ce ie vd ▁buffer "); ▁free ( cacerts _ decoded ); ▁return ▁( rv ); ▁} ▁rv ▁= ▁PKCS 7_ to _ stack ( pkcs 7, ▁& stack ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" C ould ▁not ▁obtain ▁stack ▁of ▁ca ▁certs ▁from ▁PKCS 7 ▁structure "); ▁free ( cacerts _ decoded ); ▁PKCS 7_ free ( pkcs 7 ); ▁return ▁( rv ); ▁} ▁/* ▁* ▁At ▁this ▁point ▁we ▁have ▁the ▁stack ▁of ▁X 509 ▁certs ▁that ▁make ▁up ▁* ▁the ▁CA ▁certs ▁response ▁sent ▁from ▁the ▁EST ▁server . ▁* ▁- ▁Build ▁a ▁store ▁of ▁" trusted " ▁certs ▁to ▁use ▁in ▁the ▁verify ▁* ▁- ▁walk ▁through ▁ each ▁cert ▁and ▁verify ▁it ▁* ▁- ▁Build ▁a ▁store ▁context ▁from ▁the ▁store ▁and ▁the ▁cert ▁to ▁be ▁verified ▁and ▁* ▁call ▁the ▁verify ▁function ▁*/ ▁trusted _ cacerts _ store ▁= ▁X 509_ STORE _ new (); ▁if ▁( trusted _ cacerts _ store ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁allocate ▁cert ▁store "); ▁ossl _ dump _ ssl _ errors (); ▁free ( cacerts _ decoded ); ▁PKCS 7_ free ( pkcs 7 ); ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁X 509_ STORE _ set _ verify _ cb ( trusted _ cacerts _ store , ▁est _ client _ cacert _ verify _ cb ); ▁for ▁( i =0; ▁i < sk _ X 509_ num ( stack ); ▁i ++) ▁{ ▁current _ cert ▁= ▁sk _ X 509_ value ( stack , ▁i ); ▁/* ▁* ▁I s ▁it ▁self ▁signed ? ▁If ▁so , ▁add ▁it ▁in ▁the ▁trusted ▁store , ▁otherwise , ▁* ▁add ▁it ▁to ▁the ▁untrusted ▁store . ▁*/ ▁rv ▁= ▁X 509_ check _ issued ( current _ cert , ▁current _ cert ); ▁if ▁( rv ▁== ▁X 509_ V _ OK ) ▁{ ▁EST _ LOG _ INFO (" Add ing ▁cert ▁to ▁trusted ▁store ▁(% s )", ▁current _ cert -> name ); ▁X 509_ STORE _ add _ cert ( trusted _ cacerts _ store , ▁current _ cert ); ▁} ▁} ▁/* ▁* ▁set ▁up ▁a ▁X 509 ▁Store ▁Context ▁*/ ▁store _ ctx ▁= ▁X 509_ STORE _ CTX _ new (); ▁if ▁( store _ ctx ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁allocate ▁a ▁new ▁store ▁context "); ▁ossl _ dump _ ssl _ errors (); ▁free ( cacerts _ decoded ); ▁PKCS 7_ free ( pkcs 7 ); ▁X 509_ STORE _ free ( trusted _ cacerts _ store ); ▁return ( EST _ ERR _ MALLOC ); ▁} ▁for ▁( i =0; ▁i < sk _ X 509_ num ( stack ); ▁i ++) ▁{ ▁if ▁(! X 509_ STORE _ CTX _ init ( store _ ctx , ▁trusted _ cacerts _ store , ▁NULL , ▁stack )) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁initialize ▁the ▁new ▁store ▁context "); ▁ossl _ dump _ ssl _ errors (); ▁free ( cacerts _ decoded ); ▁PKCS 7_ free ( pkcs 7 ); ▁X 509_ STORE _ free ( trusted _ cacerts _ store ); ▁X 509_ STORE _ CTX _ free ( store _ ctx ); ▁return ▁( ▁EST _ ERR _ MALLOC ); ▁} ▁current _ cert ▁= ▁sk _ X 509_ value ( stack , ▁i ); ▁EST _ LOG _ INFO (" Add ing ▁cert ▁to ▁store ▁(% s )", ▁current _ cert -> name ); ▁X 509_ STORE _ CTX _ set _ cert ( store _ ctx , ▁current _ cert ); ▁rv ▁= ▁X 509_ verify _ cert ( store _ ctx ); ▁if ▁(! rv ) ▁{ ▁/* ▁* ▁this ▁cert ▁failed ▁verification . ▁Log ▁this ▁and ▁continue ▁on ▁*/ ▁EST _ LOG _ WARN (" Certificate ▁failed ▁verification ▁(% s )", ▁current _ cert -> name ); ▁failed ▁= ▁1; ▁} ▁} ▁/* ▁* ▁ Final ly , ▁remove ▁any ▁CRL s ▁that ▁m ight ▁be ▁attached . ▁*/ ▁est _ rc ▁= ▁est _ client _ remove _ crls ( ctx , ▁cacerts , ▁cacerts _ len , ▁pkcs 7 ); ▁free ( cacerts _ decoded ); ▁X 509_ STORE _ free ( trusted _ cacerts _ store ); ▁X 509_ STORE _ CTX _ free ( store _ ctx ); ▁PKCS 7_ free ( pkcs 7 ); ▁if ▁( fail ed ) ▁{ ▁return ▁( EST _ ERR _ CACERT _ VERIFICATION ); ▁} ▁else ▁{ ▁return ▁est _ rc ; ▁} ▁} ▁/* ▁* ▁This ▁function ▁is ▁registered ▁with ▁SSL ▁to ▁be ▁called ▁dur ing ▁the ▁verification ▁* ▁of ▁ each ▁certificate ▁in ▁the ▁server ' s ▁identity ▁cert ▁chain . ▁The ▁main ▁purpose ▁* ▁is ▁to ▁look ▁for ▁the ▁case ▁where ▁the ▁cert ▁could ▁not ▁be ▁verified . ▁In ▁this ▁case , ▁* ▁if ▁the ▁EST ▁client ▁app ▁has ▁registered ▁a ▁callback ▁to ▁receive ▁these ▁untrusted ▁* ▁certs , ▁it ▁will ▁be ▁forward ed ▁up ▁to ▁the ▁EST ▁client ▁application . ▁* ▁* ▁ Parameters : ▁* ▁ok : ▁The ▁status ▁of ▁this ▁certificate ▁from ▁the ▁SSL ▁verify ▁code . ▁* ▁x _ ctx : ▁P tr ▁to ▁the ▁X 509 ▁certificate ▁store ▁structure ▁* ▁* ▁Return ▁value : ▁* ▁int : ▁The ▁potential ly ▁modified ▁status ▁after ▁processing ▁this ▁certificate . ▁This ▁can e ▁* ▁be ▁modified ▁by ▁the ▁E T ▁client ▁application ▁if ▁they ' ve ▁provided ▁a ▁callback ▁* ▁allowing ▁it ▁to ▁be ▁processed , ▁or ▁modified ▁here ▁in ▁this ▁callback . ▁*/ ▁static ▁int ▁cert _ verify _ cb ▁( int ▁ok , ▁X 509_ STORE _ CTX ▁* x _ ctx ) ▁{ ▁SSL ▁* ssl ; ▁EST _ CTX ▁* e _ ctx ; ▁int ▁approve ; ▁int ▁cert _ error ▁= ▁0; ▁X 509 ▁* current _ cert ▁= ▁NULL ; ▁approve ▁= ▁ok ; ▁if ▁( x _ ctx ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" I nvalid ▁X 509 ▁context ▁pointer "); ▁return ▁( approve ); ▁} ▁cert _ error ▁= ▁X 509_ STORE _ CTX _ get _ error ( x _ ctx ); ▁current _ cert ▁= ▁X 509_ STORE _ CTX _ get _ current _ cert ( x _ ctx ); ▁EST _ LOG _ INFO (" enter ing : ▁Cert ▁passed ▁up ▁from ▁OpenSSL . ▁error ▁= ▁% d ▁(% s ) ▁\ n ", ▁cert _ error , ▁X 509_ verify _ cert _ error _ string ( cert _ error )); ▁/* ▁* ▁Retrieve ▁the ▁pointer ▁to ▁the ▁SSL ▁structure ▁for ▁this ▁connection ▁and ▁then ▁* ▁the ▁application ▁specific ▁data ▁stored ▁into ▁the ▁SSL ▁object . ▁This ▁will ▁be ▁* ▁our ▁EST ▁ctx ▁for ▁this ▁EST ▁session . ▁*/ ▁if ▁( e _ ctx _ ssl _ exdata _ index ▁== ▁SSL _ E X DATA _ IN DE X _ INVALID ) ▁{ ▁EST _ LOG _ ERR (" I nvalid ▁SSL ▁ exdata ▁index ▁for ▁EST ▁context ▁value "); ▁return ▁( approve ); ▁} ▁ssl ▁= ▁X 509_ STORE _ CTX _ get _ ex _ data ( x _ ctx , ▁SSL _ get _ ex _ data _ X 509_ STORE _ CTX _ id x ()); ▁if ▁(! ssl ) ▁{ ▁EST _ LOG _ ERR (" NULL ▁pointer ▁retrieved ▁for ▁SSL ▁session ▁pointer ▁from ▁X 509 ▁ctx ▁ex _ data "); ▁return ▁( approve ); ▁} ▁e _ ctx ▁= ▁SSL _ get _ ex _ data ( ssl , ▁e _ ctx _ ssl _ exdata _ index ); ▁if ▁(! e _ ctx ) ▁{ ▁EST _ LOG _ ERR (" NULL ▁pointer ▁retrieved ▁for ▁EST ▁context ▁from ▁SSL ▁ex _ data "); ▁return ▁( approve ); ▁} ▁if ▁(! ok ) ▁{ ▁switch ▁( cert _ error ) ▁{ ▁/* ▁* ▁ Case s ▁where ▁we ▁not ify ▁the ▁client ▁application : ▁* ▁* ▁ CERT _ UNTRUSTED ▁is ▁what ▁is ▁expected , ▁but ▁not ▁what ▁we ▁get ▁in ▁the ▁* ▁case ▁where ▁we ▁cannot ▁verify ▁our ▁server ' s ▁cert . ▁* ▁ SELF _ SIGNED _ CERT _ IN _ CHAIN ▁is ▁what ▁currently ▁results ▁with ▁our ▁server ▁* ▁when ▁we ▁cannot ▁verify ▁its ▁cert . ▁* ▁U NABLE _ TO _ GET _ CRL ▁is ▁passed ▁up ▁to ▁make ▁sure ▁the ▁application ▁know s ▁* ▁that ▁al th ou g h ▁*/ ▁case ▁X 509_ V _ ERR _ CERT _ UNTRUSTED : ▁case ▁X 509_ V _ ERR _ SELF _ SIGNED _ CERT _ IN _ CHAIN : ▁case ▁X 509_ V _ ERR _ U NABLE _ TO _ GET _ CRL : ▁/* ▁* ▁If ▁the ▁application ▁provided ▁a ▁callback ▁then ▁go ▁a head ▁and ▁pass ▁* ▁this ▁cert ▁store ▁up . ▁If ▁not , ▁then ▁log ▁a ▁warning ▁and ▁return ▁what ▁* ▁SSL ▁ g a ve ▁us ▁for ▁a ▁status . ▁*/ ▁if ▁( e _ ctx -> manual _ cert _ verify _ cb ) ▁{ ▁EST _ LOG _ INFO (" EST ▁client ▁application ▁server ▁cert ▁verify ▁function ▁is ▁registered \ n "); ▁approve ▁= ▁e _ ctx -> manual _ cert _ verify _ cb ( current _ cert , ▁cert _ error ); ▁} ▁else ▁{ ▁EST _ LOG _ INFO (" NO ▁EST ▁client ▁application ▁server ▁cert ▁verify ▁function ▁registered \ n "); ▁if ▁( cert _ error ▁== ▁X 509_ V _ ERR _ U NABLE _ TO _ GET _ CRL ) ▁{ ▁/* ▁* ▁We ' ve ▁enabled ▁CRL ▁checking ▁in ▁the ▁TLS ▁stack . ▁If ▁the ▁* ▁application ▁has n ' t ▁loaded ▁a ▁CRL , ▁then ▁this ▁verify ▁error ▁* ▁can ▁occur . ▁The ▁peer ' s ▁cert ▁is ▁valid , ▁but ▁we ▁can ' t ▁* ▁confirm ▁if ▁it ▁was ▁revoked . ▁The ▁app ▁has ▁not ▁provided ▁* ▁a ▁way ▁for ▁us ▁to ▁not ify ▁on ▁this , ▁so ▁our ▁only ▁option ▁is ▁* ▁to ▁log ▁a ▁warning ▁and ▁proceed ▁on . ▁*/ ▁EST _ LOG _ WARN (" No ▁CRL ▁loaded , ▁TLS ▁peer ▁will ▁be ▁allowed . "); ▁approve ▁= ▁1; ▁} ▁} ▁break ; ▁/* ▁The ▁remain der ▁of ▁these ▁will ▁result ▁in ▁the ▁ok ▁state ▁remain ing ▁un change d ▁* ▁and ▁a ▁EST ▁log ▁warning ▁message ▁being ▁logged . ▁*/ ▁case ▁X 509_ V _ ERR _ NO _ EXPLICIT _ P OLIC Y : ▁case ▁X 509_ V _ ERR _ CERT _ HAS _ EXPIRED : ▁/* ▁since ▁we ▁are ▁just ▁checking ▁the ▁certificates , ▁it ▁is ▁* ▁ok ▁if ▁they ▁are ▁self ▁signed . ▁ But ▁we ▁should ▁st ill ▁warn ▁* ▁the ▁user . ▁*/ ▁case ▁X 509_ V _ ERR _ DEPTH _ ZE RO _ SELF _ SIGNED _ CERT : ▁/* ▁ Continue ▁after ▁extension ▁error s ▁too ▁*/ ▁case ▁X 509_ V _ ERR _ INVALID _ CA : ▁case ▁X 509_ V _ ERR _ INVALID _ NON _ CA : ▁case ▁X 509_ V _ ERR _ P ATH _ LEN G TH _ EXCEED ED : ▁case ▁X 509_ V _ ERR _ INVALID _ PURPOSE : ▁case ▁X 509_ V _ ERR _ CRL _ HAS _ EXPIRED : ▁case ▁X 509_ V _ ERR _ CRL _ NOT _ YET _ VALID : ▁case ▁X 509_ V _ ERR _ UN HANDLE D _ CRI TICA L _ EXTEN S ION : ▁case ▁X 509_ V _ ERR _ CERT _ REVOKED : ▁default : ▁EST _ LOG _ WARN (" Certificate ▁verify ▁failed ▁( reason ▁= ▁% d ) ▁(% s )", ▁cert _ error , ▁X 509_ verify _ cert _ error _ string ( cert _ error )); ▁break ; ▁} ▁} ▁return ▁( approve ); ▁} ▁/* ▁* ▁This ▁function ▁is ▁used ▁to ▁create ▁and ▁initialize ▁an ▁* ▁SSL _ CTX ▁that ▁will ▁be ▁used ▁for ▁client ▁and ▁proxy ▁EST ▁operations . ▁* ▁The ▁SSL _ CTX ▁is ▁stored ▁on ▁the ▁EST _ CTX . ▁* ▁* ▁ Parameters : ▁* ▁ctx : ▁EST ▁Context ▁* ▁* ▁Return ▁value : ▁* ▁EST _ ERROR ▁* ▁EST _ ERR _ NONE ▁if ▁success ▁*/ ▁static ▁EST _ ERROR ▁est _ client _ init _ ssl _ ctx ▁( EST _ CTX ▁* ctx ) ▁{ ▁SSL _ CTX ▁* s _ ctx ; ▁X 509_ VERIFY _ PARAM ▁* vpm ▁= ▁NULL ; ▁EST _ ERROR ▁rv ▁= ▁EST _ ERR _ NONE ; ▁est _ log _ version (); ▁if ▁( ctx ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" I nvalid ▁context ▁pointer "); ▁return ▁EST _ ERR _ NO _ CTX ; ▁} ▁if ▁( ( s _ ctx ▁= ▁SSL _ CTX _ new ( SSLv 2 3 _ client _ method ())) ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁obtain ▁a ▁new ▁SSL ▁Context \ n "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁EST _ ERR _ SSL _ CTX _ NEW ; ▁} ▁/* ▁* ▁Only ▁TLS ▁1.1 ▁or ▁above ▁can ▁be ▁used ▁for ▁EST ▁*/ ▁SSL _ CTX _ set _ option s ( s _ ctx , ▁SSL _ OP _ NO _ SSLv 2 ▁| ▁SSL _ OP _ NO _ SSLv 3 ▁| ▁SSL _ OP _ NO _ TLS v 1); ▁/* ▁* ▁limit ▁the ▁cipher ▁suites ▁that ▁are ▁offer ed ▁*/ ▁if ▁(! SSL _ CTX _ set _ cipher _ list ( s _ ctx , ▁EST _ C IP HER _ LIST )) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁set ▁SSL ▁cipher ▁suites \ n "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁EST _ ERR _ SSL _ C IP HER _ LIST ; ▁} ▁/* ▁* ▁Make ▁sure ▁we ' re ▁verifying ▁the ▁server ▁*/ ▁SSL _ CTX _ set _ verify ( s _ ctx , ▁SSL _ VERIFY _ PEER | SSL _ VERIFY _ FAIL _ IF _ NO _ PEER _ CERT , ▁cert _ verify _ cb ); ▁/* ▁* ▁le verage ▁the ▁cert ▁store ▁we ▁already ▁created ▁from ▁the ▁* ▁trusted ▁CA ▁chain ▁provided ▁by ▁the ▁application . ▁* ▁* ▁In ▁e i ther ▁case , ▁the ▁SSL ▁stack ▁will ▁ clean ▁up ▁the ▁cert ▁store ▁dur ing ▁the ▁* ▁SSL _ CTX _ free (), ▁so ▁let ' s ▁remove ▁our ▁reference ▁to ▁it ▁so ▁we ▁don ' t ▁try ▁to ▁* ▁ clean ▁it ▁up ▁ourselves ▁later ▁*/ ▁SSL _ CTX _ set _ cert _ store ( s _ ctx , ▁ctx -> trusted _ certs _ store ); ▁ctx -> trusted _ certs _ store ▁= ▁NULL ; ▁/* ▁* ▁Set ▁up ▁X 509 ▁params ▁and ▁assign ▁them ▁to ▁the ▁SSL ▁ctx ▁* ▁- ▁E nable ▁CRL ▁checks ▁* ▁- ▁ Max ▁# ▁of ▁untrusted ▁CA ▁certs ▁that ▁can ▁exist ▁in ▁a ▁chain ▁* ▁- ▁ensure ▁that ▁the ▁cert ▁is ▁being ▁used ▁as ▁intended , ▁if ▁* ▁it ▁contains ▁the ▁X 509 ▁Key Usage ▁extension ▁*/ ▁ vpm ▁= ▁X 509_ VERIFY _ PARAM _ new (); ▁if ▁( vpm ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁allocate ▁a ▁verify ▁parameter ▁structure "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁/* ▁E nable ▁CRL ▁checks ▁*/ ▁if ▁( ctx -> enable _ crl ) ▁{ ▁X 509_ VERIFY _ PARAM _ set _ flags ( vpm , ▁X 509_ V _ FLAG _ CRL _ CHECK ▁| ▁X 509_ V _ FLAG _ CRL _ CHECK _ ALL ); ▁} ▁X 509_ VERIFY _ PARAM _ set _ flags ( vpm , ▁X 509_ V _ FLAG _ CRL _ CHECK ▁| ▁X 509_ V _ FLAG _ CRL _ CHECK _ ALL ); ▁X 509_ VERIFY _ PARAM _ set _ depth ( vpm , ▁EST _ TLS _ VERIFY _ DEPTH ); ▁X 509_ VERIFY _ PARAM _ set _ purpose ( vpm , ▁X 509_ PURPOSE _ SSL _ SERVER ); ▁SSL _ CTX _ set 1 _ param ( s _ ctx , ▁ vpm ); ▁X 509_ VERIFY _ PARAM _ free ( vpm ); ▁/* ▁* ▁ Save ▁the ▁reference ▁to ▁the ▁SSL ▁session ▁* ▁This ▁will ▁be ▁used ▁later ▁when ▁match ing ▁the ▁EST _ CTX ▁to ▁the ▁SSL ▁context ▁* ▁in ▁est _ ssl _ info _ cb (). ▁*/ ▁ctx -> ssl _ ctx ▁= ▁ s _ ctx ; ▁if ▁( e _ ctx _ ssl _ exdata _ index ▁== ▁SSL _ E X DATA _ IN DE X _ INVALID ) ▁{ ▁e _ ctx _ ssl _ exdata _ index ▁= ▁SSL _ get _ ex _ new _ index (0, ▁" EST ▁Context ", ▁NULL , ▁NULL , ▁NULL ); ▁} ▁/* ▁* ▁This ▁last ▁config ▁setting ▁is ▁not ▁ctx ▁based , ▁but ▁instead , ▁global ▁to ▁the ▁* ▁entire ▁ lib crypto ▁library . ▁Need ▁to ▁ensure ▁that ▁CSR ▁string ▁attributes ▁* ▁are ▁added ▁in ▁ASCII ▁print able ▁format . ▁*/ ▁ASN 1 _ STRING _ set _ default _ m a sk ( B _ ASN 1 _ PRINT AB LE ); ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁function ▁calculate s ▁the ▁digest ▁value ▁to ▁be ▁* ▁used ▁in ▁HTTP ▁requests ▁when ▁the ▁server ▁has ▁asked ▁* ▁the ▁client ▁to ▁use ▁HTTP ▁digest ▁authentication . ▁* ▁It ▁uses ▁the ▁token s ▁that ▁we re ▁parsed ▁from ▁the ▁HTTP ▁* ▁server ▁response ▁earlier ▁to ▁calculate ▁the ▁digest . ▁*/ ▁static ▁un signed ▁char ▁* est _ client _ generate _ auth _ digest ▁( EST _ CTX ▁* ctx , ▁char ▁* uri , ▁char ▁* user , ▁char ▁* pwd ) ▁{ ▁E VP _ MD _ CTX ▁* mdctx ; ▁const ▁E VP _ MD ▁* md ▁= ▁E VP _ md 5 (); ▁u int 8 _ t ▁ha 1 [ E VP _ MAX _ MD _ SIZE ] ; ▁un signed ▁int ▁ha 1 _ len ; ▁char ▁ha 1 _ str [ EST _ MAX _ MD 5 _ DIGEST _ STR _ LEN ] ; ▁u int 8 _ t ▁ha 2 [ E VP _ MAX _ MD _ SIZE ] ; ▁un signed ▁int ▁ha 2 _ len ; ▁char ▁ha 2 _ str [ EST _ MAX _ MD 5 _ DIGEST _ STR _ LEN ] ; ▁char ▁nonce _ cnt [ 9 ] ▁= ▁" 00000001 "; ▁un signed ▁char ▁digest [ E VP _ MAX _ MD _ SIZE ] ; ▁un signed ▁int ▁d _ len ; ▁un signed ▁char ▁* rv ; ▁/* ▁* ▁C alculate ▁HA 1 ▁using ▁username , ▁realm , ▁password , ▁and ▁server ▁nonce ▁*/ ▁ mdctx ▁= ▁E VP _ MD _ CTX _ create (); ▁if ▁(! E VP _ Digest Init _ ex ( mdctx , ▁md , ▁NULL )) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁Initialize ▁digest "); ▁return ▁NULL ; ▁} ▁E VP _ Digest Update ( mdctx , ▁user , ▁ strnlen _ s ( user , ▁ MAX _ UIDPWD )); ▁E VP _ Digest Update ( mdctx , ▁":" , ▁1); ▁E VP _ Digest Update ( mdctx , ▁ctx -> realm , ▁ strnlen _ s ( ctx -> realm , ▁ MAX _ REALM )); ▁E VP _ Digest Update ( mdctx , ▁":" , ▁1); ▁E VP _ Digest Update ( mdctx , ▁pwd , ▁ strnlen _ s ( pwd , ▁ MAX _ UIDPWD )); ▁E VP _ Digest Final ( mdctx , ▁ha 1, ▁& ha 1 _ len ); ▁E VP _ MD _ CTX _ destroy ( mdctx ); ▁est _ hex _ to _ str ( ha 1 _ str , ▁ha 1, ▁ha 1 _ len ); ▁/* ▁* ▁C alculate ▁HA 2 ▁using ▁method , ▁URI , ▁*/ ▁ mdctx ▁= ▁E VP _ MD _ CTX _ create (); ▁if ▁(! E VP _ Digest Init _ ex ( mdctx , ▁md , ▁NULL )) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁Initialize ▁digest "); ▁return ▁NULL ; ▁} ▁E VP _ Digest Update ( mdctx , ▁" POST ", ▁4 ); ▁E VP _ Digest Update ( mdctx , ▁":" , ▁1); ▁E VP _ Digest Update ( mdctx , ▁uri , ▁ strnlen _ s ( uri , ▁ MAX _ REALM )); ▁E VP _ Digest Final ( mdctx , ▁ha 2 , ▁& ha 2 _ len ); ▁E VP _ MD _ CTX _ destroy ( mdctx ); ▁est _ hex _ to _ str ( ha 2 _ str , ▁ha 2 , ▁ha 2 _ len ); ▁/* ▁* ▁C alculate ▁auth ▁digest ▁using ▁HA 1, ▁nonce , ▁nonce ▁count , ▁client ▁nonce , ▁qop , ▁HA 2 ▁*/ ▁ mdctx ▁= ▁E VP _ MD _ CTX _ create (); ▁if ▁(! E VP _ Digest Init _ ex ( mdctx , ▁md , ▁NULL )) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁Initialize ▁digest "); ▁return ▁NULL ; ▁} ▁E VP _ Digest Update ( mdctx , ▁ha 1 _ str , ▁ha 1 _ len ▁* ▁2 ); ▁E VP _ Digest Update ( mdctx , ▁":" , ▁1); ▁E VP _ Digest Update ( mdctx , ▁ctx -> s _ nonce , ▁ strnlen _ s ( ctx -> s _ nonce , ▁ MAX _ NONCE )); ▁E VP _ Digest Update ( mdctx , ▁":" , ▁1); ▁E VP _ Digest Update ( mdctx , ▁nonce _ cnt , ▁ strnlen _ s ( nonce _ cnt , ▁ MAX _ NC )); ▁E VP _ Digest Update ( mdctx , ▁":" , ▁1); ▁E VP _ Digest Update ( mdctx , ▁ctx -> c _ nonce , ▁ strnlen _ s ( ctx -> c _ nonce , ▁ MAX _ NONCE )); ▁E VP _ Digest Update ( mdctx , ▁":" , ▁1); ▁E VP _ Digest Update ( mdctx , ▁" auth ", ▁4 ); ▁E VP _ Digest Update ( mdctx , ▁":" , ▁1); ▁E VP _ Digest Update ( mdctx , ▁ha 2 _ str , ▁ha 2 _ len ▁* ▁2 ); ▁E VP _ Digest Final ( mdctx , ▁digest , ▁& d _ len ); ▁E VP _ MD _ CTX _ destroy ( mdctx ); ▁rv ▁= ▁malloc ( EST _ MAX _ MD 5 _ DIGEST _ STR _ LEN ); ▁if ▁( rv ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁allocate ▁memory ▁for ▁digest "); ▁return ▁NULL ; ▁} ▁est _ hex _ to _ str ( ( char ▁* ) rv , ▁digest , ▁d _ len ); ▁return ▁( rv ); ▁} ▁/* ▁* ▁est _ client _ retrieve _ credentials () ▁is ▁used ▁to ▁retrieve ▁the ▁credentials ▁when ▁* ▁the ▁server ▁has ▁requested ▁e i ther ▁BASIC ▁or ▁ DIGEST ▁mode . ▁The ▁values ▁needed ▁from ▁* ▁the ▁application ▁layer ▁in ▁e i ther ▁mode ▁are ▁the ▁same , ▁username , ▁password , ▁but ▁the ▁* ▁API ▁will ▁indicate ▁the ▁mode ▁to ▁the ▁callback ▁in ▁case ▁anything ▁changes . ▁*/ ▁static ▁void ▁est _ client _ retrieve _ credentials ▁( EST _ CTX ▁* ctx , ▁EST _ HTTP _ AUTH _ MODE ▁auth _ mode , ▁char ▁* user , ▁char ▁* pwd ) ▁{ ▁EST _ HTTP _ AUTH _ HDR ▁auth _ credentials ; ▁EST _ HTTP _ AUTH _ CRE D _ RC ▁rc ; ▁/* ▁* ▁Se e ▁if ▁we ▁only ▁have ▁one ▁part ▁of ▁them . ▁If ▁so , ▁reset ▁the ▁part ▁we ▁* ▁have . ▁*/ ▁if ▁( ctx -> userid [0 ] ▁ != ▁'\0') ▁{ ▁mem zero _ s ( ctx -> userid , ▁sizeof ( ctx -> userid )); ▁} ▁if ▁( ctx -> password [0 ] ▁ != ▁'\0') ▁{ ▁mem zero _ s ( ctx -> password , ▁sizeof ( ctx -> password )); ▁} ▁/* ▁* ▁Need ▁to ▁ask ▁the ▁application ▁layer ▁for ▁the ▁credentials ▁*/ ▁mem zero _ s (& auth _ credentials , ▁sizeof ( auth _ credentials )); ▁if ▁( ctx -> auth _ credentials _ cb ) ▁{ ▁auth _ credentials . mode ▁= ▁auth _ mode ; ▁rc ▁= ▁ctx -> auth _ credentials _ cb (& auth _ credentials ); ▁if ▁( rc ▁== ▁EST _ HTTP _ AUTH _ CRE D _ NOT _ AVAILABLE ) ▁{ ▁EST _ LOG _ ERR (" Attempt ▁to ▁obtain ▁token ▁from ▁application ▁failed . "); ▁} ▁} ▁/* ▁* ▁D id ▁we ▁get ▁the ▁credentials ▁we ▁expected ? ▁If ▁not , ▁point ▁to ▁a ▁NULL ▁string ▁* ▁to ▁generate ▁the ▁header ▁*/ ▁if ▁( auth _ credentials . user ▁== ▁NULL ) ▁{ ▁user [0 ] ▁= ▁'\0'; ▁} ▁else ▁if ▁( MAX _ UIDPWD ▁< ▁ strnlen _ s ( auth _ credentials . user , ▁ MAX _ UIDPWD +1 )) ▁{ ▁EST _ LOG _ ERR (" User id ▁provided ▁is ▁large r ▁than ▁the ▁max ▁of ▁% d ", ▁ MAX _ UIDPWD ); ▁user [0 ] ▁= ▁'\0'; ▁} ▁else ▁{ ▁if ▁( EOK ▁ != ▁strncpy _ s ( user , ▁ MAX _ UIDPWD , ▁auth _ credentials . user , ▁ MAX _ UIDPWD )) ▁{ ▁EST _ LOG _ ERR (" I nvalid ▁User ▁ID ▁provided "); ▁} ▁} ▁if ▁( auth _ credentials . pwd ▁== ▁NULL ) ▁{ ▁pwd [0 ] ▁= ▁'\0'; ▁} ▁else ▁if ▁( MAX _ UIDPWD ▁< ▁ strnlen _ s ( auth _ credentials . pwd , ▁ MAX _ UIDPWD +1 )) ▁{ ▁EST _ LOG _ ERR (" Password ▁provided ▁is ▁large r ▁than ▁the ▁max ▁of ▁% d ", ▁ MAX _ UIDPWD ); ▁pwd [0 ] ▁= ▁'\0'; ▁} ▁else ▁{ ▁if ▁( EOK ▁ != ▁strncpy _ s ( pwd , ▁ MAX _ UIDPWD , ▁auth _ credentials . pwd , ▁ MAX _ UIDPWD )) ▁{ ▁EST _ LOG _ ERR (" I nvalid ▁User ▁password ▁provided "); ▁} ▁} ▁ cleanse _ auth _ credentials (& auth _ credentials ); ▁} ▁/* ▁* ▁This ▁function ▁add s ▁the ▁HTTP ▁authentication ▁header ▁to ▁* ▁an ▁out go ing ▁HTTP ▁request , ▁allowing ▁the ▁server ▁to ▁* ▁authenticate ▁the ▁EST ▁client . ▁* ▁* ▁ Parameters : ▁* ▁ctx : ▁EST ▁context ▁* ▁hdr : ▁pointer ▁to ▁the ▁buffer ▁to ▁hold ▁the ▁header ▁* ▁uri : ▁pointer ▁to ▁a ▁buffer ▁that ▁hold s ▁the ▁uri ▁to ▁be ▁used ▁in ▁the ▁header ▁*/ ▁static ▁void ▁est _ client _ add _ auth _ hdr ▁( EST _ CTX ▁* ctx , ▁char ▁* hdr , ▁char ▁* uri ) ▁{ ▁int ▁hdr _ len ; ▁un signed ▁char ▁* digest ; ▁un signed ▁char ▁client _ random [ 8 ] ; ▁char ▁both [ MAX _ UIDPWD *2+2 ] ; ▁/* ▁both ▁UID ▁and ▁ PWD ▁+ ▁":" ▁+ ▁/ 0 ▁*/ ▁char ▁both _ b 64 [2 *2 * MAX _ UIDPWD ] ; ▁int ▁both _ len ▁= ▁0; ▁EST _ HTTP _ AUTH _ HDR ▁auth _ credentials ; ▁EST _ HTTP _ AUTH _ CRE D _ RC ▁rc ; ▁char ▁* token ▁= ▁NULL ; ▁char ▁token _ b 64 [ MAX _ AUTH _ TOKEN _ LEN *2 ] ; ▁char ▁user [ MAX _ UIDPWD +1 ] ; ▁char ▁pwd [ MAX _ UIDPWD +1 ] ; ▁int ▁e nc _ len ▁= ▁0; ▁int ▁token _ len ▁= ▁0; ▁mem zero _ s ( both , ▁ MAX _ UIDPWD *2+2) ; ▁mem zero _ s ( both _ b 64, ▁2 *2 * MAX _ UIDPWD ); ▁hdr _ len ▁= ▁( int ) ▁ strnlen _ s ( hdr , ▁EST _ HTTP _ REQ _ TO TAL _ LEN ); ▁if ▁( hdr _ len ▁== ▁EST _ HTTP _ REQ _ TO TAL _ LEN ) ▁{ ▁EST _ LOG _ WARN (" Authentication ▁header ▁to ok ▁up ▁the ▁maximum ▁amount ▁in ▁buffer ▁(% d )", ▁EST _ HTTP _ REQ _ TO TAL _ LEN ); ▁} ▁switch ▁( ctx -> auth _ mode ) ▁{ ▁case ▁AUTH _ BASIC : ▁/* ▁* ▁make ▁sure ▁we ▁have ▁both ▁part s ▁of ▁the ▁credentials ▁to ▁send . ▁If ▁we ▁do , ▁* ▁then ▁we ' re ▁operat ing ▁in ▁the ▁original ▁mode ▁where ▁the ▁app ▁layer ▁* ▁provide s ▁them ▁up ▁front ▁before ▁they ' re ▁needed . ▁If ▁not , ▁then ▁we ▁can ▁* ▁now ▁go ▁ask ▁for ▁them ▁from ▁the ▁app ▁layer . ▁*/ ▁if ▁( ctx -> userid [0 ] ▁== ▁'\0' ▁&& ▁ctx -> password [0 ] ▁== ▁'\0') ▁{ ▁mem zero _ s ( user , ▁ MAX _ UIDPWD +1 ); ▁mem zero _ s ( pwd , ▁ MAX _ UIDPWD +1 ); ▁est _ client _ retrieve _ credentials ( ctx , ▁ctx -> auth _ mode , ▁user , ▁pwd ); ▁/* ▁* ▁regard less ▁of ▁what ▁come s ▁back , ▁build ▁the ▁string ▁containing ▁both ▁*/ ▁ snprintf ( both , ▁ MAX _ UIDPWD *2+2 , ▁"% s :% s ", ▁user , ▁pwd ); ▁} ▁else ▁{ ▁/* ▁* ▁Use ▁what ▁was ▁given ▁dur ing ▁configuration ▁through ▁est _ client _ set _ auth ▁*/ ▁ snprintf ( both , ▁ MAX _ UIDPWD *2+2 , ▁"% s :% s ", ▁ctx -> userid , ▁ctx -> password ); ▁} ▁/* ▁* ▁base 64 ▁encode ▁the ▁combine d ▁string ▁and ▁build ▁the ▁HTTP ▁auth ▁header ▁*/ ▁both _ len ▁= ▁ strnlen _ s ( both , ▁ MAX _ UIDPWD *2+2) ; ▁e nc _ len ▁= ▁est _ base 64_ encode ( ( const ▁char ▁* ) both , ▁both _ len , ▁both _ b 64, ▁( 2 *2 * MAX _ UIDPWD )); ▁if ▁( enc _ len ▁< = ▁0) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁encode ▁basic ▁auth ▁value "); ▁} ▁ snprintf ( hdr ▁+ ▁hdr _ len , ▁EST _ HTTP _ REQ _ TO TAL _ LEN - hdr _ len , ▁" Authorization : ▁Basic ▁% s \ r \ n ", ▁both _ b 64 ); ▁break ; ▁case ▁AUTH _ DIGEST : ▁/* ▁Generate ▁a ▁client ▁nonce ▁*/ ▁if ▁(! R AND _ bytes ( client _ random , ▁ 8)) ▁{ ▁EST _ LOG _ ERR (" R NG ▁failure ▁while ▁generat ing ▁nonce "); ▁/* ▁For ce ▁hdr ▁to ▁a ▁null ▁string ▁*/ ▁mem zero _ s ( hdr , ▁EST _ HTTP _ REQ _ TO TAL _ LEN ); ▁break ; ▁} ▁est _ hex _ to _ str ( ctx -> c _ nonce , ▁client _ random , ▁8 ); ▁/* ▁* ▁Check ▁to ▁see ▁if ▁the ▁application ▁layer ▁has ▁provided ▁username ▁and ▁password ▁* ▁up ▁front ▁dur ing ▁configuration . ▁If ▁it ▁has ▁not , ▁go ▁retrieve ▁them ▁now , ▁otherwise , ▁* ▁copy ▁them ▁into ▁the ▁local ▁buffer s ▁to ▁get ▁them ▁ready ▁*/ ▁if ▁( ctx -> userid [0 ] ▁== ▁'\0' ▁&& ▁ctx -> password [0 ] ▁== ▁'\0') ▁{ ▁mem zero _ s ( user , ▁ MAX _ UIDPWD +1 ); ▁mem zero _ s ( pwd , ▁ MAX _ UIDPWD +1 ); ▁est _ client _ retrieve _ credentials ( ctx , ▁ctx -> auth _ mode , ▁user , ▁pwd ); ▁} ▁else ▁{ ▁if ▁( EOK ▁ != ▁strncpy _ s ( user , ▁ MAX _ UIDPWD , ▁ctx -> userid , ▁ MAX _ UIDPWD )) ▁{ ▁EST _ LOG _ ERR (" I nvalid ▁User ▁ID ▁provided "); ▁} ▁if ▁( EOK ▁ != ▁strncpy _ s ( pwd , ▁ MAX _ UIDPWD , ▁ctx -> password , ▁ MAX _ UIDPWD )) ▁{ ▁EST _ LOG _ ERR (" I nvalid ▁User ▁password ▁provided "); ▁} ▁} ▁digest ▁= ▁est _ client _ generate _ auth _ digest ( ctx , ▁uri , ▁user , ▁pwd ); ▁if ▁( digest ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" Error ▁while ▁generat ing ▁digest "); ▁/* ▁For ce ▁hdr ▁to ▁a ▁null ▁string ▁*/ ▁mem zero _ s ( hdr , ▁EST _ HTTP _ REQ _ TO TAL _ LEN ); ▁mem zero _ s ( ctx -> c _ nonce , ▁ MAX _ NONCE +1 ); ▁mem zero _ s ( user , ▁ MAX _ UIDPWD +1 ); ▁mem zero _ s ( pwd , ▁ MAX _ UIDPWD +1 ); ▁break ; ▁} ▁ snprintf ( hdr ▁+ ▁hdr _ len , ▁EST _ HTTP _ REQ _ TO TAL _ LEN - hdr _ len , ▁" Authorization : ▁Digest ▁username =\"% s \ ", ▁realm =\"% s \ ", ▁nonce =\"% s \ ", ▁uri =\"% s \ ", ▁ cnonce =\"% s \ ", ▁ nc = 00000001 , ▁qop =\" auth \ ", ▁response =\"% s \"\ r \ n ", ▁user , ▁ctx -> realm , ▁ctx -> s _ nonce , ▁uri , ▁ctx -> c _ nonce , ▁digest ); ▁mem zero _ s ( digest , ▁EST _ MAX _ MD 5 _ DIGEST _ STR _ LEN ); ▁mem zero _ s ( ctx -> c _ nonce , ▁ MAX _ NONCE +1 ); ▁mem zero _ s ( user , ▁ MAX _ UIDPWD +1 ); ▁mem zero _ s ( pwd , ▁ MAX _ UIDPWD +1 ); ▁free ( digest ); ▁break ; ▁case ▁AUTH _ TOKEN : ▁EST _ LOG _ INFO (" Server ▁requested ▁Token ▁based ▁authentication "); ▁mem zero _ s (& auth _ credentials , ▁sizeof ( auth _ credentials )); ▁if ▁( ctx -> auth _ credentials _ cb ) ▁{ ▁auth _ credentials . mode ▁= ▁AUTH _ TOKEN ; ▁rc ▁= ▁ctx -> auth _ credentials _ cb (& auth _ credentials ); ▁if ▁( rc ▁== ▁EST _ HTTP _ AUTH _ CRE D _ NOT _ AVAILABLE ) ▁{ ▁EST _ LOG _ ERR (" Attempt ▁to ▁obtain ▁token ▁from ▁application ▁failed . "); ▁} ▁} ▁/* ▁* ▁D id ▁we ▁get ▁the ▁credentials ▁we ▁expected ? ▁If ▁not , ▁point ▁to ▁a ▁NULL ▁string ▁* ▁to ▁generate ▁the ▁header ▁*/ ▁if ▁( auth _ credentials . auth _ token ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" Requested ▁token ▁credentials , ▁but ▁application ▁did ▁not ▁provide ▁any . "); ▁token ▁= ▁""; ▁} ▁else ▁{ ▁/* ▁* ▁Make ▁sure ▁the ▁token ▁we ▁we re ▁given ▁is ▁not ▁too ▁long . ▁* ▁If ▁it ▁is , ▁force ▁it ▁to ▁NULL ▁to ▁cause ▁the ▁auth ▁failure ▁at ▁* ▁the ▁server ▁just ▁as ▁if ▁no ▁credentials ▁we re ▁provided ▁*/ ▁if ▁( MAX _ AUTH _ TOKEN _ LEN ▁< ▁ strnlen _ s ( auth _ credentials . auth _ token , ▁ MAX _ AUTH _ TOKEN _ LEN +1 )) ▁{ ▁EST _ LOG _ ERR (" Token ▁provided ▁is ▁large r ▁than ▁the ▁max ▁of ▁% d ", ▁ MAX _ AUTH _ TOKEN _ LEN ); ▁token ▁= ▁""; ▁} ▁else ▁{ ▁token ▁= ▁auth _ credentials . auth _ token ; ▁} ▁} ▁/* ▁* ▁base 64 ▁encode ▁the ▁combine d ▁string ▁and ▁build ▁the ▁HTTP ▁auth ▁header ▁*/ ▁mem zero _ s ( token _ b 64, ▁ MAX _ AUTH _ TOKEN _ LEN *2 ); ▁token _ len ▁= ▁ strnlen _ s ( token , ▁ MAX _ AUTH _ TOKEN _ LEN ); ▁e nc _ len ▁= ▁est _ base 64_ encode ( ( const ▁char ▁* ) token , ▁token _ len , ▁token _ b 64, ▁ MAX _ AUTH _ TOKEN _ LEN *2 ); ▁if ▁( enc _ len ▁< = ▁0) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁encode ▁bearer ▁token ▁auth ▁value "); ▁} ▁ snprintf ( hdr ▁+ ▁hdr _ len , ▁EST _ HTTP _ REQ _ TO TAL _ LEN - hdr _ len , ▁" Authorization : ▁Bearer ▁% s \ r \ n ", ▁token _ b 64 ); ▁ cleanse _ auth _ credentials (& auth _ credentials ); ▁break ; ▁default : ▁EST _ LOG _ INFO (" No ▁HTTP ▁auth ▁mode ▁set , ▁send ing ▁ano nymo us ▁request "); ▁break ; ▁} ▁} ▁/* ▁* ▁This ▁function ▁is ▁used ▁to ▁build ▁the ▁HTTP ▁header ▁for ▁* ▁the ▁CA certs ▁request ▁flow . ▁* ▁* ▁ Parameters : ▁* ▁ctx : ▁EST ▁context ▁* ▁hdr : ▁pointer ▁to ▁the ▁buffer ▁to ▁hold ▁the ▁header ▁*/ ▁static ▁int ▁est _ client _ build _ cacerts _ header ▁( EST _ CTX ▁* ctx , ▁char ▁* hdr ) ▁{ ▁int ▁hdr _ len ; ▁ snprintf ( hdr , ▁EST _ HTTP _ REQ _ TO TAL _ LEN , ▁" GET ▁% s % s % s /% s ▁HTTP /1.1 \ r \ n " ▁" User - Agent : ▁% s \ r \ n " ▁" Connection : ▁close \ r \ n " ▁" Host : ▁% s :% d \ r \ n " ▁" Accept : ▁*/* \ r \ n ", ▁EST _ P ATH _ PRE FIX , ▁( ctx -> uri _ path _ segment ?" / ":"") , ▁( ctx -> uri _ path _ segment ? ctx -> uri _ path _ segment :"") , ▁EST _ GET _ CACERTS , ▁EST _ HTTP _ HDR _ EST _ CLIENT , ▁ctx -> est _ server , ▁ctx -> est _ port _ num ); ▁hdr _ len ▁= ▁( int ) ▁ strnlen _ s ( hdr , ▁EST _ HTTP _ REQ _ TO TAL _ LEN ); ▁if ▁( hdr _ len ▁== ▁EST _ HTTP _ REQ _ TO TAL _ LEN ) ▁{ ▁EST _ LOG _ WARN (" CA ▁Certs ▁header ▁to ok ▁up ▁the ▁maximum ▁amount ▁in ▁buffer ▁(% d )", ▁EST _ HTTP _ REQ _ TO TAL _ LEN ); ▁} ▁return ▁( hdr _ len ); ▁} ▁/* ▁* ▁This ▁function ▁is ▁used ▁to ▁build ▁the ▁HTTP ▁header ▁for ▁* ▁the ▁CSR ▁attributes ▁request ▁flow . ▁* ▁* ▁ Parameters : ▁* ▁ctx : ▁EST ▁context ▁* ▁hdr : ▁pointer ▁to ▁the ▁buffer ▁to ▁hold ▁the ▁header ▁*/ ▁static ▁int ▁est _ client _ build _ csr _ header ▁( EST _ CTX ▁* ctx , ▁char ▁* hdr ) ▁{ ▁int ▁hdr _ len ; ▁ snprintf ( hdr , ▁EST _ HTTP _ REQ _ TO TAL _ LEN , " GET ▁% s % s % s /% s ▁HTTP /1.1 \ r \ n " ▁" User - Agent : ▁% s \ r \ n " ▁" Connection : ▁close \ r \ n " ▁" Host : ▁% s :% d \ r \ n " ▁" Accept : ▁*/* \ r \ n ", ▁EST _ P ATH _ PRE FIX , ▁( ctx -> uri _ path _ segment ?" / ":"") , ▁( ctx -> uri _ path _ segment ? ctx -> uri _ path _ segment :"") , ▁EST _ GET _ CSRATTRS , ▁EST _ HTTP _ HDR _ EST _ CLIENT , ▁ctx -> est _ server , ▁ctx -> est _ port _ num ); ▁est _ client _ add _ auth _ hdr ( ctx , ▁hdr , ▁EST _ SIMPLE _ ENROLL _ URI ); ▁hdr _ len ▁= ▁( int ) ▁ strnlen _ s ( hdr , ▁EST _ HTTP _ REQ _ TO TAL _ LEN ); ▁if ▁( hdr _ len ▁== ▁EST _ HTTP _ REQ _ TO TAL _ LEN ) ▁{ ▁EST _ LOG _ WARN (" CSR ▁attributes ▁request ▁header ▁to ok ▁up ▁the ▁maximum ▁amount ▁in ▁buffer ▁(% d )", ▁EST _ HTTP _ REQ _ TO TAL _ LEN ); ▁} ▁return ▁( hdr _ len ); ▁} ▁/* ▁* ▁This ▁function ▁does ▁the ▁work ▁for ▁the ▁CSR ▁attributes ▁request ▁flow . ▁* ▁* ▁ Parameters : ▁* ▁ctx : ▁EST ▁context ▁* ▁ssl : ▁SSL ▁context ▁*/ ▁static ▁int ▁est _ client _ send _ csrattrs _ request ▁( EST _ CTX ▁* ctx , ▁SSL ▁* ssl , ▁un signed ▁char ▁** csrattrs , ▁int ▁* csrattrs _ len ) ▁{ ▁char ▁* http _ data ; ▁int ▁hdr _ len ; ▁int ▁read _ size , ▁write _ size ; ▁un signed ▁char ▁* csr _ attrs _ buf ▁= ▁NULL ; ▁int ▁rv ; ▁/* ▁assume ▁ def e at ▁*/ ▁* csrattrs ▁= ▁NULL ; ▁* csrattrs _ len ▁= ▁0; ▁/* ▁* ▁Build ▁the ▁HTTP ▁request ▁* ▁- ▁allocate ▁buffer : ▁header , ▁no ▁data , ▁terminat ing ▁characters ▁* ▁- ▁build ▁the ▁header ▁* ▁- ▁no ▁data ▁* ▁- ▁terminate ▁it ▁*/ ▁http _ data ▁= ▁malloc ( EST _ HTTP _ REQ _ TO TAL _ LEN ); ▁if ▁( http _ data ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁allocate ▁memory ▁for ▁http _ data "); ▁return ▁EST _ ERR _ MALLOC ; ▁} ▁hdr _ len ▁= ▁est _ client _ build _ csr _ header ( ctx , ▁http _ data ); ▁if ▁( hdr _ len ▁== ▁0) ▁{ ▁EST _ LOG _ ERR (" CSR ▁attributes ▁HTTP ▁header ▁could ▁not ▁be ▁ built ▁correctly "); ▁free ( http _ data ); ▁return ▁( EST _ ERR _ HTTP _ CA N NOT _ BU IL D _ HEADER ); ▁} ▁/* ▁* ▁terminate ▁the ▁HTTP ▁header ▁*/ ▁ snprintf ( http _ data ▁+ ▁hdr _ len , ▁EST _ HTTP _ REQ _ TO TAL _ LEN - hdr _ len , ▁"\ r \ n "); ▁hdr _ len ▁+= ▁2 ; ▁/* ▁* ▁no ▁data ▁is ▁being ▁sent ▁so ▁go ▁a head ▁and ▁terminate ▁the ▁HTTP ▁request ▁*/ ▁ snprintf ( http _ data ▁+ ▁hdr _ len , ▁EST _ HTTP _ REQ _ TO TAL _ LEN - hdr _ len , ▁"\ r \ n "); ▁hdr _ len ▁+= ▁2 ; ▁/* ▁* ▁Send ▁the ▁request ▁to ▁the ▁server ▁and ▁wait ▁for ▁a ▁response ▁*/ ▁ctx -> last _ http _ status ▁= ▁0; ▁write _ size ▁= ▁SSL _ write ( ssl , ▁http _ data , ▁hdr _ len ); ▁if ▁( write _ size ▁< ▁0) ▁{ ▁EST _ LOG _ ERR (" TLS ▁write ▁error "); ▁ossl _ dump _ ssl _ errors (); ▁rv ▁= ▁EST _ ERR _ SSL _ WRITE ; ▁} ▁else ▁{ ▁EST _ LOG _ INFO (" TLS ▁wro te ▁% d ▁bytes , ▁attempted ▁% d ▁bytes \ n ", ▁write _ size , ▁hdr _ len ); ▁/* ▁* ▁T ry ▁to ▁get ▁the ▁response ▁from ▁the ▁server ▁*/ ▁rv ▁= ▁est _ io _ get _ response ( ctx , ▁ssl , ▁EST _ OP _ CSRATTRS , ▁& csr _ attrs _ buf , ▁& read _ size ); ▁switch ▁( rv ) ▁{ ▁case ▁EST _ ERR _ NONE : ▁if ▁( csr _ attrs _ buf ▁ != ▁NULL ) ▁{ ▁* csrattrs ▁= ▁csr _ attrs _ buf ; ▁* csrattrs _ len ▁= ▁read _ size ; ▁} ▁break ; ▁case ▁EST _ ERR _ AUTH _ FAIL : ▁default : ▁EST _ LOG _ ERR (" EST ▁request ▁failed : ▁% d ▁(% s )", ▁rv , ▁EST _ ERR _ NUM _ TO _ STR ( rv )); ▁if ▁( csr _ attrs _ buf ) ▁{ ▁free ( csr _ attrs _ buf ); ▁} ▁break ; ▁} ▁} ▁free ( http _ data ); ▁return ▁( rv ); ▁} ▁/* ▁* ▁This ▁function ▁is ▁used ▁to ▁build ▁the ▁HTTP ▁header ▁for ▁* ▁the ▁Simple ▁Enroll ▁flow . ▁* ▁* ▁ Parameters : ▁* ▁ctx : ▁EST ▁context ▁* ▁hdr : ▁pointer ▁to ▁the ▁buffer ▁to ▁hold ▁the ▁header ▁* ▁pkcs 10_ len : ▁length ▁of ▁the ▁buffer ▁point ed ▁to ▁by ▁hdr ▁*/ ▁static ▁int ▁est _ client _ build _ enroll _ header ▁( EST _ CTX ▁* ctx , ▁char ▁* hdr , ▁int ▁pkcs 10_ len ) ▁{ ▁int ▁hdr _ len ; ▁ snprintf ( hdr , ▁EST _ HTTP _ REQ _ TO TAL _ LEN , ▁" POST ▁% s % s % s /% s ▁HTTP /1.1 \ r \ n " ▁" User - Agent : ▁% s \ r \ n " ▁" Connection : ▁close \ r \ n " ▁" Host : ▁% s :% d \ r \ n " ▁" Accept : ▁*/* \ r \ n " ▁" Content - Type : ▁application / pkcs 10 \ r \ n " ▁" Content - Length : ▁% d \ r \ n ", ▁EST _ P ATH _ PRE FIX , ▁( ctx -> uri _ path _ segment ?" / ":"") , ▁( ctx -> uri _ path _ segment ? ctx -> uri _ path _ segment :"") , ▁EST _ SIMPLE _ ENROLL , ▁EST _ HTTP _ HDR _ EST _ CLIENT , ▁ctx -> est _ server , ▁ctx -> est _ port _ num , ▁pkcs 10_ len ); ▁est _ client _ add _ auth _ hdr ( ctx , ▁hdr , ▁EST _ SIMPLE _ ENROLL _ URI ); ▁hdr _ len ▁= ▁( int ) ▁ strnlen _ s ( hdr , ▁EST _ HTTP _ REQ _ TO TAL _ LEN ); ▁if ▁( hdr _ len ▁== ▁EST _ HTTP _ REQ _ TO TAL _ LEN ) ▁{ ▁EST _ LOG _ WARN (" Client ▁enroll ▁request ▁header ▁to ok ▁up ▁the ▁maximum ▁amount ▁in ▁buffer ▁(% d )", ▁EST _ HTTP _ REQ _ TO TAL _ LEN ); ▁} ▁return ▁( hdr _ len ); ▁} ▁/* ▁* ▁This ▁function ▁is ▁used ▁to ▁build ▁the ▁HTTP ▁header ▁for ▁* ▁the ▁Simple ▁Re Enroll ▁flow . ▁* ▁* ▁ Parameters : ▁* ▁ctx : ▁EST ▁context ▁* ▁hdr : ▁pointer ▁to ▁the ▁buffer ▁to ▁hold ▁the ▁header ▁* ▁pkcs 10_ len : ▁length ▁of ▁the ▁buffer ▁point ed ▁to ▁by ▁hdr ▁*/ ▁static ▁int ▁est _ client _ build _ reenroll _ header ▁( EST _ CTX ▁* ctx , ▁char ▁* hdr , ▁int ▁pkcs 10_ len ) ▁{ ▁int ▁hdr _ len ; ▁ snprintf ( hdr , ▁EST _ HTTP _ REQ _ TO TAL _ LEN , ▁" POST ▁% s % s % s /% s ▁HTTP /1.1 \ r \ n " ▁" User - Agent : ▁% s \ r \ n " ▁" Connection : ▁close \ r \ n " ▁" Host : ▁% s :% d \ r \ n " ▁" Accept : ▁*/* \ r \ n " ▁" Content - Type : ▁application / pkcs 10 \ r \ n " ▁" Content - Length : ▁% d \ r \ n ", ▁EST _ P ATH _ PRE FIX , ▁( ctx -> uri _ path _ segment ?" / ":"") , ▁( ctx -> uri _ path _ segment ? ctx -> uri _ path _ segment :"") , ▁EST _ SIMPLE _ REENROLL , ▁EST _ HTTP _ HDR _ EST _ CLIENT , ▁ctx -> est _ server , ▁ctx -> est _ port _ num , ▁pkcs 10_ len ); ▁est _ client _ add _ auth _ hdr ( ctx , ▁hdr , ▁EST _ SIMPLE _ ENROLL _ URI ); ▁hdr _ len ▁= ▁( int ) ▁ strnlen _ s ( hdr , ▁EST _ HTTP _ REQ _ TO TAL _ LEN ); ▁if ▁( hdr _ len ▁== ▁EST _ HTTP _ REQ _ TO TAL _ LEN ) ▁{ ▁EST _ LOG _ WARN (" Client ▁reenroll ▁request ▁header ▁to ok ▁up ▁the ▁maximum ▁amount ▁in ▁buffer ▁(% d )", ▁EST _ HTTP _ REQ _ TO TAL _ LEN ); ▁} ▁return ▁( hdr _ len ); ▁} ▁/* ▁* ▁This ▁function ▁send s ▁the ▁HTTP ▁request ▁for ▁a ▁Simple ▁Enroll ▁* ▁The ▁CSR ▁( pkcs 10) ▁is ▁already ▁ built ▁at ▁this ▁point . ▁This ▁* ▁function ▁simpl y ▁create s ▁the ▁HTTP ▁header ▁and ▁body ▁and ▁put s ▁* ▁it ▁on ▁the ▁w i re . ▁It ▁then ▁wait s ▁for ▁a ▁response ▁from ▁the ▁* ▁server ▁and ▁copie s ▁the ▁response ▁to ▁a ▁buffer ▁provided ▁by ▁* ▁the ▁caller ▁* ▁* ▁ Parameters : ▁* ▁ctx : ▁EST ▁context ▁* ▁ssl : ▁SSL ▁context ▁* ▁bptr : ▁pointer ▁containing ▁PKCS 10 ▁CSR ▁* ▁pkcs 7 : ▁pointer ▁that ▁will ▁receive ▁the ▁pkcs 7 ▁response ▁* ▁pkcs 7_ len : ▁length ▁of ▁pkcs 7 ▁response ▁* ▁reenroll : ▁Set ▁to ▁1 ▁to ▁do ▁a ▁reenroll ▁instead ▁of ▁an ▁enroll ▁* ▁*/ ▁int ▁est _ client _ send _ enroll _ request ▁( EST _ CTX ▁* ctx , ▁SSL ▁* ssl , ▁ BUF _ MEM ▁* bptr , ▁un signed ▁char ▁* pkcs 7, ▁int ▁* pkcs 7_ len , ▁int ▁reenroll ) ▁{ ▁char ▁* http _ data ; ▁int ▁hdr _ len ; ▁int ▁write _ size ; ▁un signed ▁char ▁* enroll _ buf ▁= ▁NULL ; ▁int ▁enroll _ buf _ len ▁= ▁0; ▁int ▁rv ; ▁/* ▁* ▁A ssume ▁the ▁enroll ▁will ▁fail , ▁set ▁return ▁length ▁to ▁zero ▁* ▁to ▁be ▁defensive . ▁*/ ▁* pkcs 7_ len ▁= ▁0; ▁/* ▁* ▁Build ▁the ▁HTTP ▁request ▁* ▁- ▁allocate ▁buffer : ▁header , ▁data , ▁terminat ing ▁characters ▁* ▁- ▁build ▁the ▁header ▁* ▁- ▁no ▁data ▁* ▁- ▁terminate ▁it ▁*/ ▁http _ data ▁= ▁malloc ( EST _ HTTP _ REQ _ TO TAL _ LEN ); ▁if ▁( http _ data ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁allocate ▁memory ▁for ▁http _ data "); ▁return ▁EST _ ERR _ MALLOC ; ▁} ▁if ▁(! reenroll ) ▁{ ▁/* ▁Perform ▁a ▁/ simpleenroll ▁*/ ▁hdr _ len ▁= ▁est _ client _ build _ enroll _ header ( ctx , ▁http _ data , ▁( int ) ▁bptr -> length ); ▁} ▁else ▁{ ▁/* ▁Perform ▁a ▁/ simplereenroll ▁*/ ▁hdr _ len ▁= ▁est _ client _ build _ reenroll _ header ( ctx , ▁http _ data , ▁( int ) ▁bptr -> length ); ▁} ▁if ▁( hdr _ len ▁== ▁0) ▁{ ▁EST _ LOG _ ERR (" Enroll ▁HTTP ▁header ▁could ▁not ▁be ▁ built ▁correctly "); ▁free ( http _ data ); ▁return ▁( EST _ ERR _ HTTP _ CA N NOT _ BU IL D _ HEADER ); ▁} ▁/* ▁* ▁terminate ▁the ▁HTTP ▁header ▁*/ ▁ snprintf ( http _ data ▁+ ▁hdr _ len , EST _ HTTP _ REQ _ TO TAL _ LEN - hdr _ len , ▁"\ r \ n "); ▁hdr _ len ▁+= ▁2 ; ▁/* ▁* ▁Build ▁the ▁HTTP ▁body ▁containing ▁the ▁pkcs 10 ▁request ▁*/ ▁memcpy _ s ( http _ data ▁+ ▁hdr _ len , ▁EST _ HTTP _ REQ _ DATA _ MAX , ▁bptr -> data , ▁( r size _ t ) bptr -> length ); ▁hdr _ len ▁+= ▁bptr -> length ; ▁/* ▁* ▁terminate ▁the ▁HTTP ▁request ▁*/ ▁ snprintf ( http _ data ▁+ ▁hdr _ len , ▁EST _ HTTP _ REQ _ TO TAL _ LEN - hdr _ len , " \ r \ n "); ▁hdr _ len ▁+= ▁2 ; ▁/* ▁* ▁Send ▁the ▁request ▁to ▁the ▁server ▁and ▁wait ▁for ▁a ▁response ▁*/ ▁ctx -> last _ http _ status ▁= ▁0; ▁write _ size ▁= ▁SSL _ write ( ssl , ▁http _ data , ▁hdr _ len ); ▁if ▁( write _ size ▁< ▁0) ▁{ ▁EST _ LOG _ ERR (" TLS ▁write ▁error "); ▁ossl _ dump _ ssl _ errors (); ▁rv ▁= ▁EST _ ERR _ SSL _ WRITE ; ▁} ▁else ▁{ ▁EST _ LOG _ INFO (" TLS ▁wro te ▁% d ▁bytes , ▁attempted ▁% d ▁bytes \ n ", ▁write _ size , ▁hdr _ len ); ▁/* ▁* ▁T ry ▁to ▁get ▁the ▁response ▁from ▁the ▁server ▁*/ ▁rv ▁= ▁est _ io _ get _ response ( ctx , ▁ssl , ▁EST _ OP _ SIMPLE _ ENROLL , ▁& enroll _ buf , ▁& enroll _ buf _ len ); ▁switch ▁( rv ) ▁{ ▁case ▁EST _ ERR _ NONE : ▁if ▁( enroll _ buf _ len ▁== ▁0) ▁{ ▁EST _ LOG _ ERR (" Enroll ▁buf ▁is ▁zero ▁bytes ▁in ▁length "); ▁rv ▁= ▁EST _ ERR _ ZE RO _ LEN G TH _ BUF ; ▁break ; ▁} ▁memcpy _ s ( pkcs 7, ▁EST _ MAX _ CLIENT _ CERT _ LEN , ▁enroll _ buf , ▁enroll _ buf _ len ); ▁* pkcs 7_ len ▁= ▁enroll _ buf _ len ; ▁break ; ▁case ▁EST _ ERR _ AUTH _ FAIL : ▁EST _ LOG _ WARN (" HTTP ▁auth ▁failure "); ▁break ; ▁default : ▁EST _ LOG _ ERR (" EST ▁request ▁failed : ▁% d ▁(% s )", ▁rv , ▁EST _ ERR _ NUM _ TO _ STR ( rv )); ▁break ; ▁} ▁free ( enroll _ buf ); ▁} ▁O PEN SSL _ cleanse ( http _ data , ▁ strnlen _ s ( http _ data , ▁EST _ HTTP _ REQ _ TO TAL _ LEN )); ▁free ( http _ data ); ▁http _ data ▁= ▁NULL ; ▁return ▁( rv ); ▁} ▁/* ▁* ▁This ▁function ▁does ▁a ▁ sanity ▁check ▁on ▁the ▁X 509 ▁* ▁prior ▁to ▁attempt ing ▁to ▁convert ▁the ▁X 509 ▁to ▁* ▁a ▁CSR ▁for ▁a ▁reenroll ▁operation . ▁* ▁* ▁Returns ▁an ▁EST _ ERROR ▁code ▁*/ ▁static ▁EST _ ERROR ▁est _ client _ check _ x 509 ▁( X 509 ▁* cert ) ▁{ ▁/* ▁* ▁Make ▁sure ▁the ▁cert ▁is ▁signed ▁*/ ▁if (! cert -> signature ) ▁{ ▁EST _ LOG _ ERR (" The ▁certificate ▁provided ▁does ▁not ▁contain ▁a ▁signature . "); ▁return ▁( EST _ ERR _ BAD _ X 509 ); ▁} ▁/* ▁* ▁Make ▁sure ▁the ▁signature ▁length ▁is ▁not ▁invalid ▁*/ ▁if ▁( cert -> signature -> length ▁< = ▁0) ▁{ ▁EST _ LOG _ ERR (" The ▁certificate ▁provided ▁contains ▁an ▁invalid ▁signature ▁length . "); ▁return ▁( EST _ ERR _ BAD _ X 509 ); ▁} ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁This ▁function ▁is ▁used ▁to ▁clear ▁any ▁C hallengePassword ▁* ▁attributes ▁in ▁an ▁X 509 ▁CSR . ▁This ▁is ▁used ▁because ▁when ▁* ▁HTTP ▁authentication ▁is ▁used ▁dur ing ▁the ▁enrollment ▁* ▁process , ▁the ▁PoP ▁value ▁will ▁change ▁when ▁the ▁client ▁* ▁send s ▁the ▁second ▁HTTP ▁request ▁that ▁contains ▁the ▁HTTP ▁* ▁authorization ▁values . ▁S ince ▁the ▁CSR ▁is ▁ reused ▁between ▁* ▁both ▁the ▁initial ▁and ▁secondary ▁requests , ▁we ▁need ▁to ▁* ▁clear ▁the ▁PoP ▁value ▁from ▁the ▁CSR ▁before ▁submitting ▁* ▁the ▁secondary ▁request . ▁*/ ▁static ▁void ▁est _ client _ clear _ csr _ pop ▁( X 509_ REQ ▁* csr ) ▁{ ▁int ▁ pos ▁= ▁0; ▁X 509_ ATTRIBUTE ▁* attr ; ▁/* ▁* ▁The ▁challenge ▁password ▁( PoP ) ▁ma y ▁be ▁in ▁the ▁CSR ▁* ▁more ▁than ▁once . ▁This ▁should ▁n ever ▁happen , ▁but ▁* ▁we ' re ▁being ▁defensive . ▁*/ ▁while ▁( pos ▁>= ▁0) ▁{ ▁/* ▁* ▁Look ▁for ▁the ▁PoP ▁value ▁in ▁the ▁CSR ▁*/ ▁ pos ▁= ▁X 509_ REQ _ get _ attr _ by _ NID ( csr , ▁NID _ pkcs 9 _ c hallengePassword , ▁-1) ; ▁if ▁( pos ▁>= ▁0) ▁{ ▁/* ▁* ▁If ▁found , ▁delete ▁it ▁*/ ▁attr ▁= ▁X 509_ REQ _ delete _ attr ( csr , ▁ pos ); ▁if ▁( attr ) ▁{ ▁/* ▁* ▁There ▁are ▁no ▁do cs ▁in ▁OpenSSL ▁that ▁show ▁how ▁* ▁to ▁use ▁X 509_ REQ _ delete _ attr . ▁Go ing ▁to ▁assume ▁* ▁we ▁need ▁to ▁free ▁the ▁attribute ▁ourselves . ▁There ▁* ▁do ▁not ▁appear ▁to ▁be ▁any ▁good ▁example s ▁on ▁how ▁* ▁to ▁use ▁this ▁API . ▁*/ ▁X 509_ ATTRIBUTE _ free ( attr ); ▁} ▁} ▁} ▁} ▁/* ▁* ▁This ▁function ▁does ▁the ▁work ▁of ▁convert ing ▁the ▁X 509_ REQ * ▁to ▁* ▁the ▁base 64 ▁encoded ▁DER ▁format ▁as ▁specified ▁in ▁the ▁EST ▁RFC . ▁* ▁On ce ▁convert ed ▁to ▁the ▁proper ▁format , ▁this ▁routine ▁will ▁* ▁forward ▁the ▁request ▁to ▁the ▁server , ▁check ▁the ▁response , ▁* ▁and ▁save ▁the ▁cert ▁on ▁the ▁local ▁context ▁where ▁it ▁can ▁be ▁* ▁retrieved ▁later ▁by ▁the ▁application ▁layer . ▁*/ ▁static ▁EST _ ERROR ▁est _ client _ enroll _ req ▁( EST _ CTX ▁* ctx , ▁SSL ▁* ssl , ▁X 509_ REQ ▁* req , ▁int ▁* pkcs 7_ len , ▁int ▁reenroll ) ▁{ ▁EST _ ERROR ▁rv ▁= ▁EST _ ERR _ NONE ; ▁BIO ▁* p 10 out ▁= ▁NULL , ▁* b 64 ; ▁ BUF _ MEM ▁* bptr ▁= ▁NULL ; ▁un signed ▁char ▁* recv _ buf ; ▁un signed ▁char ▁* new _ cert _ buf ; ▁int ▁new _ cert _ buf _ len ; ▁/* ▁* ▁Gra b ▁the ▁PKCS 10 ▁PEM ▁encoded ▁data ▁*/ ▁b 64 ▁= ▁BIO _ new ( BIO _ f _ base 64 ()); ▁if ▁(! b 64 ) ▁{ ▁EST _ LOG _ ERR (" BIO _ new ▁failed "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁EST _ ERR _ MALLOC ; ▁} ▁p 10 out ▁= ▁BIO _ new ( BIO _ s _ mem ()); ▁if ▁(! p 10 out ) ▁{ ▁EST _ LOG _ ERR (" BIO _ new ▁failed "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁EST _ ERR _ MALLOC ; ▁} ▁p 10 out ▁= ▁BIO _ push ( b 64, ▁p 10 out ); ▁/* ▁* ▁ Encode ▁using ▁DER ▁( ASN . 1) ▁* ▁* ▁We ▁have ▁to ▁set ▁the ▁modified ▁flag ▁on ▁the ▁X 509_ REQ ▁because ▁* ▁OpenSSL ▁keep s ▁a ▁cached ▁copy ▁of ▁the ▁DER ▁encoded ▁data ▁in ▁some ▁* ▁cases . ▁Sett ing ▁this ▁flag ▁tell s ▁OpenSSL ▁to ▁run ▁the ▁ASN ▁* ▁encoding ▁again ▁r ather ▁than ▁using ▁the ▁cached ▁copy . ▁* ▁*/ ▁req -> req _ info -> enc . modified ▁= ▁1; ▁i 2 d _ X 509_ REQ _ bio ( p 10 out , ▁req ); ▁( void ) BIO _ flu sh ( p 10 out ); ▁BIO _ get _ mem _ ptr ( p 10 out , ▁& bptr ); ▁/* ▁* ▁Get ▁the ▁buffer ▁in ▁which ▁to ▁place ▁the ▁entire ▁response ▁from ▁the ▁server ▁*/ ▁ recv _ buf ▁= ▁malloc ( EST _ CA _ MAX ); ▁if ▁( recv _ buf ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁allocate ▁buffer ▁for ▁server ▁response "); ▁return ▁EST _ ERR _ MALLOC ; ▁} ▁new _ cert _ buf ▁= ▁ recv _ buf ; ▁new _ cert _ buf _ len ▁= ▁0; ▁/* ▁* ▁Send ▁the ▁PKCS 10 ▁as ▁an ▁HTTP ▁request ▁to ▁the ▁EST ▁server ▁*/ ▁rv ▁= ▁est _ client _ send _ enroll _ request ( ctx , ▁ssl , ▁bptr , ▁new _ cert _ buf , ▁& new _ cert _ buf _ len , ▁reenroll ); ▁switch ▁( rv ) ▁{ ▁case ▁EST _ ERR _ NONE : ▁/* ▁* ▁Make ▁sure ▁that ▁even ▁though ▁we ▁got ▁a ▁success ▁return ▁code , ▁that ▁we ▁* ▁ actually ▁received ▁something ▁*/ ▁if ▁( new _ cert _ buf _ len ▁== ▁0) ▁{ ▁EST _ LOG _ ERR (" B uff er ▁containing ▁new ly ▁enrolled ▁client ▁certificate ▁is ▁zero ▁bytes ▁in ▁length "); ▁rv ▁= ▁EST _ ERR _ ZE RO _ LEN G TH _ BUF ; ▁break ; ▁} ▁/* ▁* ▁Re size ▁the ▁buffer ▁hold ing ▁the ▁retrieved ▁client ▁certificate ▁and ▁link ▁* ▁it ▁into ▁the ▁ctx . ▁Get ▁rid ▁of ▁the ▁http ▁hdr ▁and ▁any ▁extra ▁space ▁on ▁* ▁the ▁back . ▁*/ ▁if ▁( ctx -> enrolled _ client _ cert ▁ != ▁NULL ){ ▁free ( ctx -> enrolled _ client _ cert ); ▁} ▁ctx -> enrolled _ client _ cert ▁= ▁malloc ( new _ cert _ buf _ len +1 ); ▁if ▁( ctx -> enrolled _ client _ cert ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁allocate ▁new ly ▁enrolled ▁client ▁certificate ▁buffer "); ▁rv ▁= ▁EST _ ERR _ MALLOC ; ▁break ; ▁} ▁ctx -> enrolled _ client _ cert [ new _ cert _ buf _ len ] ▁= ▁'\0'; ▁memcpy _ s ( ctx -> enrolled _ client _ cert , ▁new _ cert _ buf _ len +1, ▁new _ cert _ buf , ▁new _ cert _ buf _ len ); ▁ctx -> enrolled _ client _ cert _ len ▁= ▁new _ cert _ buf _ len ; ▁/* ▁* ▁pass ▁back ▁the ▁length ▁of ▁this ▁new ly ▁enrolled ▁cert ▁*/ ▁* pkcs 7_ len ▁= ▁ctx -> enrolled _ client _ cert _ len ; ▁EST _ LOG _ INFO (" New ly ▁Enroll ed ▁Client ▁certificate : ▁% s ", ▁ctx -> enrolled _ client _ cert ); ▁EST _ LOG _ INFO (" length : ▁% d ", ▁ctx -> enrolled _ client _ cert _ len ); ▁break ; ▁case ▁EST _ ERR _ AUTH _ FAIL : ▁EST _ LOG _ INFO (" HTTP ▁Authorization ▁failed . ▁ Requested ▁auth ▁mode ▁= ▁% d ", ▁ctx -> auth _ mode ); ▁break ; ▁default : ▁EST _ LOG _ ERR (" EST ▁enrollment ▁failed , ▁error ▁code ▁is ▁% d ▁(% s )", ▁rv , ▁EST _ ERR _ NUM _ TO _ STR ( rv )); ▁break ; ▁} ▁if ▁( recv _ buf ) ▁{ ▁free ( recv _ buf ); ▁} ▁BIO _ free _ all ( p 10 out ); ▁return ▁( rv ); ▁} ▁/* ▁est _ client _ enroll _ pkcs 10 () ▁This ▁function ▁implement s ▁the ▁Simple ▁Enroll ▁* ▁flow . ▁It ▁sign s ▁the ▁CSR ▁that ▁was ▁provided ▁and ▁then ▁send s ▁the ▁CSR ▁* ▁to ▁the ▁EST ▁server ▁and ▁retrieve s ▁the ▁pkcs 7 ▁response . ▁* ▁* ▁ Parameters : ▁* ▁ctx ▁EST ▁context ▁* ▁ssl ▁SSL ▁context ▁being ▁used ▁for ▁this ▁EST ▁session ▁* ▁csr ▁ Pointer ▁to ▁X 509_ REQ ▁object ▁containing ▁the ▁PKCS 10 ▁CSR ▁* ▁pkcs 7_ len ▁pointer ▁to ▁an ▁integer ▁in ▁which ▁the ▁length ▁of ▁the ▁re c ie v ed ▁* ▁pkcs 7 ▁response ▁is ▁placed . ▁* ▁priv _ key ▁ Pointer ▁to ▁the ▁private ▁key ▁used ▁to ▁sign ▁the ▁CSR . ▁* ▁reenroll ▁Set ▁to ▁1 ▁to ▁do ▁a ▁reenroll ▁instead ▁of ▁an ▁enroll ▁* ▁* ▁Returns ▁EST _ ERROR ▁*/ ▁static ▁EST _ ERROR ▁est _ client _ enroll _ pkcs 10 ▁( EST _ CTX ▁* ctx , ▁SSL ▁* ssl , ▁X 509_ REQ ▁* csr , ▁int ▁* pkcs 7_ len , ▁E VP _ PKEY ▁* priv _ key , ▁int ▁reenroll ) ▁{ ▁EST _ ERROR ▁rv ▁= ▁EST _ ERR _ NONE ; ▁char ▁* tls _ uid ; ▁int ▁ossl _ rv ; ▁/* ▁* ▁Make ▁sure ▁the ▁PoP ▁is ▁removed ▁from ▁the ▁CSR ▁before ▁we ▁proceed ▁*/ ▁est _ client _ clear _ csr _ pop ( csr ); ▁/* ▁* ▁Get ▁the ▁PoP ▁value ▁from ▁the ▁TLS ▁session ▁and ▁ em b ed ▁this ▁into ▁* ▁the ▁CSR ▁if ▁required . ▁*/ ▁if ▁( ctx -> csr _ pop _ required ▁|| ▁ctx -> client _ force _ pop ) ▁{ ▁EST _ LOG _ INFO (" Client ▁will ▁include ▁ c hallengePassword ▁in ▁CSR "); ▁tls _ uid ▁= ▁est _ get _ tls _ uid ( ssl , ▁1); ▁if ▁( tls _ uid ) ▁{ ▁ossl _ rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ NID ( csr , ▁NID _ pkcs 9 _ c hallengePassword , ▁MB STRING _ ASC , ▁( un signed ▁char *) tls _ uid , ▁-1) ; ▁free ( tls _ uid ); ▁if ▁(! ossl _ rv ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁set ▁X 509 ▁ c hallengePassword ▁attribute "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁( EST _ ERR _ X 509_ ATTR ); ▁} ▁} ▁else ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁obtain ▁the ▁TLS ▁UID "); ▁return ▁( EST _ ERR _ AUTH _ FAIL _ TLSUID ); ▁} ▁} ▁/* ▁* ▁Sign ▁the ▁CSR ▁*/ ▁ossl _ rv ▁= ▁est _ client _ X 509_ REQ _ sign ( csr , ▁priv _ key , ▁ctx -> signing _ digest ); ▁if ▁(! ossl _ rv ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁sign ▁X 509 ▁cert ▁request "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁( EST _ ERR _ X 509_ SIGN ); ▁} ▁rv ▁= ▁est _ client _ enroll _ req ( ctx , ▁ssl , ▁csr , ▁pkcs 7_ len , ▁reenroll ); ▁return ▁( rv ); ▁} ▁/* ▁est _ client _ enroll _ cn () ▁This ▁function ▁implement s ▁the ▁Simple ▁Enroll ▁flow . ▁It ▁uses ▁the ▁private ▁key ▁to ▁generate ▁a ▁CSR ▁( pkcs 10) ▁request . ▁It ▁then ▁send s ▁the ▁request ▁to ▁the ▁EST ▁server ▁and ▁retrieve s ▁the ▁pkcs 7 ▁response . ▁The ▁user ▁of ▁this ▁function ▁simpl y ▁provide s ▁the ▁CommonName ▁value ▁to ▁be ▁placed ▁in ▁the ▁PKCS 10 ▁CSR . ▁This ▁is ▁a ▁simplifie d ▁interface , ▁none ▁of ▁the ▁other ▁CSR ▁attributes ▁can ▁be ▁specified . ▁@ param ▁ctx ▁EST ▁context ▁@ param ▁ssl ▁SSL ▁context ▁being ▁used ▁for ▁this ▁EST ▁session ▁@ param ▁cn ▁pointer ▁to ▁the ▁common ▁name ▁that ▁is ▁to ▁be ▁placed ▁in ▁the ▁x 509 ▁request ▁@ param ▁pkcs 7_ len ▁pointer ▁to ▁an ▁integer ▁in ▁which ▁the ▁length ▁of ▁the ▁re c ie v ed ▁pkcs 7 ▁response ▁is ▁placed . ▁@ param ▁pkey ▁The ▁new ▁client ▁public ▁key ▁that ▁is ▁to ▁be ▁enrolled ▁@ return ▁EST _ ERROR ▁*/ ▁static ▁EST _ ERROR ▁est _ client _ enroll _ cn ▁( EST _ CTX ▁* ctx , ▁SSL ▁* ssl , ▁char ▁* cn , ▁int ▁* pkcs 7_ len , ▁E VP _ PKEY ▁* pkey ) ▁{ ▁X 509_ REQ ▁* pkcs 10 ▁= ▁NULL ; ▁EST _ ERROR ▁rv ▁= ▁EST _ ERR _ NONE ; ▁char ▁* tls _ uid ; ▁if ▁(! ctx ) ▁{ ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁/* ▁* ▁Attempt ▁to ▁create ▁the ▁PKCS 10 ▁certificate ▁request . ▁* ▁Get ▁the ▁TLS ▁uid ▁in ▁case ▁we ▁need ▁it ▁dur ing ▁populate . ▁*/ ▁tls _ uid ▁= ▁est _ get _ tls _ uid ( ssl , ▁1); ▁if ▁( tls _ uid ) ▁{ ▁rv ▁= ▁est _ generate _ pkcs 10 ( ctx , ▁cn , ▁tls _ uid , ▁pkey , ▁& pkcs 10); ▁free ( tls _ uid ); ▁} ▁else ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁obtain ▁the ▁TLS ▁UID "); ▁rv ▁= ▁EST _ ERR _ AUTH _ FAIL _ TLSUID ; ▁} ▁if ▁( rv ▁== ▁EST _ ERR _ NONE ) ▁{ ▁rv ▁= ▁est _ client _ enroll _ req ( ctx , ▁ssl , ▁pkcs 10 , ▁pkcs 7_ len , ▁0); ▁} ▁if ▁( pkcs 10) ▁{ ▁X 509_ REQ _ free ( pkcs 10); ▁} ▁return ▁( rv ); ▁} ▁/* ▁* ▁The ▁following ▁function ▁was ▁taken ▁from ▁cURL ▁* ▁* ▁The ▁content ▁that ▁was ▁ incorporate d ▁we re ▁portion s ▁of ▁* ▁- ▁ lib / hostcheck . c ▁* ▁- ▁ lib / raw str . c ▁* ▁* ▁P or table , ▁consisten t ▁ toupper ▁( re member ▁ EB C DI C ) . ▁Do ▁not ▁use ▁ toupper () ▁because ▁* ▁its ▁behavio r ▁is ▁altered ▁by ▁the ▁current ▁locale . ▁*/ ▁static ▁char ▁est _ client _ Curl _ raw _ toupper ( char ▁in ) ▁{ ▁switch ▁( in ) ▁{ ▁case ▁' a ': ▁return ▁' A '; ▁case ▁' b ': ▁return ▁' B '; ▁case ▁' c ': ▁return ▁' C '; ▁case ▁' d ': ▁return ▁' D '; ▁case ▁' e ': ▁return ▁' E '; ▁case ▁' f ': ▁return ▁' F '; ▁case ▁' g ': ▁return ▁' G '; ▁case ▁' h ': ▁return ▁' H '; ▁case ▁' i ': ▁return ▁' I '; ▁case ▁' j ': ▁return ▁' J '; ▁case ▁' k ': ▁return ▁' K '; ▁case ▁' l ': ▁return ▁' L '; ▁case ▁' m ': ▁return ▁' M '; ▁case ▁' n ': ▁return ▁' N '; ▁case ▁' o ': ▁return ▁' O '; ▁case ▁' p ': ▁return ▁' P '; ▁case ▁' q ': ▁return ▁' Q '; ▁case ▁' r ': ▁return ▁' R '; ▁case ▁' s ': ▁return ▁' S '; ▁case ▁' t ': ▁return ▁' T '; ▁case ▁' u ': ▁return ▁' U '; ▁case ▁' v ': ▁return ▁' V '; ▁case ▁' w ': ▁return ▁' W '; ▁case ▁' x ': ▁return ▁' X '; ▁case ▁' y ': ▁return ▁' Y '; ▁case ▁' z ': ▁return ▁' Z '; ▁} ▁return ▁in ; ▁} ▁/* ▁* ▁The ▁following ▁function ▁was ▁taken ▁from ▁cURL ▁* ▁* ▁Curl _ raw _ equal () ▁is ▁for ▁do ing ▁" raw " ▁case ▁insensitive ▁strings . ▁This ▁is ▁mean t ▁* ▁to ▁be ▁locale ▁in depend ent ▁and ▁only ▁compare ▁strings ▁we ▁know ▁are ▁safe ▁for ▁* ▁this . ▁Se e ▁http :// dan iel . ha xx . se / b log /2008 / 10 / 15 / strcasecmp - in - tur ki sh / ▁for ▁* ▁some ▁f ur ther ▁explanat ion ▁to ▁wh y ▁this ▁function ▁is ▁necessary . ▁* ▁* ▁The ▁function ▁is ▁capab le ▁of ▁compar ing ▁a - z ▁case ▁insensitive ly ▁even ▁for ▁* ▁non - a sc i i . ▁*/ ▁static ▁int ▁est _ client _ Curl _ raw _ equal ( const ▁char ▁* first , ▁const ▁char ▁* second ) ▁{ ▁while (* first ▁&& ▁* second ) ▁{ ▁if ( est _ client _ Curl _ raw _ toupper (* first ) ▁ != ▁est _ client _ Curl _ raw _ toupper (* second )) ▁{ ▁/* ▁get ▁out ▁of ▁the ▁loo p ▁as ▁soon ▁as ▁they ▁don ' t ▁match ▁*/ ▁break ; ▁} ▁first ++; ▁second ++; ▁} ▁/* ▁we ▁do ▁the ▁comparison ▁here ▁( possibly ▁again ) , ▁just ▁to ▁make ▁sure ▁that ▁if ▁the ▁loo p ▁above ▁is ▁skip p ed ▁because ▁one ▁of ▁the ▁strings ▁reach ed ▁zero , ▁we ▁must ▁not ▁return ▁this ▁as ▁a ▁successful ▁match ▁*/ ▁return ▁( est _ client _ Curl _ raw _ toupper (* first ) ▁== ▁est _ client _ Curl _ raw _ toupper (* second )); ▁} ▁/* ▁* ▁The ▁following ▁function ▁was ▁taken ▁from ▁cURL ▁* ▁* ▁Curl _ raw _ equal () ▁is ▁for ▁do ing ▁" raw " ▁case ▁insensitive ▁strings . ▁This ▁is ▁mean t ▁* ▁to ▁be ▁locale ▁in depend ent ▁and ▁only ▁compare ▁strings ▁we ▁know ▁are ▁safe ▁for ▁* ▁this . ▁Se e ▁http :// dan iel . ha xx . se / b log /2008 / 10 / 15 / strcasecmp - in - tur ki sh / ▁for ▁* ▁some ▁f ur ther ▁explanat ion ▁to ▁wh y ▁this ▁function ▁is ▁necessary . ▁* ▁* ▁The ▁function ▁is ▁capab le ▁of ▁compar ing ▁a - z ▁case ▁insensitive ly ▁even ▁for ▁* ▁non - a sc i i . ▁*/ ▁static ▁int ▁est _ client _ Curl _ raw _ n equal ( const ▁char ▁* first , ▁const ▁char ▁* second , ▁size _ t ▁max ) ▁{ ▁while (* first ▁&& ▁* second ▁&& ▁max ) ▁{ ▁if ( est _ client _ Curl _ raw _ toupper (* first ) ▁ != ▁est _ client _ Curl _ raw _ toupper (* second )) ▁{ ▁break ; ▁} ▁max -- ; ▁first ++; ▁second ++; ▁} ▁if ( 0 ▁== ▁max ) ▁{ ▁return ▁1; ▁/* ▁they ▁are ▁equal ▁this ▁far ▁*/ ▁} ▁return ▁( est _ client _ Curl _ raw _ toupper (* first ) ▁== ▁est _ client _ Curl _ raw _ toupper (* second )); ▁} ▁/* ▁* ▁The ▁following ▁function ▁was ▁taken ▁from ▁cURL ▁* ▁* ▁Curl _ raw _ equal () ▁is ▁for ▁do ing ▁" raw " ▁case ▁insensitive ▁strings . ▁This ▁is ▁mean t ▁* ▁to ▁be ▁locale ▁in depend ent ▁and ▁only ▁compare ▁strings ▁we ▁know ▁are ▁safe ▁for ▁* ▁this . ▁Se e ▁http :// dan iel . ha xx . se / b log /2008 / 10 / 15 / strcasecmp - in - tur ki sh / ▁for ▁* ▁some ▁f ur ther ▁explanat ion ▁to ▁wh y ▁this ▁function ▁is ▁necessary . ▁* ▁* ▁The ▁function ▁is ▁capab le ▁of ▁compar ing ▁a - z ▁case ▁insensitive ly ▁even ▁for ▁* ▁non - a sc i i . ▁*/ ▁static ▁int ▁est _ client _ host match ( const ▁char ▁* hostname , ▁const ▁char ▁* pattern ) ▁{ ▁const ▁char ▁* pattern _ label _ end , ▁* pattern _ wildcard , ▁* hostname _ label _ end ; ▁int ▁wildcard _ enabled ; ▁size _ t ▁prefix len , ▁suffixlen ; ▁struct ▁in _ addr ▁ignored ; ▁struct ▁sockaddr _ in 6 ▁ s i 6 ; ▁pattern _ wildcard ▁= ▁str chr ( pattern , ▁' * '); ▁if ( pattern _ wildcard ▁== ▁NULL ) ▁{ ▁return ▁est _ client _ Curl _ raw _ equal ( pattern , ▁hostname ) ▁? ▁ HOST _ MATCH ▁: ▁ HOST _ NOMATCH ; ▁} ▁/* ▁de te ct ▁IP ▁address ▁as ▁hostname ▁and ▁fail ▁the ▁match ▁if ▁so ▁*/ ▁if ( i net _ p ton ( AF _ INET , ▁hostname , ▁& i gnore d ) ▁> ▁0) ▁return ▁ HOST _ NOMATCH ; ▁else ▁if ( i net _ p ton ( AF _ INET 6, ▁hostname , ▁& s i 6 . sin 6 _ addr ) ▁> ▁0) ▁return ▁ HOST _ NOMATCH ; ▁/* ▁We ▁require ▁at ▁least ▁2 ▁ dots ▁in ▁pattern ▁to ▁a void ▁too ▁wid e ▁wildcard ▁match . ▁*/ ▁wildcard _ enabled ▁= ▁1; ▁pattern _ label _ end ▁= ▁str chr ( pattern , ▁'.') ; ▁if ( pattern _ label _ end ▁== ▁NULL ▁|| ▁str chr ( pattern _ label _ end +1, ▁'.') ▁== ▁NULL ▁|| ▁pattern _ wildcard ▁> ▁pattern _ label _ end ▁|| ▁est _ client _ Curl _ raw _ n equal ( pattern , ▁" x n -- ", ▁ 4)) ▁{ ▁wildcard _ enabled ▁= ▁0; ▁} ▁if (! wildcard _ enabled ) ▁{ ▁return ▁est _ client _ Curl _ raw _ equal ( pattern , ▁hostname ) ▁? ▁ HOST _ MATCH ▁: ▁ HOST _ NOMATCH ; ▁} ▁hostname _ label _ end ▁= ▁str chr ( hostname , ▁'.') ; ▁if ( hostname _ label _ end ▁== ▁NULL ▁|| ▁! est _ client _ Curl _ raw _ equal ( pattern _ label _ end , ▁hostname _ label _ end )) ▁{ ▁return ▁ HOST _ NOMATCH ; ▁} ▁/* ▁The ▁wildcard ▁must ▁match ▁at ▁least ▁one ▁character , ▁so ▁the ▁left - most ▁label ▁of ▁the ▁hostname ▁is ▁at ▁least ▁as ▁large ▁as ▁the ▁left - most ▁label ▁of ▁the ▁pattern . ▁*/ ▁if ( hostname _ label _ end ▁- ▁hostname ▁< ▁pattern _ label _ end ▁- ▁pattern ) ▁{ ▁return ▁ HOST _ NOMATCH ; ▁} ▁prefix len ▁= ▁pattern _ wildcard ▁- ▁pattern ; ▁suffixlen ▁= ▁pattern _ label _ end ▁- ▁( pattern _ wildcard +1 ); ▁return ▁( est _ client _ Curl _ raw _ n equal ( pattern , ▁hostname , ▁prefix len ) ▁&& ▁est _ client _ Curl _ raw _ n equal ( pattern _ wildcard +1, ▁hostname _ label _ end ▁- ▁suffixlen , ▁suffixlen ) ▁? ▁ HOST _ MATCH ▁: ▁ HOST _ NOMATCH ); ▁} ▁/* ▁* ▁The ▁following ▁function ▁was ▁taken ▁from ▁cURL ▁for ▁the ▁* ▁ FQDN ▁check ▁on ▁the ▁server ▁cert ▁*/ ▁static ▁int ▁est _ client _ cert _ hostcheck ( const ▁char ▁* match _ pattern , ▁const ▁char ▁* hostname ) ▁{ ▁/* ▁* ▁ Sanity ▁check ▁input ▁*/ ▁if (! match _ pattern ▁|| ▁!* match _ pattern ▁|| ▁! hostname ▁|| ▁!* hostname ) ▁{ ▁return ▁0; ▁} ▁/* ▁* ▁tri val ▁case ▁*/ ▁if ( est _ client _ Curl _ raw _ equal ( hostname , ▁match _ pattern )) ▁{ ▁return ▁1; ▁} ▁if ( est _ client _ host match ( hostname , match _ pattern ) ▁== ▁ HOST _ MATCH ) ▁{ ▁return ▁1; ▁} ▁return ▁0; ▁} ▁/* ▁* ▁This ▁function ▁was ▁taken ▁from ▁cURL ▁and ▁a d apt ed ▁to ▁EST . ▁* ▁* ▁cURL ▁file ▁name ▁is ▁ . / lib / ssl use . c , ▁function : ▁ verifyhost () ▁* ▁* ▁ Qu o te ▁from ▁RFC 2818 ▁section ▁3.1 ▁" Server ▁Identity " ▁If ▁a ▁ subjectAltName ▁extension ▁of ▁type ▁d NS Name ▁is ▁present , ▁that ▁MUST ▁be ▁used ▁as ▁the ▁identity . ▁Otherwise , ▁the ▁( most ▁specific ) ▁Common ▁Name ▁field ▁in ▁the ▁Subject ▁field ▁of ▁the ▁certificate ▁MUST ▁be ▁used . ▁A l th ou g h ▁the ▁use ▁of ▁the ▁Common ▁Name ▁is ▁existing ▁practice , ▁it ▁is ▁deprecated ▁and ▁Certification ▁Authorit ies ▁are ▁e nc ou ra g ed ▁to ▁use ▁the ▁d NS Name ▁instead . ▁M atch ing ▁is ▁performed ▁using ▁the ▁match ing ▁rules ▁specified ▁by ▁[ RFC 2 45 9 ] . ▁If ▁more ▁than ▁one ▁identity ▁of ▁a ▁given ▁type ▁is ▁present ▁in ▁the ▁certificate ▁( e . g . , ▁more ▁than ▁one ▁d NS Name ▁name , ▁a ▁match ▁in ▁any ▁one ▁of ▁the ▁set ▁is ▁con side r ed ▁acceptable . ) ▁Name s ▁ma y ▁contain ▁the ▁wildcard ▁character ▁* ▁which ▁is ▁con side r ed ▁to ▁match ▁any ▁single ▁do main ▁name ▁component ▁or ▁component ▁f ra g ment . ▁E . g . , ▁* . a . com ▁matches ▁ foo . a . com ▁but ▁not ▁bar . foo . a . com . ▁f * . com ▁matches ▁ foo . com ▁but ▁not ▁bar . com . ▁In ▁some ▁cases , ▁the ▁URI ▁is ▁specified ▁as ▁an ▁IP ▁address ▁r ather ▁than ▁a ▁hostname . ▁In ▁this ▁case , ▁the ▁i P Address ▁ subjectAltName ▁must ▁be ▁present ▁in ▁the ▁certificate ▁and ▁must ▁exact ly ▁match ▁the ▁IP ▁in ▁the ▁URI . ▁*/ ▁static ▁EST _ ERROR ▁est _ client _ verifyhost ▁( char ▁* hostname , ▁X 509 ▁* server _ cert ) ▁{ ▁int ▁matched ▁= ▁-1; ▁/* ▁-1 ▁is ▁no ▁alternative ▁match ▁yet , ▁1 ▁means ▁match ▁and ▁0 ▁means ▁mismatch ▁*/ ▁size _ t ▁addrlen ▁= ▁0; ▁STA CK _ OF ( GENERA L _ NAME ) ▁* ▁ altnames ; ▁struct ▁in 6 _ addr ▁addr _ v 6 ; ▁struct ▁in _ addr ▁addr _ v 4 ; ▁int ▁addr _ is _ v 4 ▁= ▁0; ▁int ▁addr _ is _ v 6 ▁= ▁0; ▁EST _ ERROR ▁res ▁= ▁EST _ ERR _ NONE ; ▁int ▁rv ; ▁errno _ t ▁safe c _ rc ; ▁int ▁numalts ; ▁int ▁i , ▁j ; ▁int ▁diff ; ▁const ▁GENERA L _ NAME ▁* check ; ▁const ▁char ▁* altptr ; ▁size _ t ▁altlen ; ▁un signed ▁char ▁* n ul str ; ▁un signed ▁char ▁* peer _ CN ; ▁X 509_ NAME ▁* name ; ▁ASN 1 _ STRING ▁* tmp ; ▁/* ▁* ▁Attempt ▁to ▁resolve ▁host ▁name ▁to ▁v 4 ▁address ▁*/ ▁rv ▁= ▁in et _ p ton ( AF _ INET , ▁hostname , ▁& addr _ v 4 ); ▁if ▁( rv ) ▁{ ▁addr _ is _ v 4 ▁= ▁1; ▁addrlen ▁= ▁sizeof ( struct ▁in _ addr ); ▁} ▁else ▁{ ▁/* ▁* ▁T ry ▁to ▁see ▁if ▁hostname ▁resolve s ▁to ▁v 6 ▁address ▁*/ ▁rv ▁= ▁in et _ p ton ( AF _ INET 6, ▁hostname , ▁& addr _ v 6 ); ▁if ▁( rv ) ▁{ ▁addr _ is _ v 6 ▁= ▁1; ▁addrlen ▁= ▁sizeof ( struct ▁in 6 _ addr ); ▁} ▁} ▁/* ▁get ▁a ▁" list " ▁of ▁alternative ▁names ▁*/ ▁ altnames ▁= ▁X 509_ get _ ext _ d 2 i ( server _ cert , ▁NID _ subject _ alt _ name , ▁NULL , ▁NULL ); ▁if ▁( altnames ) ▁{ ▁/* ▁get ▁amount ▁of ▁alternative s , ▁RFC 2 45 9 ▁cl a im s ▁there ▁MUST ▁be ▁at ▁least ▁one , ▁but ▁we ▁don ' t ▁depend ▁on ▁it . . . ▁*/ ▁numalts ▁= ▁sk _ GENERA L _ NAME _ num ( altnames ); ▁EST _ LOG _ INFO (" Found ▁% d ▁Subject A l ter n ate Name s ", ▁numalts ); ▁/* ▁loo p ▁through ▁all ▁alternative s ▁while ▁none ▁has ▁matched ▁*/ ▁for ▁( i ▁= ▁0; ▁( i ▁< ▁numalts ) ▁&& ▁( matched ▁ != ▁1); ▁i ++) ▁{ ▁/* ▁get ▁a ▁handle ▁to ▁alternative ▁name ▁number ▁i ▁*/ ▁check ▁= ▁sk _ GENERA L _ NAME _ value ( altnames , ▁i ); ▁/* ▁get ▁data ▁and ▁length ▁*/ ▁ altptr ▁= ▁( char *) ASN 1 _ STRING _ data ( check -> d . ia 5 ); ▁altlen ▁= ▁( size _ t ) ASN 1 _ STRING _ length ( check -> d . ia 5 ); ▁switch ▁( check -> type ) ▁{ ▁case ▁ GE N _ DNS : ▁/* ▁name / pattern ▁comparison ▁*/ ▁EST _ LOG _ INFO (" Check ing ▁ FQDN ▁against ▁SAN ▁% s ", ▁ altptr ); ▁/* ▁The ▁OpenSSL ▁ma n ▁page ▁explicit ly ▁say s : ▁" In ▁general ▁it ▁cannot ▁be ▁assume d ▁that ▁the ▁data ▁returned ▁by ▁ASN 1 _ STRING _ data () ▁is ▁null ▁terminated ▁or ▁does ▁not ▁contain ▁embedd ed ▁null s . " ▁ But ▁also ▁that ▁" The ▁actual ▁format ▁of ▁the ▁data ▁will ▁depend ▁on ▁the ▁actual ▁string ▁type ▁itself : ▁for ▁example ▁for ▁and ▁ IA 5 String ▁the ▁data ▁will ▁be ▁ASCII " ▁G is le ▁re search ed ▁the ▁OpenSSL ▁source s : ▁" I ▁checked ▁the ▁0.9 . 6 ▁and ▁0.9 . 8 ▁source s ▁before ▁my ▁p atch ▁and ▁it ▁al way s ▁0 - ter min ate s ▁an ▁ IA 5 String . " ▁*/ ▁if ▁( ( alt len ▁== ▁ strnlen _ s ( altptr , ▁EST _ MAX _ SERVER NAME _ LEN )) ▁&& ▁/* ▁if ▁this ▁is n ' t ▁true , ▁there ▁was ▁an ▁embedd ed ▁zero ▁in ▁the ▁name ▁string ▁and ▁we ▁cannot ▁match ▁it . ▁*/ ▁est _ client _ cert _ hostcheck ( altptr , ▁hostname )) ▁{ ▁matched ▁= ▁1; ▁} ▁else { ▁matched ▁= ▁0; ▁} ▁break ; ▁case ▁ GE N _ IP ADD : ▁/* ▁IP ▁address ▁comparison ▁*/ ▁/* ▁compare ▁alternative ▁IP ▁address ▁if ▁the ▁data ▁ c hu nk ▁is ▁the ▁same ▁size ▁our ▁server ▁IP ▁address ▁is ▁*/ ▁/* ▁* ▁For ▁P S B ▁compl i ance , ▁use ▁S a f e C ▁library ▁mem cmp _ s ▁*/ ▁if ▁( addr _ is _ v 4 ) ▁{ ▁safe c _ rc ▁= ▁mem cmp _ s ( altptr , ▁altlen , ▁& addr _ v 4, ▁altlen , ▁& diff ); ▁if ▁( safe c _ rc ▁ != ▁EOK ) ▁{ ▁EST _ LOG _ INFO (" mem cmp _ s ▁error ▁0 x % xO ▁with ▁IPv 4 ▁address \ n ", ▁safe c _ rc ); ▁} ▁} ▁else ▁if ▁( addr _ is _ v 6 ) ▁{ ▁safe c _ rc ▁= ▁mem cmp _ s ( altptr , ▁altlen , ▁& addr _ v 6, ▁altlen , ▁& diff ); ▁if ▁( safe c _ rc ▁ != ▁EOK ) ▁{ ▁EST _ LOG _ INFO (" mem cmp _ s ▁error ▁0 x % xO ▁with ▁IPv 6 ▁address \ n ", ▁safe c _ rc ); ▁} ▁} ▁else ▁{ ▁/* ▁* ▁Should ▁n ever ▁get ▁here . . . s o ▁force ▁matched ▁to ▁be ▁0 ▁*/ ▁diff ▁= ▁-1; ▁} ▁if ▁( ( addr _ is _ v 4 ) ▁&& ▁( alt len ▁== ▁addrlen ) ▁&& ▁! diff ) ▁{ ▁matched ▁= ▁1; ▁} ▁else ▁if ▁( ( addr _ is _ v 6 ) ▁&& ▁( alt len ▁== ▁addrlen ) ▁&& ▁! diff ) ▁{ ▁matched ▁= ▁1; ▁} ▁else { ▁matched ▁= ▁0; ▁} ▁break ; ▁} ▁} ▁GENERA L _ NAME S _ free ( altnames ); ▁} ▁if ▁( matched ▁== ▁1) ▁{ ▁/* ▁an ▁alternative ▁name ▁matched ▁the ▁server ▁hostname ▁*/ ▁EST _ LOG _ INFO (" subjectAltName : ▁% s ▁matched \ n ", ▁hostname ); ▁} ▁else ▁if ▁( matched ▁== ▁0) ▁{ ▁/* ▁an ▁alternative ▁name ▁field ▁exist ed , ▁but ▁did n ' t ▁match ▁and ▁then ▁we ▁MUST ▁fail ▁*/ ▁EST _ LOG _ INFO (" subjectAltName ▁does ▁not ▁match ▁% s \ n ", ▁hostname ); ▁res ▁= ▁EST _ ERR _ FQDN _ MISMATCH ; ▁} else ▁{ ▁/* ▁we ▁have ▁to ▁look ▁to ▁the ▁last ▁occur re nc e ▁of ▁a ▁common Name ▁in ▁the ▁dis ting u ished ▁one ▁to ▁get ▁the ▁most ▁signifi c ant ▁one . ▁*/ ▁i ▁= ▁-1; ▁/* ▁The ▁following ▁is ▁done ▁because ▁of ▁a ▁bug ▁in ▁0.9 . 6 b ▁*/ ▁n ul str ▁= ▁( un signed ▁char *) " "; ▁peer _ CN ▁= ▁n ul str ; ▁name ▁= ▁X 509_ get _ subject _ name ( server _ cert ); ▁if ▁( name ) ▁{ ▁while ▁( ( j ▁= ▁X 509_ NAME _ get _ index _ by _ NID ( name , ▁NID _ common Name , ▁i )) ▁>= ▁0) ▁{ ▁i ▁= ▁j ; ▁} ▁} ▁/* ▁we ▁have ▁the ▁name ▁entry ▁and ▁we ▁will ▁now ▁convert ▁this ▁to ▁a ▁string ▁that ▁we ▁can ▁use ▁for ▁comparison . ▁Do ing ▁this ▁we ▁support ▁B M P string , ▁ UTF 8 ▁etc . ▁*/ ▁if ▁( i ▁>= ▁0) ▁{ ▁ tmp ▁= ▁X 509_ NAME _ ENT RY _ get _ data ( X 509_ NAME _ get _ entry ( name , ▁i )); ▁/* ▁In ▁OpenSSL ▁0.9 . 7 d ▁and ▁earlier , ▁ASN 1 _ STRING _ to _ UTF 8 ▁fails ▁if ▁the ▁input ▁is ▁already ▁ UTF - 8 ▁encoded . ▁We ▁check ▁for ▁this ▁case ▁and ▁copy ▁the ▁raw ▁string ▁manually ▁to ▁a void ▁the ▁problem . ▁This ▁code ▁can ▁be ▁made ▁condition al ▁in ▁the ▁future ▁when ▁OpenSSL ▁has ▁been ▁fixed . ▁W ork - a round ▁ br ou g ht ▁by ▁A le x is ▁S . ▁L . ▁Car val h o . ▁*/ ▁if ▁( tmp ) ▁{ ▁if ▁( ASN 1 _ STRING _ type ( tmp ) ▁== ▁V _ ASN 1 _ UTF 8 STRING ) ▁{ ▁j ▁= ▁ASN 1 _ STRING _ length ( tmp ); ▁if ▁( j ▁>= ▁0) ▁{ ▁peer _ CN ▁= ▁malloc ( j ▁+ ▁1); ▁if ▁( peer _ CN ) ▁{ ▁safe c _ rc ▁= ▁memcpy _ s ( peer _ CN , ▁j , ▁ASN 1 _ STRING _ data ( tmp ) , ▁j ); ▁if ▁( safe c _ rc ▁ != ▁EOK ) ▁{ ▁EST _ LOG _ INFO (" mem c py _ s ▁error ▁0 x % xO ▁with ▁ASN 1 ▁string \ n ", ▁safe c _ rc ); ▁} ▁peer _ CN [ j ] ▁= ▁'\0'; ▁} ▁} ▁} else ▁{ ▁/* ▁not ▁a ▁ UTF 8 ▁name ▁*/ ▁j ▁= ▁ASN 1 _ STRING _ to _ UTF 8 (& peer _ CN , ▁ tmp ); ▁} ▁if ▁( peer _ CN ▁&& ▁( strnlen _ s ( ( char *) peer _ CN , ▁EST _ MAX _ SERVER NAME _ LEN ) ▁ != ▁j )) ▁{ ▁/* ▁there ▁was ▁a ▁terminat ing ▁zero ▁before ▁the ▁end ▁of ▁string , ▁this ▁cannot ▁match ▁and ▁we ▁return ▁failure ! ▁*/ ▁EST _ LOG _ WARN (" SSL : ▁illegal ▁cert ▁name ▁field "); ▁res ▁= ▁EST _ ERR _ FQDN _ MISMATCH ; ▁} ▁} ▁} ▁if ▁( peer _ CN ▁== ▁n ul str ) ▁{ ▁peer _ CN ▁= ▁NULL ; ▁} ▁else { ▁/* ▁convert ▁peer _ CN ▁from ▁ UTF 8 ▁*/ ▁# if ▁0 ▁// ▁ UTF 8 ▁currently ▁not ▁supported ▁in ▁the ▁first ▁release ▁of ▁libest ▁CURL code ▁rc ▁= ▁Curl _ convert _ from _ ut f 8 ( data , ▁peer _ CN , ▁str len ( peer _ CN )); ▁/* ▁Curl _ convert _ from _ ut f 8 ▁calls ▁fail f ▁if ▁un success f ul ▁*/ ▁if ▁( rc ) ▁{ ▁free ( peer _ CN ); ▁return ▁EST _ ERR _ FQDN _ MISMATCH ; ▁} ▁# endif ▁} ▁if ▁( re s ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁/* ▁error ▁already ▁de te ct ed , ▁pass ▁through ▁*/ ▁ ; ▁} ▁else ▁if ▁(! peer _ CN ) ▁{ ▁EST _ LOG _ WARN (" SSL : ▁un able ▁to ▁obtain ▁common ▁name ▁from ▁peer ▁certificate "); ▁res ▁= ▁EST _ ERR _ FQDN _ MISMATCH ; ▁} else ▁if ▁(! est _ client _ cert _ hostcheck ( ( const ▁char *) peer _ CN , ▁hostname )) ▁{ ▁EST _ LOG _ WARN (" SSL : ▁ FQDN ▁hostname ▁mismatch ▁in ▁server ▁certificate , ▁'% s ' ▁does ▁not ▁match ▁" ▁" target ▁host ▁name ▁'% s ' ", ▁peer _ CN , ▁hostname ); ▁res ▁= ▁EST _ ERR _ FQDN _ MISMATCH ; ▁} else ▁{ ▁EST _ LOG _ INFO (" common ▁name : ▁% s ▁( matched )", ▁peer _ CN ); ▁} ▁if ▁( peer _ CN ) ▁{ ▁free ( peer _ CN ); ▁} ▁} ▁return ▁res ; ▁} ▁/* ▁* ▁This ▁routine ▁checks ▁the ▁ FQDN ▁in ▁the ▁server ▁certificate ▁* ▁against ▁the ▁configure ▁server ▁name ▁used ▁to ▁establish ▁* ▁the ▁TCP ▁connection ▁with ▁the ▁EST ▁server . ▁* ▁This ▁is ▁required ▁per ▁section ▁3.6 ▁in ▁the ▁EST ▁spec . ▁* ▁Note , ▁we ▁only ▁do ▁the ▁ FQDN ▁check ▁as ▁defined ▁in ▁RFC ▁ 6125 . ▁* ▁We ▁do ▁not ▁look ▁for ▁the ▁id - kp - cmcRA ▁e xtended ▁key ▁usage ▁* ▁extension ▁in ▁the ▁server ▁cert . ▁W h i le ▁this ▁is ▁more ▁* ▁ restrict ive ▁by ▁not ▁allowing ▁ FQDN ▁mismatch es ▁when ▁the ▁* ▁id - kp - cmcRA ▁is ▁present , ▁we ▁currently ▁have ▁no ▁way ▁to ▁* ▁determine ▁when ▁we ' re ▁using ▁the ▁explicit ▁trust ▁anchor ▁to ▁* ▁allow ▁this ▁additional ▁f le x i bi l ity . ▁*/ ▁static ▁EST _ ERROR ▁est _ client _ check _ f qd n ▁( EST _ CTX ▁* ctx , ▁SSL ▁* ssl ) ▁{ ▁X 509 ▁* cert ; ▁EST _ ERROR ▁ er ; ▁cert ▁= ▁SSL _ get _ peer _ certificate ( ssl ); ▁if ▁( cert ) ▁{ ▁ er ▁= ▁est _ client _ verifyhost ( ctx -> est _ server , ▁cert ); ▁X 509_ free ( cert ); ▁return ▁( er ); ▁} ▁else ▁if ▁(! cert ▁&& ▁ctx -> enable _ srp ) ▁{ ▁EST _ LOG _ INFO (" No ▁peer ▁certificate , ▁skip p ing ▁ FQDN ▁check ▁since ▁SRP ▁is ▁enabled . "); ▁return ▁EST _ ERR _ NONE ; ▁} ▁else ▁{ ▁EST _ LOG _ WARN (" U nable ▁to ▁perform ▁ FQDN ▁check , ▁no ▁peer ▁certificate . "); ▁return ▁EST _ ERR _ FQDN _ MISMATCH ; ▁} ▁} ▁/* ▁* ▁This ▁function ▁will ▁open ▁a ▁TCP ▁socket ▁and ▁establish ▁a ▁TLS ▁session ▁* ▁with ▁the ▁EST ▁server . ▁This ▁should ▁be ▁called ▁after ▁est _ client _ init (). ▁* ▁* ▁ Parameters : ▁* ▁ctx : ▁ Pointer ▁to ▁EST ▁context ▁for ▁client ▁session ▁* ▁ssl : ▁pointer ▁to ▁an ▁SSL ▁context ▁structure ▁to ▁return ▁the ▁* ▁SSL ▁context ▁created , ▁* ▁Re urn s : ▁* ▁EST _ ERR _ NONE ▁if ▁success ▁*/ ▁EST _ ERROR ▁est _ client _ connect ▁( EST _ CTX ▁* ctx , ▁SSL ▁** ssl ) ▁{ ▁BIO ▁* tcp ; ▁SSL _ CTX ▁* s _ ctx ; ▁EST _ ERROR ▁rv ▁= ▁EST _ ERR _ NONE ; ▁# if ndef ▁WI N 32 ▁int ▁sock ; ▁# else ▁ SOCKET ▁sock ▁= ▁ INVALID _ SOCKET ; ▁# endif ▁int ▁rc ; ▁int ▁ oval ▁= ▁1; ▁int ▁ssl _ connect _ ret ▁= ▁-1; ▁t cw _ err _ t ▁t cw _ err ; ▁t cw _ opts _ t ▁t cw _ opts ▁= ▁{ ▁0 ▁} ; ▁if ▁(! ctx ) ▁{ ▁return ▁EST _ ERR _ NO _ CTX ; ▁} ▁ s _ ctx ▁= ▁ctx -> ssl _ ctx ; ▁/* ▁* ▁E stablish ▁the ▁connection ▁through ▁a ▁proxy ▁( if ▁applicable ) ▁*/ ▁if ▁( ctx -> use _ proxy ) ▁{ ▁t cw _ opts . proxy _ proto ▁= ▁ctx -> proxy _ proto ; ▁t cw _ opts . proxy _ host ▁= ▁ctx -> proxy _ server ; ▁t cw _ opts . proxy _ port ▁= ▁ctx -> proxy _ port ; ▁if ▁( ctx -> proxy _ username [0 ] ▁&& ▁ctx -> proxy _ password [0 ] ▁&& ▁ctx -> proxy _ auth ▁ != ▁EST _ CLIENT _ PROXY _ AUTH _ NONE ) ▁{ ▁t cw _ opts . proxy _ username ▁= ▁ctx -> proxy _ username ; ▁t cw _ opts . proxy _ password ▁= ▁ctx -> proxy _ password ; ▁t cw _ opts . proxy _ auth ▁= ▁0; ▁/* ▁initialize ▁*/ ▁if ▁( ctx -> proxy _ auth ▁& ▁EST _ CLIENT _ PROXY _ AUTH _ BASIC ) ▁{ ▁t cw _ opts . proxy _ auth ▁| = ▁EST _ CLIENT _ PROXY _ AUTH _ BASIC ; ▁} ▁if ▁( ctx -> proxy _ auth ▁& ▁EST _ CLIENT _ PROXY _ AUTH _ NTLM ) ▁{ ▁t cw _ opts . proxy _ auth ▁| = ▁EST _ CLIENT _ PROXY _ AUTH _ NTLM ; ▁} ▁} ▁} ▁else ▁{ ▁t cw _ opts . proxy _ proto ▁= ▁EST _ CLIENT _ PROXY _ NONE ; ▁} ▁t cw _ err ▁= ▁t cw _ connect (& ctx -> t cw _ sock , ▁& t cw _ opts , ▁ctx -> est _ server , ▁ctx -> est _ port _ num , ▁& sock ); ▁if ▁( t cw _ err ▁== ▁TC W _ ERR _ RESOLV ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁lookup ▁hostname ▁% s . ", ▁ctx -> est _ server ); ▁return ▁( EST _ ERR _ IP _ GETADDR ); ▁} ▁if ▁( t cw _ err ▁ != ▁TC W _ OK ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁connect ▁to ▁EST ▁server ▁at ▁% s ", ▁ctx -> est _ server ); ▁return ▁( EST _ ERR _ IP _ CONNECT ); ▁} ▁/* ▁* ▁E nable ▁TCP ▁keep - alive ▁*/ ▁rc ▁= ▁set sock opt ( sock , ▁ SOL _ SOCKET , S O _ K EEP AL I VE , ▁( char ▁ *)& oval , ▁sizeof ( oval )); ▁if ▁( rc ▁< ▁0) ▁{ ▁t cw _ close (& ctx -> t cw _ sock ); ▁sock ▁= ▁SOCK _ INVALID ; ▁EST _ LOG _ ERR (" U nable ▁to ▁connect ▁to ▁EST ▁server ▁at ▁address ▁% s ", ▁ctx -> est _ server ); ▁return ▁( EST _ ERR _ IP _ CONNECT ); ▁} ▁/* ▁* ▁Pass ▁the ▁socket ▁to ▁the ▁BIO ▁interface , ▁which ▁OpenSSL ▁uses ▁* ▁to ▁create ▁the ▁TLS ▁session . ▁*/ ▁ tcp ▁= ▁BIO _ new _ socket ( sock , ▁BIO _ NO CLOSE ); ▁if ▁( tcp ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" Error ▁creating ▁IP ▁socket "); ▁t cw _ close (& ctx -> t cw _ sock ); ▁sock ▁= ▁SOCK _ INVALID ; ▁ossl _ dump _ ssl _ errors (); ▁return ▁( EST _ ERR _ IP _ CONNECT ); ▁} ▁if ▁(! (* ssl ▁= ▁SSL _ new ( s _ ctx ))) ▁{ ▁EST _ LOG _ ERR (" Error ▁creating ▁TLS ▁context "); ▁ossl _ dump _ ssl _ errors (); ▁BIO _ free _ all ( tcp ); ▁t cw _ close (& ctx -> t cw _ sock ); ▁sock ▁= ▁SOCK _ INVALID ; ▁return ▁( EST _ ERR _ SSL _ NEW ); ▁} ▁/* ▁* ▁Need ▁to ▁set ▁the ▁EST ▁ctx ▁into ▁the ▁ exdata ▁of ▁the ▁SSL ▁session ▁context ▁so ▁* ▁that ▁it ▁can ▁be ▁retrieved ▁on ▁a ▁per ▁session ▁basis . ▁*/ ▁SSL _ set _ ex _ data (* ssl , ▁e _ ctx _ ssl _ exdata _ index , ▁ctx ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁name ▁in ▁the ▁SSL ▁context ▁so ▁that ▁it ' ll ▁be ▁sent ▁in ▁the ▁* ▁in ▁the ▁server ▁name ▁extension ▁in ▁the ▁client ▁he ll o . ▁*/ ▁SSL _ set _ tls ext _ host _ name (* ssl , ▁ctx -> est _ server ); ▁SSL _ set _ bio (* ssl , ▁ tcp , ▁ tcp ); ▁if ▁( ctx -> sess ) ▁{ ▁SSL _ set _ session (* ssl , ▁ctx -> sess ); ▁} ▁if ▁( ( ssl _ connect _ ret ▁= ▁SSL _ connect (* ssl )) ▁< = ▁0) ▁{ ▁EST _ LOG _ ERR (" Error ▁connecting ▁TLS ▁context . ▁% d ", ▁SSL _ get _ error (* ssl , ▁ssl _ connect _ ret )); ▁ossl _ dump _ ssl _ errors (); ▁t cw _ close (& ctx -> t cw _ sock ); ▁sock ▁= ▁SOCK _ INVALID ; ▁rv ▁= ▁EST _ ERR _ SSL _ CONNECT ; ▁} ▁else ▁{ ▁ctx -> t cw _ sock _ connected ▁= ▁1; ▁} ▁/* ▁* ▁ Now ▁that ▁we ' ve ▁established ▁a ▁TLS ▁session ▁with ▁the ▁EST ▁server , ▁* ▁we ▁need ▁to ▁verify ▁that ▁the ▁ FQDN ▁in ▁the ▁server ▁cert ▁matches ▁* ▁the ▁server ▁name ▁we ▁used ▁to ▁establish ▁the ▁connection . ▁* ▁This ▁is ▁from ▁section ▁3.6 ▁in ▁the ▁EST ▁spec . ▁*/ ▁if ▁( ( EST _ ERR _ NONE ▁== ▁rv ) ▁&& ▁est _ client _ check _ f qd n ( ctx , ▁* ssl )) ▁{ ▁/* ▁* ▁The ▁host ▁name ▁did ▁not ▁match , ▁ sh ut ▁down ▁the ▁tunnel ▁and ▁bail ▁*/ ▁est _ client _ disconnect ( ctx , ▁ssl ); ▁EST _ LOG _ WARN (" EST ▁server ▁name ▁did ▁not ▁match ▁ FQDN ▁in ▁server ▁certificate . "); ▁rv ▁= ▁EST _ ERR _ FQDN _ MISMATCH ; ▁} ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁function ▁will ▁close ▁the ▁TLS ▁session ▁and ▁the ▁under ly ing ▁socket . ▁* ▁* ▁ Parameters : ▁* ▁ssl : ▁ Pointer ▁to ▁SSL ▁context ▁that ▁has ▁been ▁set ▁up ▁for ▁this ▁connection ▁* ▁to ▁the ▁EST ▁server . ▁*/ ▁void ▁est _ client _ disconnect ▁( EST _ CTX ▁* ctx , ▁SSL ▁** ssl ) ▁{ ▁SSL _ SESSION ▁* new _ sess ; ▁if ▁(! * ssl ) ▁{ ▁return ; ▁} ▁/* ▁* ▁if ▁first ▁ disconnect , ▁get ▁the ▁session ▁id ▁to ▁cache ▁it ▁away ▁to ▁use ▁for ▁* ▁session ▁resumption . ▁*/ ▁if ▁(! ctx -> sess ) ▁{ ▁ctx -> sess ▁= ▁SSL _ get 1 _ session (* ssl ); ▁} ▁else ▁{ ▁/* ▁* ▁if ▁not ▁the ▁first ▁time ▁to ▁ disconnect , ▁see ▁if ▁the ▁session ▁id ▁changed . ▁* ▁If ▁it ▁did , ▁of f i cial ly ▁re - ob ta in ▁it ▁with ▁a ▁get 1 ▁call ▁and ▁cache ▁it ▁away ▁*/ ▁new _ sess ▁= ▁SSL _ get 0 _ session (* ssl ); ▁if ▁( new _ sess ▁ != ▁ctx -> sess ) ▁{ ▁ctx -> sess ▁= ▁SSL _ get 1 _ session (* ssl ); ▁} ▁} ▁SSL _ shutdown (* ssl ); ▁SSL _ free (* ssl ); ▁* ssl ▁= ▁NULL ; ▁if ▁( ctx -> t cw _ sock _ connected ) ▁{ ▁t cw _ close (& ctx -> t cw _ sock ); ▁ctx -> t cw _ sock _ connected ▁= ▁0; ▁} ▁} ▁/* ▁* ▁This ▁function ▁does ▁the ▁work ▁for ▁the ▁CACerts ▁request ▁flow . ▁* ▁* ▁ Parameters : ▁* ▁ctx : ▁EST ▁context ▁* ▁ssl : ▁SSL ▁context ▁* ▁ca _ certs _ len : ▁pointer ▁to ▁the ▁un signed ▁int ▁that ▁will ▁hold ▁the ▁length ▁of ▁the ▁* ▁returned ▁CA ▁certs . ▁*/ ▁static ▁int ▁est _ client _ send _ cacerts _ request ▁( EST _ CTX ▁* ctx , ▁SSL ▁* ssl , ▁int ▁* ca _ certs _ len ) ▁{ ▁char ▁* http _ data ; ▁int ▁hdr _ len ; ▁int ▁write _ size ; ▁int ▁rv ; ▁un signed ▁char ▁* ca _ certs _ buf ▁= ▁NULL ; ▁int ▁ca _ certs _ buf _ len ▁= ▁0; ▁/* ▁* ▁Build ▁the ▁HTTP ▁request ▁* ▁- ▁allocate ▁buffer : ▁header , ▁no ▁data , ▁terminat ing ▁characters ▁* ▁- ▁build ▁the ▁header ▁* ▁- ▁no ▁data ▁* ▁- ▁terminate ▁it ▁*/ ▁http _ data ▁= ▁malloc ( EST _ HTTP _ REQ _ TO TAL _ LEN ); ▁if ▁( http _ data ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁allocate ▁memory ▁for ▁http _ data "); ▁return ▁EST _ ERR _ MALLOC ; ▁} ▁hdr _ len ▁= ▁est _ client _ build _ cacerts _ header ( ctx , ▁http _ data ); ▁/* ▁* ▁terminate ▁the ▁HTTP ▁header ▁*/ ▁ snprintf ( http _ data ▁+ ▁hdr _ len , ▁EST _ HTTP _ REQ _ TO TAL _ LEN - hdr _ len , " \ r \ n "); ▁hdr _ len ▁+= ▁2 ; ▁/* ▁* ▁no ▁data ▁is ▁being ▁sent ▁so ▁go ▁a head ▁and ▁terminate ▁the ▁HTTP ▁request ▁*/ ▁ snprintf ( http _ data ▁+ ▁hdr _ len , EST _ HTTP _ REQ _ TO TAL _ LEN - hdr _ len , ▁"\ r \ n "); ▁hdr _ len ▁+= ▁2 ; ▁/* ▁* ▁Send ▁the ▁request ▁to ▁the ▁server ▁and ▁wait ▁for ▁a ▁response ▁*/ ▁ctx -> last _ http _ status ▁= ▁0; ▁write _ size ▁= ▁SSL _ write ( ssl , ▁http _ data , ▁hdr _ len ); ▁if ▁( write _ size ▁< ▁0) ▁{ ▁EST _ LOG _ ERR (" TLS ▁write ▁error "); ▁ossl _ dump _ ssl _ errors (); ▁rv ▁= ▁EST _ ERR _ SSL _ WRITE ; ▁} ▁else ▁{ ▁EST _ LOG _ INFO (" TLS ▁wro te ▁% d ▁bytes , ▁attempted ▁% d ▁bytes \ n ", ▁write _ size , ▁hdr _ len ); ▁/* ▁* ▁T ry ▁to ▁get ▁the ▁response ▁from ▁the ▁server ▁*/ ▁rv ▁= ▁est _ io _ get _ response ( ctx , ▁ssl , ▁EST _ OP _ CACERTS , ▁& ca _ certs _ buf , ▁& ca _ certs _ buf _ len ); ▁switch ▁( rv ) ▁{ ▁case ▁EST _ ERR _ NONE : ▁/* ▁* ▁Make ▁sure ▁that ▁even ▁though ▁we ▁got ▁a ▁success ▁return ▁code , ▁that ▁we ▁* ▁ actually ▁received ▁something ▁*/ ▁if ▁( ca _ certs _ buf _ len ▁== ▁0) ▁{ ▁EST _ LOG _ ERR (" Retrieve d ▁CA ▁Cert ▁buf ▁is ▁zero ▁bytes ▁in ▁length "); ▁rv ▁= ▁EST _ ERR _ ZE RO _ LEN G TH _ BUF ; ▁break ; ▁} ▁if ▁( ca _ certs _ buf _ len +1 ▁> ▁EST _ CA _ MAX ) ▁{ ▁EST _ LOG _ ERR (" Retrieve d ▁CA ▁Cert ▁buf ▁is ▁large r ▁than ▁maximum ▁allowed "); ▁rv ▁= ▁EST _ ERR _ BUF _ EXCEED S _ MAX _ LEN ; ▁break ; ▁} ▁/* ▁* ▁Re size ▁the ▁buffer ▁hold ing ▁the ▁retrieved ▁CA ▁cert ▁and ▁link ▁it ▁* ▁into ▁the ▁ctx . ▁Get ▁rid ▁of ▁the ▁http ▁hdr ▁and ▁any ▁extra ▁space ▁on ▁* ▁the ▁back . ▁*/ ▁if ▁( ctx -> retrieved _ ca _ certs ▁ != ▁NULL ){ ▁free ( ctx -> retrieved _ ca _ certs ); ▁} ▁ctx -> retrieved _ ca _ certs ▁= ▁malloc ( ca _ certs _ buf _ len +1 ); ▁if ▁( ctx -> retrieved _ ca _ certs ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁allocate ▁CA ▁certs ▁buffer "); ▁rv ▁= ▁EST _ ERR _ MALLOC ; ▁break ; ▁} ▁ctx -> retrieved _ ca _ certs [ ca _ certs _ buf _ len ] ▁= ▁'\0'; ▁memcpy _ s ( ctx -> retrieved _ ca _ certs , ▁ca _ certs _ buf _ len +1, ▁ca _ certs _ buf , ▁ca _ certs _ buf _ len ); ▁ctx -> retrieved _ ca _ certs _ len ▁= ▁ca _ certs _ buf _ len ; ▁/* ▁* ▁Verify ▁the ▁returned ▁CA ▁cert ▁chain ▁*/ ▁rv ▁= ▁verify _ cacert _ resp ( ctx , ▁ctx -> retrieved _ ca _ certs , ▁& ctx -> retrieved _ ca _ certs _ len ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" Re turn ed ▁CACerts ▁chain ▁was ▁invalid "); ▁free ( ctx -> retrieved _ ca _ certs ); ▁ctx -> retrieved _ ca _ certs ▁= ▁NULL ; ▁ctx -> retrieved _ ca _ certs _ len ▁= ▁0; ▁* ca _ certs _ len ▁= ▁ctx -> retrieved _ ca _ certs _ len ; ▁break ; ▁} ▁/* ▁* ▁pass ▁back ▁the ▁length ▁of ▁the ▁retrieved ▁CA ▁cert ▁buffer ▁*/ ▁* ca _ certs _ len ▁= ▁ctx -> retrieved _ ca _ certs _ len ; ▁EST _ LOG _ INFO (" CACerts ▁buf : ▁% s ", ▁ctx -> retrieved _ ca _ certs ); ▁EST _ LOG _ INFO (" CACerts ▁length : ▁% d ", ▁ctx -> retrieved _ ca _ certs _ len ); ▁break ; ▁case ▁EST _ ERR _ AUTH _ FAIL : ▁EST _ LOG _ ERR (" HTTP ▁auth ▁failure "); ▁break ; ▁case ▁EST _ ERR _ CA _ ENROLL _ RETRY : ▁EST _ LOG _ INFO (" HTTP ▁request ▁failed ▁with ▁a ▁ RETRY ▁ AFTER ▁ resp "); ▁break ; ▁default : ▁EST _ LOG _ ERR (" EST ▁request ▁failed : ▁% d ▁(% s )", ▁rv , ▁EST _ ERR _ NUM _ TO _ STR ( rv )); ▁break ; ▁} ▁} ▁if ▁( http _ data ) ▁{ ▁free ( http _ data ); ▁} ▁if ▁( ca _ certs _ buf ) ▁{ ▁free ( ca _ certs _ buf ); ▁} ▁return ▁( rv ); ▁} ▁/* ▁* ▁This ▁function ▁does ▁the ▁work ▁for ▁the ▁CACerts ▁request ▁flow . ▁* ▁* ▁ Parameters : ▁* ▁ctx : ▁EST ▁context ▁* ▁ssl : ▁SSL ▁context ▁* ▁ca _ certs _ len : ▁pointer ▁to ▁the ▁un signed ▁int ▁that ▁will ▁hold ▁the ▁length ▁of ▁the ▁* ▁returned ▁CA ▁certs . ▁*/ ▁EST _ ERROR ▁est _ client _ set _ uid _ pw ▁( EST _ CTX ▁* ctx , ▁const ▁char ▁* uid , ▁const ▁char ▁* pwd ) ▁{ ▁/* ▁* ▁If ▁there ' s ▁a ▁userid , ▁there ▁must ▁be ▁a ▁password , ▁and ▁v ice ▁ ve rsa . ▁* ▁The ▁userid ▁can ▁st ill ▁be ▁an ▁empty ▁string ▁( ▁"" ▁ ) , ▁but ▁it ▁cannot ▁* ▁be ▁NULL ▁if ▁there ' s ▁a ▁password . ▁( 3 . 2 . 3 ) . ▁*/ ▁if ▁( uid ▁ != ▁NULL ▁&& ▁pwd ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" User ▁ID ▁provided ▁with ▁no ▁password "); ▁return ▁EST _ ERR _ INVALID _ PARAMETERS ; ▁} ▁if ▁( uid ▁== ▁NULL ▁&& ▁pwd ▁ != ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" Password ▁provided ▁with ▁no ▁user ▁ID "); ▁return ▁EST _ ERR _ INVALID _ PARAMETERS ; ▁} ▁/* ▁* ▁if ▁uid / pwd ▁set , ▁then ▁we ' re ▁do ing ▁basic / digest ▁authentication ▁*/ ▁if ▁( uid ▁ != ▁NULL ) ▁{ ▁if ▁( EOK ▁ != ▁strncpy _ s ( ctx -> userid , ▁ MAX _ UIDPWD , ▁uid , ▁ MAX _ UIDPWD )) ▁{ ▁EST _ LOG _ ERR (" I nvalid ▁User ▁ID ▁provided "); ▁return ▁EST _ ERR _ INVALID _ PARAMETERS ; ▁} ▁if ▁( EOK ▁ != ▁strncpy _ s ( ctx -> password , ▁ MAX _ UIDPWD , ▁pwd , ▁ MAX _ UIDPWD )) ▁{ ▁EST _ LOG _ ERR (" I nvalid ▁Password ▁provided "); ▁return ▁EST _ ERR _ INVALID _ PARAMETERS ; ▁} ▁} ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ client _ enroll _ csr () ▁perform s ▁the ▁simple ▁enroll ▁request ▁with ▁the ▁EST ▁server ▁using ▁a ▁PKCS 10 ▁CSR ▁provided ▁by ▁the ▁application ▁layer . ▁@ param ▁ctx ▁ Pointer ▁to ▁an ▁EST ▁context ▁@ param ▁csr ▁ Pointer ▁to ▁the ▁PKCS 10 ▁CSR ▁data , ▁which ▁is ▁defined ▁as ▁an ▁OpenSSL ▁X 509_ REQ . ▁@ param ▁pkcs 7_ len ▁ Pointer ▁to ▁an ▁integer ▁to ▁hold ▁the ▁length ▁of ▁the ▁PKCS 7 ▁buffer . ▁@ param ▁priv _ key ▁ Pointer ▁to ▁the ▁private ▁key ▁that ▁will ▁be ▁used ▁to ▁sign ▁the ▁CSR , ▁or ▁NULL ▁@ return ▁EST _ ERROR ▁est _ client _ enroll _ csr () ▁connect s ▁to ▁the ▁EST ▁server , ▁establishe s ▁a ▁SSL / TLS ▁connection ▁to ▁the ▁EST ▁server ▁that ▁was ▁configured ▁with ▁the ▁previous ▁call ▁to ▁est _ client _ set _ server (), ▁and ▁send s ▁the ▁simple ▁enroll ▁request . ▁The ▁application ▁layer ▁must ▁provide ▁the ▁PKCS 10 ▁CSR ▁that ▁will ▁be ▁enrolled . ▁If ▁the ▁priv _ key ▁argument ▁given ▁is ▁not ▁NULL , ▁then ▁the ▁CSR ▁should ▁not ▁need ▁to ▁be ▁signed ▁by ▁the ▁private ▁key . ▁How ever , ▁the ▁CSR ▁must ▁contain ▁everything ▁else ▁that ▁is ▁required , ▁includ ing ▁the ▁public ▁key . ▁If ▁the ▁private ▁key ▁is ▁provided ▁with ▁an ▁already ▁signed ▁CSR , ▁then ▁the ▁EST ▁library ▁will ▁re - sign ▁the ▁CSR . ▁The ▁enroll ▁response ▁is ▁stored ▁in ▁the ▁EST ▁context ▁and ▁the ▁length ▁is ▁passed ▁back ▁to ▁the ▁application ▁through ▁the ▁pkcs 7_ len ▁ param ter ▁of ▁this ▁function . ▁The ▁application ▁can ▁then ▁allocate ▁a ▁correctly ▁size d ▁buffer ▁and ▁call ▁est _ client _ copy _ enrolled _ cert () ▁to ▁retrieve ▁the ▁new ▁client ▁certificate ▁from ▁the ▁context . ▁Un less ▁the ▁CSR ▁is ▁not ▁already ▁signed , ▁which ▁is ▁indicated ▁by ▁a ▁NULL ▁priv _ key , ▁the ▁application ▁must ▁provide ▁a ▁pointer ▁to ▁the ▁private ▁key ▁used ▁to ▁sign ▁the ▁CSR . ▁This ▁is ▁required ▁by ▁the ▁EST ▁library ▁in ▁the ▁event ▁that ▁the ▁EST ▁server ▁has ▁requested ▁the ▁p roof - of - possession ▁value ▁be ▁included ▁in ▁the ▁CSR . ▁The ▁EST ▁library ▁will ▁automatically ▁include ▁the ▁p roof - of - po session ▁value ▁and ▁sign ▁the ▁CSR ▁again . ▁Be ▁ aware ▁that ▁the ▁X 509_ REQ ▁data ▁passed ▁to ▁this ▁function ▁must ▁be ▁valid . ▁Pass ing ▁corrupted ▁CSR ▁data ▁ma y ▁result ▁in ▁a ▁system ▁ c ra sh . ▁libEST ▁ util ize s ▁the ▁OpenSSL ▁ASN ▁decoding ▁logic ▁to ▁read ▁the ▁X 509_ REQ ▁data . ▁OpenSSL ▁does ▁not ▁perform ▁safe ty ▁checks ▁on ▁the ▁X 509_ REQ ▁data ▁when ▁parsing . ▁If ▁your ▁application ▁is ▁reading ▁external ly ▁generated ▁PEM ▁or ▁DER ▁encoded ▁CSR ▁data , ▁then ▁p lease ▁use ▁the ▁est _ read _ x 509_ request () ▁ helper ▁function ▁to ▁convert ▁the ▁PEM / DER ▁CSR ▁into ▁a ▁valid ▁X 509_ REQ ▁pointer . ▁*/ ▁EST _ ERROR ▁est _ client _ enroll _ csr ▁( EST _ CTX ▁* ctx , ▁X 509_ REQ ▁* csr , ▁int ▁* pkcs 7_ len , ▁E VP _ PKEY ▁* priv _ key ) ▁{ ▁EST _ ERROR ▁rv ; ▁SSL ▁* ssl ▁= ▁NULL ; ▁if ▁(! ctx ) ▁{ ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁if ▁(! csr ) ▁{ ▁return ▁( EST _ ERR _ NO _ CSR ); ▁} ▁if ▁(! ctx -> est _ client _ initialized ) ▁{ ▁return ▁EST _ ERR _ CLIENT _ NOT _ INITIALIZED ; ▁} ▁/* ▁* ▁E stablish ▁TLS ▁session ▁with ▁the ▁EST ▁server ▁*/ ▁rv ▁= ▁est _ client _ connect ( ctx , ▁& ssl ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁go to ▁err ; ▁} ▁if ▁( priv _ key ) ▁{ ▁rv ▁= ▁est _ client _ enroll _ pkcs 10 ( ctx , ▁ssl , ▁csr , ▁pkcs 7_ len , ▁priv _ key , ▁0); ▁} ▁else ▁{ ▁rv ▁= ▁est _ client _ enroll _ req ( ctx , ▁ssl , ▁csr , ▁pkcs 7_ len , ▁0); ▁} ▁est _ client _ disconnect ( ctx , ▁& ssl ); ▁if ▁( rv ▁== ▁EST _ ERR _ AUTH _ FAIL ▁&& ▁( ctx -> auth _ mode ▁== ▁AUTH _ DIGEST ▁|| ▁ctx -> auth _ mode ▁== ▁AUTH _ BASIC ▁|| ▁ctx -> auth _ mode ▁== ▁AUTH _ TOKEN )) ▁{ ▁/* ▁* ▁HTTP S ▁digest ▁mode ▁requires ▁the ▁use ▁of ▁MD 5 . ▁Make ▁sure ▁we ' re ▁not ▁* ▁in ▁FIPS ▁mode ▁and ▁can ▁use ▁MD 5 ▁*/ ▁if ▁( ctx -> auth _ mode ▁== ▁AUTH _ DIGEST ▁&& ▁( FIPS _ mode ())){ ▁EST _ LOG _ ERR (" HTTP ▁digest ▁auth ▁not ▁allowed ▁while ▁in ▁FIPS ▁mode "); ▁rv ▁= ▁EST _ ERR _ BAD _ MODE ; ▁go to ▁err ; ▁} ▁/* ▁T ry ▁one ▁more ▁time ▁if ▁we ' re ▁do ing ▁Digest ▁auth ▁*/ ▁EST _ LOG _ INFO (" HTTP ▁Auth ▁failed , ▁try ing ▁again ▁with ▁digest / basic ▁parameters "); ▁rv ▁= ▁est _ client _ connect ( ctx , ▁& ssl ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" Connection ▁failed ▁on ▁second ▁attempt ▁with ▁basic / digest ▁parameters "); ▁go to ▁err ; ▁} ▁if ▁( priv _ key ) ▁{ ▁rv ▁= ▁est _ client _ enroll _ pkcs 10 ( ctx , ▁ssl , ▁csr , ▁pkcs 7_ len , ▁priv _ key , ▁0); ▁} ▁else ▁{ ▁rv ▁= ▁est _ client _ enroll _ req ( ctx , ▁ssl , ▁csr , ▁pkcs 7_ len , ▁0); ▁} ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" Enroll ▁failed ▁on ▁second ▁attempt ▁dur ing ▁basic / digest ▁authentication "); ▁} ▁est _ client _ disconnect ( ctx , ▁& ssl ); ▁} ▁err : ▁if ▁( ssl ) ▁{ ▁SSL _ shutdown ( ssl ); ▁SSL _ free ( ssl ); ▁} ▁return ▁( rv ); ▁} ▁/* ! ▁@ br i ef ▁est _ client _ enroll () ▁perform s ▁the ▁simple ▁enroll ▁request ▁with ▁the ▁EST ▁server ▁@ param ▁ctx ▁ Pointer ▁to ▁an ▁EST ▁context ▁@ param ▁cn ▁ Pointer ▁to ▁the ▁Common ▁Name ▁value ▁to ▁be ▁used ▁in ▁the ▁enrollment ▁request . ▁@ param ▁pkcs 7_ len ▁ Pointer ▁to ▁an ▁integer ▁to ▁hold ▁the ▁length ▁of ▁the ▁PKCS 7 ▁buffer . ▁@ param ▁new _ public _ key ▁ Pointer ▁an ▁E VP _ PKEY ▁structure ▁that ▁hold s ▁the ▁client ' s ▁key ▁pair ▁to ▁be ▁used ▁in ▁the ▁simple ▁enroll ▁request ▁ . ▁The ▁public ▁key ▁is ▁included ▁in ▁the ▁Certificate ▁Sign ing ▁Request ▁( CSR ) ▁sent ▁to ▁the ▁CA ▁Server , ▁and ▁the ▁private ▁key ▁is ▁used ▁to ▁sign ▁the ▁request . ▁@ return ▁EST _ ERROR ▁est _ client _ enroll () ▁connect s ▁to ▁the ▁EST ▁server , ▁build s ▁a ▁simple ▁enroll ▁request ▁using ▁the ▁Common ▁Name ▁passed ▁in ▁cn , ▁establishe s ▁a ▁SSL / TLS ▁connection ▁to ▁the ▁EST ▁server ▁that ▁was ▁configured ▁with ▁the ▁previous ▁call ▁to ▁est _ client _ set _ server (), ▁and ▁send s ▁the ▁simple ▁enroll ▁request . ▁The ▁response ▁is ▁stored ▁in ▁the ▁EST ▁context ▁and ▁the ▁length ▁is ▁passed ▁back ▁to ▁the ▁application ▁through ▁the ▁pkcs 7_ len ▁parameter ▁of ▁this ▁function . ▁The ▁application ▁can ▁then ▁allocate ▁a ▁correctly ▁size d ▁buffer ▁and ▁call ▁est _ client _ copy _ enrolled _ cert () ▁to ▁retrieve ▁the ▁new ▁client ▁certificate ▁from ▁the ▁context . ▁*/ ▁EST _ ERROR ▁est _ client _ enroll ▁( EST _ CTX ▁* ctx , ▁char ▁* cn , ▁int ▁* pkcs 7_ len , ▁E VP _ PKEY ▁* new _ public _ key ) ▁{ ▁EST _ ERROR ▁rv ; ▁SSL ▁* ssl ▁= ▁NULL ; ▁if ▁(! ctx ) ▁{ ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁if ▁(! new _ public _ key ) ▁{ ▁return ▁( EST _ ERR _ NO _ KEY ); ▁} ▁if ▁(! ctx -> est _ client _ initialized ) ▁{ ▁return ▁EST _ ERR _ CLIENT _ NOT _ INITIALIZED ; ▁} ▁rv ▁= ▁est _ client _ connect ( ctx , ▁& ssl ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁go to ▁err ; ▁} ▁rv ▁= ▁est _ client _ enroll _ cn ( ctx , ▁ssl , ▁cn , ▁pkcs 7_ len , ▁new _ public _ key ); ▁est _ client _ disconnect ( ctx , ▁& ssl ); ▁if ▁( rv ▁== ▁EST _ ERR _ AUTH _ FAIL ▁&& ▁( ctx -> auth _ mode ▁== ▁AUTH _ DIGEST ▁|| ▁ctx -> auth _ mode ▁== ▁AUTH _ BASIC ▁|| ▁ctx -> auth _ mode ▁== ▁AUTH _ TOKEN )) ▁{ ▁/* ▁* ▁HTTP S ▁digest ▁mode ▁requires ▁the ▁use ▁of ▁MD 5 . ▁Make ▁sure ▁we ' re ▁not ▁* ▁in ▁FIPS ▁mode ▁and ▁can ▁use ▁MD 5 ▁*/ ▁if ▁( ctx -> auth _ mode ▁== ▁AUTH _ DIGEST ▁&& ▁( FIPS _ mode ())){ ▁EST _ LOG _ ERR (" HTTP ▁digest ▁auth ▁not ▁allowed ▁while ▁in ▁FIPS ▁mode "); ▁rv ▁= ▁EST _ ERR _ BAD _ MODE ; ▁go to ▁err ; ▁} ▁/* ▁T ry ▁one ▁more ▁time ▁if ▁we ' re ▁do ing ▁Digest ▁auth ▁*/ ▁EST _ LOG _ INFO (" HTTP ▁Auth ▁failed , ▁try ing ▁again ▁with ▁basic / digest / token ▁parameters "); ▁rv ▁= ▁est _ client _ connect ( ctx , ▁& ssl ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" Connection ▁failed ▁on ▁second ▁attempt ▁with ▁basic / digest / token ▁parameters "); ▁go to ▁err ; ▁} ▁rv ▁= ▁est _ client _ enroll _ cn ( ctx , ▁ssl , ▁cn , ▁pkcs 7_ len , ▁new _ public _ key ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" Enroll ▁failed ▁on ▁second ▁attempt ▁dur ing ▁basic / digest ▁authentication "); ▁/* ▁* ▁If ▁we ' re ▁attempt ing ▁token ▁mode ▁for ▁the ▁second ▁time , ▁and ▁* ▁the ▁server ▁respond ed ▁with ▁error ▁attributes , ▁log ▁them ▁now ▁*/ ▁if ▁( ctx -> token _ error [0 ] ▁ != ▁'\0' ▁|| ▁ctx -> token _ error _ desc [0 ] ▁ != ▁'\0') ▁{ ▁EST _ LOG _ ERR (" Token ▁Auth ▁mode ▁failed , ▁server ▁provided ▁error ▁information : ▁\ n " ▁" ▁Error ▁= ▁% s \ n ▁Error ▁description : ▁% s ", ▁ctx -> token _ error , ▁ctx -> token _ error _ desc ); ▁ctx -> token _ error [0 ] ▁= ▁'\0'; ▁ctx -> token _ error _ desc [0 ] ▁= ▁'\0'; ▁} ▁} ▁est _ client _ disconnect ( ctx , ▁& ssl ); ▁} ▁ctx -> auth _ mode ▁= ▁AUTH _ NONE ; ▁err : ▁if ▁( ssl ) ▁{ ▁SSL _ shutdown ( ssl ); ▁SSL _ free ( ssl ); ▁} ▁return ▁( rv ); ▁} ▁/* ! ▁@ br i ef ▁est _ client _ provision _ cert () ▁perform s ▁the ▁full ▁ sequence ▁of ▁EST ▁operations ▁to ▁enroll ▁a ▁new ▁certificate ▁using ▁a ▁trusted ▁message ▁flow . ▁@ param ▁ctx ▁ Pointer ▁to ▁an ▁EST ▁context ▁@ param ▁cn ▁ Pointer ▁to ▁the ▁Common ▁Name ▁value ▁to ▁be ▁used ▁in ▁the ▁enrollment ▁request . ▁@ param ▁pkcs 7_ len ▁ Pointer ▁to ▁an ▁integer ▁to ▁hold ▁the ▁length ▁of ▁the ▁PKCS 7 ▁certificate ▁returned ▁from ▁the ▁RA ▁or ▁CA . ▁@ param ▁ca _ cert _ len ▁ Pointer ▁to ▁an ▁integer ▁to ▁hold ▁the ▁length ▁of ▁the ▁buffer ▁that ▁will ▁hold ▁the ▁new ▁trusted ▁CA ▁certificates . ▁@ param ▁new _ public _ key ▁ Pointer ▁an ▁E VP _ PKEY ▁structure ▁that ▁hold s ▁the ▁client ' s ▁key ▁pair ▁to ▁be ▁used ▁in ▁the ▁simple ▁enroll ▁request ▁ . ▁The ▁public ▁key ▁is ▁included ▁in ▁the ▁Certificate ▁Sign ing ▁Request ▁( CSR ) ▁sent ▁to ▁the ▁CA ▁Server , ▁and ▁the ▁private ▁key ▁is ▁used ▁to ▁sign ▁the ▁request . ▁@ return ▁EST _ ERROR ▁est _ client _ provision _ cert () ▁connect s ▁to ▁the ▁EST ▁server , ▁retrieve s ▁the ▁la test ▁trusted ▁CA ▁certific te s ▁from ▁the ▁server , ▁retrieve s ▁the ▁CSR ▁attributes ▁from ▁the ▁server , ▁and ▁send s ▁the ▁simple ▁enroll ▁request ▁to ▁the ▁server ▁to ▁provision ▁a ▁new ▁certificate ▁from ▁the ▁RA ▁or ▁CA . ▁This ▁is ▁a ▁con ve n ience ▁function ▁that ▁is ▁ equiv a len t ▁to ▁invoking ▁the ▁following ▁thre e ▁functions ▁in ▁order : ▁est _ client _ get _ cacerts () ▁est _ client _ get _ csrattrs () ▁est _ client _ enroll () ▁This ▁function ▁takes ▁a ▁Common ▁Name ▁( CN ) ▁as ▁the ▁only ▁ entity ▁identifier ▁that ▁will ▁be ▁used ▁in ▁the ▁CSR . ▁If ▁additional ▁X 509 ▁attributes ▁or ▁extensions ▁are ▁required ▁because ▁the ▁EST ▁server ▁is ▁e n for c ing ▁the ▁presence ▁of ▁all ▁the ▁CSR ▁attributes , ▁then ▁this ▁function ▁should ▁not ▁be ▁used ▁to ▁provision ▁a ▁certificate . ▁The ▁est _ client _ enroll _ csr () ▁function ▁should ▁be ▁used ▁when ▁additional ▁X 509 ▁attributes ▁are ▁to ▁be ▁included ▁in ▁the ▁enroll ▁request . ▁The ▁provision ing ▁response ▁is ▁stored ▁in ▁the ▁EST ▁context ▁and ▁the ▁length ▁is ▁passed ▁back ▁to ▁the ▁application ▁through ▁the ▁pkcs 7_ len ▁parameter ▁of ▁this ▁function . ▁The ▁application ▁can ▁then ▁allocate ▁a ▁correctly ▁size d ▁buffer ▁and ▁call ▁est _ client _ copy _ enrolled _ cert () ▁to ▁retrieve ▁the ▁new ▁client ▁certificate ▁from ▁the ▁context . ▁The ▁provision ing ▁response ▁also ▁include s ▁the ▁la test ▁copy ▁of ▁the ▁trusted ▁CA ▁certificates ▁from ▁the ▁EST ▁server . ▁These ▁should ▁be ▁persiste d ▁locally ▁by ▁the ▁application ▁for ▁future ▁use . ▁The ▁ca _ cert _ len ▁argument ▁will ▁contain ▁the ▁length ▁of ▁the ▁cert i cate s , ▁which ▁can ▁then ▁be ▁retrieved ▁by ▁invoking ▁est _ client _ copy _ cacerts (). ▁*/ ▁EST _ ERROR ▁est _ client _ provision _ cert ▁( EST _ CTX ▁* ctx , ▁char ▁* cn , ▁int ▁* pkcs 7_ len , ▁int ▁* ca _ cert _ len , ▁E VP _ PKEY ▁* new _ public _ key ) ▁{ ▁EST _ ERROR ▁rv ; ▁un signed ▁char ▁* new _ ta _ p 7 ; ▁un signed ▁char ▁* new _ ta _ pem ; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁int ▁new _ ta _ len ; ▁if ▁(! ctx ) ▁{ ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁/* ▁* ▁Make ▁sure ▁we ▁have ▁non - NULL ▁pointer s ▁for ▁the ▁length s ▁*/ ▁if ▁(! pkcs 7_ len ▁|| ▁! ca _ cert _ len ) ▁{ ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁if ▁(! ctx -> est _ client _ initialized ) ▁{ ▁return ▁EST _ ERR _ CLIENT _ NOT _ INITIALIZED ; ▁} ▁if ▁(! new _ public _ key ) ▁{ ▁return ▁( EST _ ERR _ NO _ KEY ); ▁} ▁/* ▁* ▁First , ▁get ▁the ▁la test ▁trust ▁anchor ▁certs ▁from ▁the ▁server . ▁*/ ▁rv ▁= ▁est _ client _ get _ cacerts ( ctx , ▁ca _ cert _ len ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁return ▁rv ; ▁} ▁new _ ta _ p 7 ▁= ▁malloc (* ca _ cert _ len ); ▁if ▁( new _ ta _ p 7 ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁allocate ▁CA ▁certs ▁buffer "); ▁rv ▁= ▁EST _ ERR _ MALLOC ; ▁return ▁rv ; ▁} ▁rv ▁= ▁est _ client _ copy _ cacerts ( ctx , ▁new _ ta _ p 7 ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁free ( new _ ta _ p 7 ); ▁return ▁( rv ); ▁} ▁/* ▁* ▁The ▁certs ▁are ▁base 64 ▁DER ▁encoded . ▁We ▁need ▁to ▁convert ▁* ▁them ▁to ▁PEM . ▁*/ ▁new _ ta _ len ▁= ▁est _ convert _ p 7 b 64_ to _ pem ▁( new _ ta _ p 7, ▁* ca _ cert _ len , ▁& new _ ta _ pem ); ▁free ( new _ ta _ p 7 ); ▁if ▁( new _ ta _ len ▁< = ▁0) ▁{ ▁return ▁( EST _ ERR _ PEM _ READ ); ▁} ▁/* ▁* ▁We ▁now ▁have ▁the ▁new ▁trust ▁anchor ▁and ▁it ' s ▁PEM ▁encoded . ▁* ▁L et ' s ▁load ▁it ▁into ▁the ▁current ▁EST ▁context . ▁All ▁* ▁future ▁EST ▁operations ▁will ▁then ▁be ▁using ▁this ▁new ▁* ▁trust ▁anchor . ▁*/ ▁if ▁( ctx -> trusted _ certs _ store ▁ != ▁NULL ) ▁{ ▁X 509_ STORE _ free ( ctx -> trusted _ certs _ store ); ▁} ▁rv ▁= ▁est _ load _ trusted _ certs ( ctx , ▁new _ ta _ pem , ▁new _ ta _ len ); ▁free ( new _ ta _ pem ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁return ▁rv ; ▁} ▁/* ▁* ▁S ince ▁we ' ve ▁reset ▁the ▁trust ▁store , ▁ma rk ▁the ▁client ▁* ▁context ▁as ▁initialized . ▁*/ ▁ctx -> est _ client _ initialized ▁= ▁1; ▁/* ▁* ▁ Next ▁we ▁need ▁to ▁get ▁the ▁CSR ▁attributes , ▁which ▁allow s ▁libEST ▁* ▁to ▁know ▁if ▁the ▁ c hallengePassword ▁needs ▁to ▁be ▁included ▁in ▁the ▁* ▁CSR . ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& attr _ data , ▁& attr _ len ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁get ▁CSR ▁attributes ▁while ▁provision ing ▁a ▁new ▁certificate "); ▁return ▁( rv ); ▁} ▁/* ▁* ▁ Final ly , ▁we ▁can ▁attempt ▁to ▁enroll ▁a ▁new ▁certificate ▁using ▁the ▁* ▁Common ▁Name ▁provided ▁by ▁the ▁application . ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ctx , ▁cn , ▁pkcs 7_ len , ▁new _ public _ key ); ▁return ▁( rv ); ▁} ▁/* ! ▁@ br i ef ▁est _ client _ reenroll () ▁perform s ▁a ▁re - enroll ▁request ▁with ▁the ▁EST ▁server ▁using ▁an ▁existing ▁X 509 ▁certificate . ▁@ param ▁ctx ▁ Pointer ▁to ▁an ▁EST ▁context ▁@ param ▁cert ▁ Pointer ▁to ▁the ▁X 509 ▁certificate , ▁which ▁is ▁defined ▁as ▁an ▁OpenSSL ▁X 509 . ▁@ param ▁pkcs 7_ len ▁ Pointer ▁to ▁an ▁integer ▁to ▁hold ▁the ▁length ▁of ▁the ▁PKCS 7 ▁buffer . ▁@ param ▁priv _ key ▁ Pointer ▁to ▁the ▁private ▁key ▁that ▁will ▁be ▁used ▁to ▁sign ▁the ▁CSR . ▁@ return ▁EST _ ERROR ▁est _ client _ reenroll () ▁connect s ▁to ▁the ▁EST ▁server , ▁establishe s ▁a ▁SSL / TLS ▁connection ▁to ▁the ▁EST ▁server ▁that ▁was ▁configured ▁with ▁the ▁previous ▁call ▁to ▁est _ client _ set _ server (), ▁and ▁send s ▁the ▁re - enroll ▁request . ▁The ▁application ▁layer ▁must ▁provide ▁the ▁X 509 ▁certificate ▁that ▁will ▁be ▁enrolled . ▁This ▁certificate ▁should ▁have ▁previous ly ▁been ▁enrolled ▁with ▁the ▁CA . ▁The ▁application ▁also ▁needs ▁to ▁provide ▁the ▁private ▁key ▁associate d ▁with ▁the ▁public ▁key ▁in ▁the ▁X 509 ▁certificate . ▁This ▁private ▁key ▁is ▁required ▁to ▁sign ▁the ▁CSR ▁that ▁is ▁generated ▁from ▁the ▁X 509 ▁certificate . ▁The ▁enroll ▁response ▁is ▁stored ▁in ▁the ▁EST ▁context ▁and ▁the ▁length ▁is ▁passed ▁back ▁to ▁the ▁application ▁through ▁the ▁pkcs 7_ len ▁ param ter ▁of ▁this ▁function . ▁The ▁application ▁can ▁then ▁allocate ▁a ▁correctly ▁size d ▁buffer ▁and ▁call ▁est _ client _ copy _ enrolled _ cert () ▁to ▁retrieve ▁the ▁new ▁client ▁certificate ▁from ▁the ▁context . ▁The ▁application ▁must ▁provide ▁a ▁pointer ▁to ▁the ▁private ▁key ▁used ▁to ▁sign ▁the ▁CSR . ▁This ▁is ▁required ▁by ▁the ▁EST ▁library ▁in ▁the ▁event ▁that ▁the ▁EST ▁server ▁has ▁requested ▁the ▁p roof - of - possession ▁value ▁be ▁included ▁in ▁the ▁CSR . ▁The ▁EST ▁library ▁will ▁automatically ▁include ▁the ▁p roof - of - po session ▁value ▁and ▁sign ▁the ▁CSR ▁again . ▁Be ▁ aware ▁that ▁only ▁the ▁public ▁key ▁and ▁subject ▁name ▁from ▁the ▁X 509 ▁certificate ▁are ▁included ▁in ▁the ▁re - enroll ▁request ▁sent ▁to ▁the ▁EST ▁server . ▁The ▁CA ▁is ▁responsible ▁for ▁re - apply ing ▁any ▁X 509 ▁extensions ▁that ▁are ▁to ▁be ▁issued ▁with ▁the ▁renewed ▁certificate . ▁*/ ▁EST _ ERROR ▁est _ client _ reenroll ▁( EST _ CTX ▁* ctx , ▁X 509 ▁* cert , ▁int ▁* pkcs 7_ len , ▁E VP _ PKEY ▁* priv _ key ) ▁{ ▁X 509_ REQ ▁* req ; ▁EST _ ERROR ▁rv ; ▁SSL ▁* ssl ▁= ▁NULL ; ▁int ▁ossl _ rv ; ▁if ▁(! ctx ) ▁{ ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁if ▁(! cert ) ▁{ ▁return ▁( EST _ ERR _ NO _ CERT ); ▁} ▁if ▁(! priv _ key ) ▁{ ▁return ▁( EST _ ERR _ NO _ KEY ); ▁} ▁if ▁(! ctx -> est _ client _ initialized ) ▁{ ▁return ▁( EST _ ERR _ CLIENT _ NOT _ INITIALIZED ); ▁} ▁/* ▁* ▁Check ▁the ▁X 509 ▁given ▁to ▁us ▁*/ ▁rv ▁= ▁est _ client _ check _ x 509( cert ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁return ▁( rv ); ▁} ▁/* ▁* ▁Check ▁that ▁the ▁private ▁key ▁matches ▁the ▁public ▁key ▁* ▁in ▁the ▁cert . ▁*/ ▁if ▁( X 509_ check _ private _ key ( cert , ▁priv _ key ) ▁< = ▁0) ▁{ ▁return ▁( EST _ ERR _ CLIENT _ INVALID _ KEY ); ▁} ▁/* ▁* ▁Convert ▁the ▁existing ▁certificate ▁to ▁a ▁CSR ▁* ▁This ▁will ▁copy ▁the ▁subject ▁name ▁from ▁the ▁cert ▁into ▁* ▁a ▁new ▁CSR . ▁We ▁pass ▁in ▁NULL ▁for ▁the ▁private ▁key ▁parameter ▁* ▁below ▁because ▁we ▁will ▁sign ▁this ▁CSR ▁ourselves ▁later . ▁*/ ▁req ▁= ▁X 509_ to _ X 509_ REQ ( cert , ▁NULL , ▁ctx -> signing _ digest ); ▁if ▁(! req ) ▁{ ▁EST _ LOG _ ERR (" X 509 ▁to ▁CSR ▁conversion ▁failed . "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁( EST _ ERR _ NO _ CSR ); ▁} ▁/* ▁* ▁Copy ▁the ▁X 509 ▁extensions ▁from ▁the ▁old ▁certificate ▁* ▁to ▁the ▁CSR . ▁The ▁CA ▁ma y ▁or ▁ma y ▁not ▁retain ▁these , ▁as ▁* ▁this ▁behavio r ▁depend s ▁on ▁policy . ▁When ▁using ▁the ▁* ▁OpenSSL ▁test ▁CA , ▁set ▁the ▁copy _ extensions ▁setting ▁* ▁in ▁the ▁config ▁file ▁to ▁copy all ▁to ▁retain ▁the ▁* ▁extensions ▁in ▁the ▁CSR ▁when ▁is su ing ▁a ▁new ▁cert . ▁*/ ▁if ▁( cert -> cert _ info ▁&& ▁cert -> cert _ info -> extensions ) ▁{ ▁ossl _ rv ▁= ▁X 509_ REQ _ add _ extensions ( req , ▁cert -> cert _ info -> extensions ); ▁if ▁(! ossl _ rv ) ▁{ ▁EST _ LOG _ WARN (" Failed ▁to ▁copy ▁X 509 ▁extensions ▁to ▁the ▁CSR . ▁You r ▁new ▁certificate ▁ma y ▁not ▁contain ▁the ▁extensions ▁present ▁in ▁the ▁old ▁certificate . "); ▁} ▁} ▁/* ▁* ▁E stablish ▁TLS ▁session ▁with ▁the ▁EST ▁server ▁*/ ▁rv ▁= ▁est _ client _ connect ( ctx , ▁& ssl ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁go to ▁err ; ▁} ▁/* ▁* ▁Send ▁the ▁re - enroll ▁request ▁*/ ▁rv ▁= ▁est _ client _ enroll _ pkcs 10 ( ctx , ▁ssl , ▁req , ▁pkcs 7_ len , ▁priv _ key , ▁1); ▁est _ client _ disconnect ( ctx , ▁& ssl ); ▁if ▁( rv ▁== ▁EST _ ERR _ AUTH _ FAIL ▁&& ▁( ctx -> auth _ mode ▁== ▁AUTH _ DIGEST ▁|| ▁ctx -> auth _ mode ▁== ▁AUTH _ BASIC ▁|| ▁ctx -> auth _ mode ▁== ▁AUTH _ TOKEN )) ▁{ ▁/* ▁* ▁HTTP S ▁digest ▁mode ▁requires ▁the ▁use ▁of ▁MD 5 . ▁Make ▁sure ▁we ' re ▁not ▁* ▁in ▁FIPS ▁mode ▁and ▁can ▁use ▁MD 5 ▁*/ ▁if ▁( ctx -> auth _ mode ▁== ▁AUTH _ DIGEST ▁&& ▁( FIPS _ mode ())){ ▁EST _ LOG _ ERR (" HTTP ▁digest ▁auth ▁not ▁allowed ▁while ▁in ▁FIPS ▁mode "); ▁rv ▁= ▁EST _ ERR _ BAD _ MODE ; ▁go to ▁err ; ▁} ▁/* ▁T ry ▁one ▁more ▁time ▁if ▁we ' re ▁do ing ▁Digest ▁auth ▁*/ ▁EST _ LOG _ INFO (" HTTP ▁Auth ▁failed , ▁try ing ▁again ▁with ▁digest / basic ▁parameters "); ▁rv ▁= ▁est _ client _ connect ( ctx , ▁& ssl ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" Connection ▁failed ▁on ▁second ▁attempt ▁with ▁basic / digest ▁parameters "); ▁go to ▁err ; ▁} ▁rv ▁= ▁est _ client _ enroll _ pkcs 10 ( ctx , ▁ssl , ▁req , ▁pkcs 7_ len , ▁priv _ key , ▁1); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" Re enroll ▁failed ▁on ▁second ▁attempt ▁dur ing ▁basic / digest ▁authentication "); ▁/* ▁* ▁If ▁we ' re ▁attempt ing ▁token ▁mode ▁for ▁the ▁second ▁time , ▁and ▁* ▁the ▁server ▁respond ed ▁with ▁error ▁attributes , ▁log ▁them ▁now ▁*/ ▁if ▁( ctx -> token _ error [0 ] ▁ != ▁'\0' ▁|| ▁ctx -> token _ error _ desc [0 ] ▁ != ▁'\0') ▁{ ▁EST _ LOG _ ERR (" Token ▁Auth ▁mode ▁failed , ▁server ▁provided ▁error ▁information : ▁\ n " ▁" ▁Error ▁= ▁% s \ n ▁Error ▁description : ▁% s ", ▁ctx -> token _ error , ▁ctx -> token _ error _ desc ); ▁ctx -> token _ error [0 ] ▁= ▁'\0'; ▁ctx -> token _ error _ desc [0 ] ▁= ▁'\0'; ▁} ▁} ▁est _ client _ disconnect ( ctx , ▁& ssl ); ▁} ▁err : ▁if ▁( ssl ) ▁{ ▁SSL _ shutdown ( ssl ); ▁SSL _ free ( ssl ); ▁} ▁X 509_ REQ _ free ( req ); ▁return ▁( rv ); ▁} ▁/* ! ▁@ br i ef ▁est _ client _ copy _ enrolled _ cert () ▁passes ▁back ▁the ▁client ▁certificate ▁that ▁was ▁previous ly ▁obtained ▁from ▁the ▁EST ▁server ▁by ▁the ▁call ▁to ▁est _ client _ enroll (). ▁@ param ▁ctx ▁ Pointer ▁to ▁an ▁EST ▁context ▁@ param ▁cn ▁ Pointer ▁to ▁the ▁Common ▁Name ▁value ▁to ▁be ▁used ▁in ▁the ▁enrollment ▁request . ▁@ param ▁pkcs 7 ▁ Pointer ▁to ▁a ▁pointer ▁that ▁will ▁point ▁to ▁the ▁buffer ▁that ▁contains ▁the ▁new ly ▁enrolled ▁client ▁certificate . ▁@ return ▁EST _ ERROR ▁est _ client _ copy _ enrolled _ cert () ▁copie s ▁the ▁previous ly ▁obtained ▁client ▁certificate ▁from ▁the ▁EST ▁context ▁to ▁the ▁application ' s ▁buffer . ▁On ce ▁this ▁client ▁certificate ▁is ▁copied ▁out ▁of ▁the ▁context ▁it ▁is ▁removed ▁from ▁the ▁context . ▁*/ ▁EST _ ERROR ▁est _ client _ copy _ enrolled _ cert ▁( EST _ CTX ▁* ctx , ▁un signed ▁char ▁* pkcs 7 ) ▁{ ▁if ▁(! ctx ) ▁{ ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁if ▁(! ctx -> est _ client _ initialized ) ▁{ ▁return ▁EST _ ERR _ CLIENT _ NOT _ INITIALIZED ; ▁} ▁if ▁( pkcs 7 ▁== ▁NULL ){ ▁EST _ LOG _ ERR (" EST ▁Client : ▁Simple ▁Enroll , ▁invalid ▁parameter "); ▁return ▁EST _ ERR _ INVALID _ PARAMETERS ; ▁} ▁if ▁( ctx -> enrolled _ client _ cert ▁== ▁NULL ){ ▁EST _ LOG _ ERR (" No ▁client ▁certificate ▁to ▁copy "); ▁return ( EST _ ERR _ NO _ CERTIFICATE ); ▁} ▁mem zero _ s ( pkcs 7, ▁ctx -> enrolled _ client _ cert _ len ); ▁memcpy _ s ( pkcs 7, ▁ctx -> enrolled _ client _ cert _ len , ▁ctx -> enrolled _ client _ cert , ▁ctx -> enrolled _ client _ cert _ len ); ▁/* ▁* ▁ Now ▁that ▁the ▁copy ▁in ▁the ▁context ▁has ▁been ▁hand ed ▁over , ▁* ▁free ▁it ▁up ▁*/ ▁free ( ctx -> enrolled _ client _ cert ); ▁ctx -> enrolled _ client _ cert ▁= ▁NULL ; ▁ctx -> enrolled _ client _ cert _ len ▁= ▁0; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ client _ get _ cacerts () ▁perform s ▁a ▁CA certs ▁GET ▁request ▁to ▁the ▁EST ▁server ▁@ param ▁ctx ▁ Pointer ▁to ▁an ▁EST ▁context ▁@ param ▁ca _ certs _ len ▁ Pointer ▁to ▁an ▁integer ▁to ▁hold ▁the ▁length ▁of ▁the ▁CA ▁certs ▁buffer ▁@ return ▁EST _ ERROR ▁est _ client _ get _ cacerts () ▁connect s ▁to ▁the ▁EST ▁server , ▁build s ▁a ▁CA ▁certs ▁request , ▁and ▁send s ▁the ▁GET ▁CA ▁certs ▁request . ▁The ▁response ▁is ▁placed ▁in ▁a ▁buffer ▁allocated ▁and ▁maintained ▁by ▁the ▁EST ▁client ▁library ▁and ▁a ▁pointer ▁to ▁this ▁buffer ▁is ▁returned ▁to ▁the ▁call ing ▁application . ▁The ▁returned ▁CA ▁certs ▁are ▁in ▁base 64 ▁encoded ▁DER ▁format ▁and ▁is ▁stored ▁in ▁a ▁NULL ▁terminated ▁string ▁buffer . ▁On ce ▁the ▁CA ▁certificates ▁are ▁retrieved ▁from ▁the ▁EST ▁server , ▁the ▁E T ▁Client ▁library ▁must ▁be ▁reset . ▁The ▁retrieved ▁CA ▁certificates ▁should ▁now ▁be ▁passed ▁into ▁the ▁EST ▁client ▁initialization ▁function ▁as ▁the ▁explicit ▁TA ▁database . ▁*/ ▁EST _ ERROR ▁est _ client _ get _ cacerts ▁( EST _ CTX ▁* ctx , ▁int ▁* ca _ certs _ len ) ▁{ ▁EST _ ERROR ▁rv ▁= ▁EST _ ERR _ NONE ; ▁SSL ▁* ssl ▁= ▁NULL ; ▁if ▁(! ctx ) ▁{ ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁if ▁(! ctx -> est _ client _ initialized ) ▁{ ▁return ▁EST _ ERR _ CLIENT _ NOT _ INITIALIZED ; ▁} ▁if ▁( ca _ certs _ len ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" EST ▁Client : ▁Get ▁CACerts , ▁invalid ▁parameter "); ▁return ▁EST _ ERR _ INVALID _ PARAMETERS ; ▁} ▁rv ▁= ▁est _ client _ connect ( ctx , ▁& ssl ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁if ▁( ssl ) ▁{ ▁SSL _ shutdown ( ssl ); ▁SSL _ free ( ssl ); ▁} ▁return ▁( rv ); ▁} ▁rv ▁= ▁est _ client _ send _ cacerts _ request ( ctx , ▁ssl , ▁ca _ certs _ len ); ▁est _ client _ disconnect ( ctx , ▁& ssl ); ▁if ▁( ssl ) ▁{ ▁SSL _ shutdown ( ssl ); ▁SSL _ free ( ssl ); ▁} ▁return ▁( rv ); ▁} ▁/* ! ▁@ br i ef ▁est _ client _ copy _ cacerts () ▁copie s ▁the ▁previous ly ▁retrieved ▁CA ▁certificates ▁to ▁the ▁application ' s ▁buffer . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁current ▁EST ▁context . ▁@ param ▁ca _ certs ▁ Pointer ▁to ▁the ▁buffer ▁into ▁which ▁the ▁retrieved ▁CA ▁certificates ▁are ▁to ▁be ▁copied . ▁@ return ▁EST _ ERROR ▁est _ client _ copy _ cacerts () ▁copie s ▁the ▁most ▁recent ly ▁retrieved ▁CA ▁certificates ▁from ▁the ▁EST ▁server . ▁On ce ▁these ▁CA ▁certificates ▁are ▁copied ▁to ▁the ▁application ' s ▁buffer ▁point ed ▁to ▁by ▁ca _ certs ▁they ▁are ▁removed ▁from ▁the ▁EST ▁ cli et n ▁context . ▁On ce ▁the ▁CA ▁certificates ▁are ▁retrieved ▁by ▁the ▁application , ▁the ▁EST ▁client ▁library ▁must ▁be ▁reset . ▁When ▁this ▁reset ▁is ▁performed , ▁the ▁CA ▁certificates ▁retrieved ▁in ▁this ▁est _ client _ copy _ cacerts ▁call ▁should ▁be ▁passed ▁into ▁the ▁EST ▁client ▁initialization ▁function ▁as ▁the ▁explicit ▁TA ▁database . ▁*/ ▁EST _ ERROR ▁est _ client _ copy _ cacerts ▁( EST _ CTX ▁* ctx , ▁un signed ▁char ▁* ca _ certs ) ▁{ ▁if ▁(! ctx ) ▁{ ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁if ▁(! ctx -> est _ client _ initialized ) ▁{ ▁return ▁EST _ ERR _ CLIENT _ NOT _ INITIALIZED ; ▁} ▁if ▁( ca _ certs ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" EST ▁Client : ▁Get ▁CACerts , ▁invalid ▁parameter "); ▁return ▁EST _ ERR _ INVALID _ PARAMETERS ; ▁} ▁if ▁( ctx -> retrieved _ ca _ certs ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" No ▁CA ▁certificates ▁to ▁copy "); ▁return ( EST _ ERR _ NO _ CERTIFICATE ); ▁} ▁mem zero _ s ( ca _ certs , ▁ctx -> retrieved _ ca _ certs _ len ); ▁memcpy _ s ( ca _ certs , ▁ctx -> retrieved _ ca _ certs _ len , ▁ctx -> retrieved _ ca _ certs , ▁ctx -> retrieved _ ca _ certs _ len ); ▁/* ▁* ▁if ▁the ▁CA ▁certs ▁we re ▁obtained , ▁then ▁the ▁client ▁ lib ▁needs ▁to ▁be ▁reset . ▁*/ ▁ctx -> est _ client _ initialized ▁= ▁0; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ client _ get _ csrattrs () ▁perform s ▁the ▁CSR ▁attributes ▁request ▁to ▁the ▁EST ▁server . ▁@ param ▁ctx ▁ Pointer ▁to ▁EST ▁context ▁for ▁a ▁client ▁session ▁@ param ▁csr _ data ▁ Pointer ▁to ▁a ▁buffer ▁that ▁is ▁to ▁hold ▁the ▁returned ▁CSR ▁attributes ▁@ param ▁csr _ len ▁ Pointer ▁to ▁an ▁integer ▁that ▁is ▁to ▁hold ▁the ▁length ▁of ▁the ▁CSR ▁attributes ▁buffer ▁@ return ▁EST _ ERROR ▁est _ client _ get _ csrattrs () ▁connect s ▁to ▁the ▁EST ▁server , ▁send s ▁the ▁CSR ▁attributes ▁request ▁to ▁the ▁server , ▁save s ▁away s ▁the ▁returned ▁CSR ▁attribute ▁data , ▁and ▁then ▁ disconnect s ▁from ▁the ▁EST ▁server . ▁*/ ▁EST _ ERROR ▁est _ client _ get _ csrattrs ▁( EST _ CTX ▁* ctx , ▁un signed ▁char ▁** csr _ data , ▁int ▁* csr _ len ) ▁{ ▁int ▁rv , ▁new _ csr _ len , ▁pop _ required ▁= ▁0; ▁SSL ▁* ssl ▁= ▁NULL ; ▁un signed ▁char ▁* new _ csr _ data ; ▁if ▁(! ctx ) ▁{ ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁if ▁(! csr _ data ) ▁{ ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁if ▁(! csr _ len ) ▁{ ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁/* ▁assume ▁ def e at ▁*/ ▁* csr _ data ▁= ▁NULL ; ▁* csr _ len ▁= ▁0; ▁/* ▁* ▁Con n e ct ▁to ▁the ▁EST ▁server ▁*/ ▁rv ▁= ▁est _ client _ connect ( ctx , ▁& ssl ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁if ▁( ssl ) ▁{ ▁SSL _ shutdown ( ssl ); ▁SSL _ free ( ssl ); ▁} ▁return ▁( rv ); ▁} ▁/* ▁* ▁free ▁the ▁current ▁attributes ▁if ▁cached ▁*/ ▁if ▁( ctx -> retrieved _ csrattrs ) ▁{ ▁free ( ctx -> retrieved _ csrattrs ); ▁ctx -> retrieved _ csrattrs ▁= ▁NULL ; ▁ctx -> retrieved _ csrattrs _ len ▁= ▁0; ▁} ▁ctx -> retrieved _ csrattrs _ len ▁= ▁0; ▁ctx -> retrieved _ csrattrs ▁= ▁NULL ; ▁/* ▁* ▁Send ▁the ▁HTTP ▁request ▁to ▁the ▁EST ▁server ▁*/ ▁rv ▁= ▁est _ client _ send _ csrattrs _ request ( ctx , ▁ssl , ▁& new _ csr _ data , ▁& new _ csr _ len ); ▁est _ client _ disconnect ( ctx , ▁& ssl ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" CSR ▁request ▁failed , ▁error ▁code ▁is ▁% d ▁(% s )", ▁rv , ▁EST _ ERR _ NUM _ TO _ STR ( rv )); ▁if ▁( new _ csr _ data ) ▁{ ▁free ( new _ csr _ data ); ▁} ▁if ▁( ssl ) ▁{ ▁SSL _ shutdown ( ssl ); ▁SSL _ free ( ssl ); ▁} ▁return ▁( rv ); ▁} ▁if ▁( ssl ) ▁{ ▁SSL _ shutdown ( ssl ); ▁SSL _ free ( ssl ); ▁} ▁if ▁( new _ csr _ data ▁== ▁NULL ) ▁{ ▁EST _ LOG _ INFO (" CSR ▁attributes ▁are : ▁NULL "); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁have ▁to ▁allocate ▁the ▁new ▁memory ▁prior ▁to ▁* ▁parsing ▁to ▁be ▁sure ▁it ▁is ▁null ▁terminated . ▁*/ ▁ctx -> retrieved _ csrattrs ▁= ▁malloc ( new _ csr _ len ▁+ ▁1); ▁if ▁(! ctx -> retrieved _ csrattrs ) ▁{ ▁free ( new _ csr _ data ); ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁ctx -> retrieved _ csrattrs _ len ▁= ▁new _ csr _ len ; ▁memcpy _ s ( ctx -> retrieved _ csrattrs , ▁new _ csr _ len +1, ▁new _ csr _ data , ▁new _ csr _ len ); ▁ctx -> retrieved _ csrattrs [ new _ csr _ len ] ▁= ▁0; ▁EST _ LOG _ INFO (" CSR ▁attributes ▁are ( % d ) : ▁% s ", ▁ctx -> retrieved _ csrattrs _ len , ▁ctx -> retrieved _ csrattrs ); ▁free ( new _ csr _ data ); ▁/* ▁ Now ▁make ▁sure ▁the ▁data ▁is ▁valid ▁*/ ▁rv ▁= ▁est _ asn 1 _ parse _ attributes ( ( char ▁* ) ctx -> retrieved _ csrattrs , ▁ctx -> retrieved _ csrattrs _ len , ▁& pop _ required ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁free ( ctx -> retrieved _ csrattrs ); ▁ctx -> retrieved _ csrattrs ▁= ▁NULL ; ▁ctx -> retrieved _ csrattrs _ len ▁= ▁0; ▁} ▁else ▁{ ▁* csr _ data ▁= ▁ctx -> retrieved _ csrattrs ; ▁* csr _ len ▁= ▁ctx -> retrieved _ csrattrs _ len ; ▁} ▁ctx -> csr _ pop _ required ▁= ▁pop _ required ; ▁return ▁( rv ); ▁} ▁/* ! ▁@ br i ef ▁est _ client _ enable _ srp () ▁is ▁used ▁by ▁an ▁application ▁to ▁enable ▁TLS - SRP ▁as ▁the ▁transport , ▁which ▁is ▁used ▁in ▁place ▁of ▁ tr ad itional ▁TLS . ▁TLS - SRP ▁allow s ▁for ▁secure ▁transport ▁when ▁an ▁X . 509 ▁certificate ▁is ▁not ▁available ▁or ▁when ▁a ▁trust ▁anchor ▁is ▁not ▁available . ▁@ param ▁ctx ▁EST ▁context ▁obtained ▁from ▁the ▁est _ client _ init () ▁call . ▁@ param ▁strength ▁Specifie s ▁the ▁SRP ▁strength ▁to ▁use . ▁@ param ▁uid ▁char ▁buffer ▁containing ▁the ▁user ▁id ▁to ▁be ▁used ▁as ▁the ▁SRP ▁user ▁name . ▁@ param ▁pwd ▁char ▁buffer ▁containing ▁the ▁pass ow rd ▁to ▁be ▁used ▁as ▁the ▁SRP ▁password . ▁This ▁function ▁allow s ▁an ▁application ▁to ▁enable ▁TLS - SRP ▁cipher ▁suites , ▁which ▁is ▁another ▁form ▁for ▁TLS . ▁This ▁could ▁be ▁used ▁when ▁the ▁EST ▁client ▁does ▁not ▁have ▁an ▁X . 509 ▁certificate ▁to ▁identify ▁itself ▁to ▁the ▁EST ▁server . ▁It ▁can ▁also ▁be ▁used ▁by ▁the ▁EST ▁client ▁when ▁a ▁trust ▁anchor ▁is ▁not ▁available ▁to ▁authenticate ▁the ▁EST ▁server ▁identity . ▁The ▁EST ▁server ▁must ▁support ▁TLS - SRP ▁when ▁using ▁this ▁API . ▁This ▁function ▁must ▁be ▁invoked ▁after ▁est _ client _ init () ▁and ▁prior ▁to ▁is su ing ▁any ▁EST ▁commands . . ▁All ▁string ▁parameters ▁are ▁NULL ▁terminated ▁strings . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ client _ enable _ srp ▁( EST _ CTX ▁* ctx , ▁int ▁strength , ▁char ▁* uid , ▁char ▁* pwd ) ▁{ ▁X 509_ STORE ▁* store ; ▁int ▁rv ; ▁if ▁( ctx ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context ▁passed "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁if ▁( ctx -> ssl _ ctx ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" SSL ▁context ▁has ▁not ▁been ▁initialized "); ▁return ▁( EST _ ERR _ NO _ SSL _ CTX ); ▁} ▁if ▁( str e ng th ▁< ▁EST _ SRP _ STR ENG TH _ MIN ) ▁{ ▁EST _ LOG _ ERR (" SRP ▁strength ▁must ▁be ▁greate r ▁than ▁% d ", ▁EST _ SRP _ STR ENG TH _ MIN ); ▁return ▁( EST _ ERR _ SRP _ STR ENG TH _ LOW ); ▁} ▁if ▁( uid ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" SRP ▁user ▁ID ▁must ▁be ▁provided "); ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁if ▁( pwd ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" SRP ▁password ▁must ▁be ▁provided "); ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁ctx -> enable _ srp ▁= ▁1; ▁/* ▁* ▁E nable ▁just ▁the ▁SRP ▁cipher ▁suites . ▁When ▁SRP ▁is ▁enabled , ▁* ▁it ' s ▁used ▁ex c lus ive ly . ▁* ▁* ▁Check ▁if ▁we ▁have ▁a ▁trust ▁anchor ▁configured . ▁We ▁will ▁* ▁enable ▁the ▁ DSS ▁and ▁RSA ▁auth ▁cipher ▁suites ▁if ▁we ▁do . ▁*/ ▁store ▁= ▁SSL _ CTX _ get _ cert _ store ( ctx -> ssl _ ctx ); ▁if ▁( store ▁&& ▁store -> obj s ▁&& ▁sk _ X 509_ OBJECT _ num ( store -> obj s ) ▁> ▁0) ▁{ ▁EST _ LOG _ INFO (" E nable ▁SSL ▁SRP ▁cipher ▁suites ▁with ▁RSA / DSS \ n "); ▁rv ▁= ▁SSL _ CTX _ set _ cipher _ list ( ctx -> ssl _ ctx , ▁EST _ C IP HER _ LIST _ SRP _ AUTH ); ▁} ▁else ▁{ ▁EST _ LOG _ INFO (" E nable ▁SSL ▁SRP ▁cipher ▁suites ▁w / o ▁RSA / DSS \ n "); ▁rv ▁= ▁SSL _ CTX _ set _ cipher _ list ( ctx -> ssl _ ctx , ▁EST _ C IP HER _ LIST _ SRP _ ONLY ); ▁} ▁if ▁(! rv ) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁set ▁SSL ▁SRP ▁cipher ▁suites \ n "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁EST _ ERR _ SSL _ C IP HER _ LIST ; ▁} ▁/* ▁* ▁Set ▁the ▁SRP ▁user ▁name ▁and ▁password . ▁*/ ▁if ▁(! SSL _ CTX _ set _ srp _ username ( ctx -> ssl _ ctx , ▁uid )) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁set ▁SRP ▁username \ n "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁EST _ ERR _ UNKNOWN ; ▁} ▁if ▁(! SSL _ CTX _ set _ srp _ password ( ctx -> ssl _ ctx , ▁pwd )) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁set ▁SRP ▁password \ n "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁EST _ ERR _ UNKNOWN ; ▁} ▁SSL _ CTX _ set _ srp _ str e ng th ( ctx -> ssl _ ctx , ▁strength ); ▁EST _ LOG _ INFO (" TLS - SRP ▁enabled "); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ client _ set _ auth () ▁is ▁used ▁by ▁an ▁application ▁to ▁set ▁up ▁the ▁authentication ▁parameters ▁to ▁be ▁used . ▁@ param ▁ctx ▁EST ▁context ▁obtained ▁from ▁the ▁est _ client _ init () ▁call . ▁@ param ▁uid ▁char ▁buffer ▁containing ▁the ▁user ▁id ▁to ▁be ▁used ▁for ▁basic ▁and ▁digest ▁based ▁authentication ▁@ param ▁pwd ▁char ▁buffer ▁containing ▁the ▁pass ow rd ▁to ▁be ▁used ▁for ▁basic ▁and ▁digest ▁based ▁authentication ▁@ param ▁client _ cert _ raw ▁char ▁buffer ▁containing ▁the ▁client ▁application ▁certificate . ▁@ param ▁pkey _ raw ▁Private ▁key ▁that ▁can ▁be ▁used ▁with ▁the ▁client ▁cert ▁@ param ▁pkey _ len ▁Length ▁of ▁buffer ▁hold ing ▁the ▁private ▁key ▁This ▁function ▁allow s ▁an ▁application ▁to ▁provide ▁the ▁information ▁required ▁for ▁authenticating ▁the ▁EST ▁client ▁with ▁the ▁EST ▁server . ▁Un ti l ▁this ▁call ▁is ▁made , ▁the ▁only ▁accepted ▁request ▁is ▁the ▁GET ▁CA ▁Certs . ▁If ▁the ▁user ▁id ▁is ▁provided , ▁a ▁password ▁must ▁also ▁be ▁provided . ▁The ▁application ▁ma y ▁pass ▁the ▁private ▁key ▁( pkey _ raw / pkey _ len ) ▁to ▁be ▁used ▁for ▁signing ▁requests ▁to ▁the ▁server , ▁otherwise , ▁only ▁basic ▁or ▁digest ▁based ▁authentication ▁will ▁be ▁performed ▁on ▁the ▁TLS ▁session ▁for ▁these ▁requests . ▁If ▁the ▁private ▁key ▁is ▁passed , ▁it ▁must ▁contain ▁the ▁private ▁key ▁that ▁matches ▁the ▁public ▁key ▁contain ed ▁in ▁the ▁client _ cert ▁parameter . ▁All ▁string ▁parameters ▁are ▁NULL ▁terminated ▁strings . ▁@ return ▁EST _ ERROR . ▁If ▁error , ▁NULL . ▁*/ ▁EST _ ERROR ▁est _ client _ set _ auth ▁( EST _ CTX ▁* ctx , ▁const ▁char ▁* uid , ▁const ▁char ▁* pwd , ▁X 509 ▁* client _ cert , ▁E VP _ PKEY ▁* private _ key ) ▁{ ▁EST _ ERROR ▁rv ▁= ▁EST _ ERR _ NONE ; ▁if ▁( ctx ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context ▁passed "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁rv ▁= ▁est _ client _ set _ uid _ pw ( ctx , ▁uid , ▁pwd ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁return ▁( rv ); ▁} ▁ctx -> auth _ mode ▁= ▁AUTH _ NONE ; ▁/* ▁* ▁cache ▁away ▁the ▁client ▁cert ▁and ▁the ▁associate d ▁private ▁key , ▁then ▁* ▁get ▁them ▁loaded ▁into ▁the ▁SSL ▁context ▁so ▁that ▁they ' ll ▁be ▁used . ▁*/ ▁ctx -> client _ key ▁= ▁private _ key ; ▁ctx -> client _ cert ▁= ▁client _ cert ; ▁/* ▁* ▁Load ▁the ▁client ▁cert ▁if ▁it ' s ▁available ▁*/ ▁if ▁( ctx -> client _ cert ▁&& ▁ctx -> client _ key ) ▁{ ▁if ▁( est _ client _ set _ cert _ and _ key ( ctx -> ssl _ ctx , ▁ctx -> client _ cert , ▁ctx -> client _ key )) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁load ▁local ▁certificate ▁and ▁private ▁key "); ▁return ▁EST _ ERR _ CLIENT _ INVALID _ KEY ; ▁} ▁} ▁else ▁{ ▁EST _ LOG _ WARN (" Not ▁using ▁client ▁certificate ▁for ▁TLS ▁session , ▁HTTP ▁basic ▁or ▁digest ▁auth ▁will ▁be ▁used . "); ▁} ▁return ▁EST _ ERR _ NONE ; ▁} ▁/* ! ▁@ br i ef ▁est _ client _ set _ auth _ cred _ cb () ▁is ▁used ▁by ▁an ▁application ▁to ▁register ▁its ▁callback ▁function . ▁@ param ▁ctx ▁EST ▁context ▁obtained ▁from ▁the ▁est _ client _ init () ▁call . ▁@ param ▁auth _ credentials _ cb ▁Function ▁pointer ▁to ▁the ▁application ▁layer ▁callback ▁The ▁registered ▁callback ▁function ▁is ▁used ▁by ▁the ▁EST ▁client ▁library ▁to ▁obtain ▁authentication ▁credentials . ▁The ▁application ▁can ▁provide ▁authentication ▁credentials ▁dur ing ▁initialization ▁if ▁they ▁are ▁available , ▁suc h ▁as ▁the ▁userid ▁and ▁password ▁used ▁with ▁HTTP ▁basic ▁authentication . ▁Dur ing ▁the ▁processing ▁of ▁a ▁request , ▁the ▁EST ▁client ▁library ▁will ▁call ▁this ▁application ▁callback ▁in ▁the ▁event ▁that ▁it ▁does ▁not ▁have ▁the ▁authentication ▁credentials ▁that ▁are ▁being ▁requested ▁by ▁the ▁EST ▁server . ▁The ▁callback ▁function ▁definition ▁must ▁match ▁the ▁following ▁function ▁prototype , ▁int ▁(* auth _ credentials _ cb ) ( EST _ HTTP _ AUTH _ HDR ▁* auth _ credentials ); ▁auth _ credentials ▁- ▁A ▁pointer ▁to ▁a ▁EST _ HTTP _ AUTH _ HDR ▁structure . ▁The ▁structure ▁is ▁provided ▁by ▁the ▁EST ▁library ▁and ▁the ▁callback ▁function ▁fill s ▁in ▁the ▁specific ▁credentials ▁being ▁requested . ▁These ▁credential ▁values ▁must ▁be ▁passed ▁in ▁the ▁format ▁in ▁which ▁they ▁will ▁be ▁sent ▁to ▁the ▁server , ▁that ▁is , ▁the ▁EST ▁client ▁library ▁will ▁perform ▁no ▁re format ting ▁of ▁these ▁credentials . ▁Own ers h ip ▁of ▁the ▁memory ▁hold ing ▁these ▁credential ▁values ▁is ▁transferred ▁from ▁the ▁application ▁layer ▁to ▁the ▁EST ▁library ▁when ▁the ▁application ▁layer ▁return s ▁these ▁values ▁to ▁the ▁EST ▁library . ▁This ▁allow s ▁the ▁EST ▁library ▁to ▁free ▁up ▁this ▁memory ▁as ▁soon ▁as ▁it ▁is ▁done ▁using ▁these ▁values . ▁The ▁return ▁value ▁from ▁the ▁callback ▁must ▁be ▁one ▁of ▁the ▁following ▁values : ▁EST _ HTTP _ AUTH _ CRE D _ SUCCESS ▁- ▁If ▁the ▁callback ▁was ▁ able ▁to ▁provide ▁the ▁requested ▁credentials . ▁EST _ HTTP _ AUTH _ CRE D _ NOT _ AVAILABLE ▁- ▁If ▁the ▁callback ▁could ▁not ▁provide ▁the ▁requested ▁credentials . ▁The ▁auth _ credentials _ cb ▁parameter ▁can ▁be ▁set ▁to ▁NULL ▁to ▁reset ▁the ▁callback ▁function . ▁All ▁string ▁parameters ▁are ▁NULL ▁terminated ▁strings . ▁@ return ▁EST _ ERROR . ▁EST _ ERR _ NONE ▁- ▁Success . ▁EST _ ERR _ NO _ CTX ▁*/ ▁EST _ ERROR ▁est _ client _ set _ auth _ cred _ cb ▁( EST _ CTX ▁* ctx , ▁auth _ credentials _ cb ▁callback ) ▁{ ▁if ▁( ctx ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context ▁passed "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁ctx -> auth _ credentials _ cb ▁= ▁callback ; ▁return ▁EST _ ERR _ NONE ; ▁} ▁/* ! ▁@ br i ef ▁est _ client _ enable _ basic _ auth _ hint () ▁is ▁used ▁by ▁an ▁application ▁to ▁redu ce ▁over head ▁at ▁the ▁TCP ▁and ▁TLS ▁layer s ▁when ▁the ▁client ▁know s ▁that ▁the ▁EST ▁server ▁is ▁using ▁HTTP ▁Basic ▁Authentication . ▁@ param ▁ctx ▁ Pointer ▁to ▁EST ▁context ▁for ▁a ▁client ▁session ▁Normally ▁libEST ▁will ▁send ▁an ▁ano nymo us ▁HTTP ▁request ▁when ▁do ing ▁the ▁initial ▁request ▁from ▁the ▁EST ▁server . ▁This ▁function ▁allow s ▁an ▁application ▁to ▁improve ▁performance ▁by ▁send ing ▁the ▁HTTP ▁Basic ▁Auth ▁header ▁in ▁the ▁initial ▁request ▁sent ▁to ▁the ▁EST ▁server . ▁This ▁eliminate s ▁the ▁need ▁for ▁the ▁server ▁to ▁send ▁the ▁HTTP ▁authentication ▁ c hall en e ▁response , ▁which ▁eliminate s ▁a ▁ round - tr ip ▁between ▁the ▁EST ▁client ▁and ▁server . ▁This ▁function ▁should ▁be ▁called ▁ im mediate ly ▁after ▁invoking ▁est _ client _ set _ auth (). ▁P re ca u tion s ▁should ▁be ▁taken ▁by ▁your ▁application ▁to ▁ensure ▁this ▁hint ▁is ▁only ▁enabled ▁when ▁it ▁is ▁known ▁that ▁the ▁EST ▁server ▁is ▁configured ▁for ▁HTTP ▁Basic ▁Authentication . ▁If ▁the ▁EST ▁server ▁is ▁configured ▁for ▁HTTP ▁Digest ▁Authentication , ▁then ▁e n a b l ing ▁this ▁hint ▁will ▁cause ▁the ▁EST ▁transaction ▁to ▁fail . ▁@ return ▁EST _ ERROR ▁EST _ ERR _ NONE ▁- ▁Success . ▁*/ ▁EST _ ERROR ▁est _ client _ enable _ basic _ auth _ hint ▁( EST _ CTX ▁* ctx ) ▁{ ▁if ▁( ctx ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context ▁passed "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁ctx -> auth _ mode ▁= ▁AUTH _ BASIC ; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ client _ init () ▁is ▁used ▁by ▁an ▁application ▁to ▁create ▁a ▁context ▁in ▁the ▁EST ▁library . ▁This ▁context ▁is ▁used ▁when ▁invoking ▁other ▁functions ▁in ▁the ▁client ▁API . ▁@ param ▁ca _ chain ▁Require d ▁char ▁buffer ▁containing ▁CA ▁certificates ▁as ▁raw ▁byte ▁data , ▁to ▁be ▁used ▁for ▁authenticating ▁the ▁EST ▁server ▁@ param ▁ca _ chain _ len ▁length ▁of ▁ca _ chain ▁char ▁buffer . ▁@ param ▁cert _ format ▁ define s ▁the ▁format ▁of ▁the ▁certificates ▁that ▁will ▁be ▁passed ▁down ▁dur ing ▁this ▁instantiat ion ▁of ▁the ▁EST ▁client ▁library . ▁Currently , ▁the ▁only ▁value ▁accepted ▁is ▁EST _ CERT _ FORMAT _ PEM ▁@ param ▁cert _ verify _ cb ▁A ▁pointer ▁to ▁a ▁function ▁in ▁the ▁EST ▁client ▁application ▁that ▁is ▁called ▁when ▁a ▁received ▁server ▁identity ▁certificate ▁has ▁failed ▁verification ▁from ▁the ▁SSL ▁code . ▁This ▁function ▁takes ▁as ▁input ▁two ▁parameters , ▁a ▁pointer ▁to ▁the ▁X 509 ▁structure ▁containing ▁the ▁server ' s ▁certificate , ▁and ▁a ▁integer ▁value ▁set ▁to ▁the ▁OpenSSL ▁defined ▁error ▁for ▁this ▁certificate . ▁This ▁callback ▁function ▁return s ▁a ▁0 ▁if ▁the ▁server ' s ▁identity ▁certificate ▁has ▁been ▁rejected , ▁and ▁any ▁other ▁value ▁if ▁it ▁has ▁been ▁approved . ▁This ▁function ▁allow s ▁an ▁application ▁to ▁initialize ▁an ▁EST ▁client ▁context . ▁The ▁application ▁must ▁provide ▁the ▁local ▁CA ▁certificates ▁( ca _ chain / ca _ chain _ len ) ▁to ▁use ▁for ▁client ▁operation . ▁The ▁certificates ▁provided ▁must ▁be ▁in ▁the ▁format ▁specified ▁by ▁the ▁cert _ format ▁parameter . ▁Currently , ▁only ▁PEM ▁encoded ▁certificates ▁are ▁supported . ▁The ▁length ▁parameters ▁for ▁the ▁certificates ▁( ca _ chain _ len ) ▁are ▁to ▁be ▁used ▁when ▁DER ▁formatt ed ▁certificates ▁are ▁passed . ▁The ▁CA ▁certificates ▁ma y ▁contain ▁CRL ▁entries ▁that ▁will ▁be ▁used ▁when ▁authenticating ▁the ▁certificates ▁received ▁from ▁the ▁server . ▁@ return ▁EST _ CTX . ▁If ▁error , ▁NULL . ▁*/ ▁EST _ CTX ▁* est _ client _ init ▁( un signed ▁char ▁* ca _ chain , ▁int ▁ca _ chain _ len , ▁EST _ CERT _ FORMAT ▁cert _ format , ▁int ▁(* cert _ verify _ cb ) ( X 509 ▁* , ▁int )) ▁{ ▁EST _ CTX ▁* ctx ; ▁v ol at i le ▁int ▁len ; ▁int ▁rv ; ▁# if def ▁WI N 32 ▁int ▁iResult ; ▁/* ▁* Init ial ize ▁W in sock ▁*/ ▁iResult ▁= ▁ WSAStartup ( MA K E WORD (2, ▁2) , ▁& ws aData ); ▁if ▁( i Result ▁ != ▁0) ▁{ ▁EST _ LOG _ ERR (" WSAStartup ▁ Failed : ▁% d \ n ", ▁iResult ); ▁return ▁0; ▁} ▁# endif ▁if ▁( cert _ format ▁ != ▁EST _ CERT _ FORMAT _ PEM ) ▁{ ▁EST _ LOG _ ERR (" Only ▁PEM ▁encoding ▁of ▁certificates ▁is ▁supported . "); ▁return ▁NULL ; ▁} ▁/* ▁* ▁If ▁a ▁CA ▁chain ▁was ▁passed ▁in , ▁then ▁check ▁the ▁length ▁value ▁passed ▁in . ▁It ▁* ▁should ▁match ▁the ▁calculate d ▁length ▁of ▁the ▁buffer . ▁This ▁will ▁verify ▁* ▁both ▁that ▁the ▁length ▁value ▁is ▁correct , ▁and ▁that ▁the ▁buffer ▁is ▁properly ▁* ▁null ▁terminated . ▁*/ ▁if ▁( ca _ chain ) ▁{ ▁len ▁= ▁( int ) ▁ strnlen _ s ( ( char ▁* ) ca _ chain , ▁EST _ CA _ MAX ); ▁if ▁( len ▁ != ▁ca _ chain _ len ) ▁{ ▁EST _ LOG _ ERR (" Length ▁of ▁ca _ chain ▁does n ' t ▁match ▁passed ▁ca _ chain _ len "); ▁return ▁NULL ; ▁} ▁} ▁ctx ▁= ▁malloc ( sizeof ( EST _ CTX )); ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁allocate ▁memory ▁for ▁EST ▁Context "); ▁return ▁NULL ; ▁} ▁mem zero _ s ( ctx , ▁sizeof ( EST _ CTX )); ▁ctx -> est _ mode ▁= ▁EST _ CLIENT ; ▁/* ▁* ▁Load ▁the ▁local ▁CA ▁certificates ▁into ▁memory ▁and ▁retain ▁* ▁for ▁future ▁use . ▁This ▁will ▁be ▁used ▁for ▁/ CACerts ▁requests . ▁*/ ▁if ▁( est _ load _ trusted _ certs ( ctx , ▁ca _ chain , ▁ca _ chain _ len )) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁load ▁trusted ▁certificate ▁store "); ▁est _ destroy ( ctx ); ▁return ▁NULL ; ▁} ▁rv ▁= ▁est _ client _ init _ ssl _ ctx ( ctx ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁initialize ▁SSL ▁context ▁with ▁certific i ate ▁and ▁private ▁key ▁passed "); ▁est _ destroy ( ctx ); ▁return ▁NULL ; ▁} ▁/* ▁* ▁save ▁away ▁the ▁client ' s ▁callback ▁function ▁that ▁allow s ▁for ▁manual ▁verification ▁of ▁* ▁the ▁server ' s ▁identity ▁certificate ▁*/ ▁ctx -> manual _ cert _ verify _ cb ▁= ▁cert _ verify _ cb ; ▁/* ▁* ▁Set ▁the ▁default ▁value ▁for ▁the ▁socket ▁read ▁timeout . ▁*/ ▁ctx -> read _ timeout ▁= ▁EST _ SSL _ READ _ TIMEOUT _ DEF ; ▁/* ▁* ▁We ▁use ▁SHA - 256 ▁as ▁the ▁default ▁hash ▁algorithm ▁* ▁for ▁signing ▁the ▁CSR . ▁This ▁can ▁be ▁changed ▁by ▁the ▁* ▁application ▁by ▁using ▁the ▁est _ client _ set _ sign _ digest () ▁* ▁function . ▁*/ ▁ctx -> signing _ digest ▁= ▁E VP _ sha 256 (); ▁ctx -> retry _ after _ delay ▁= ▁0; ▁ctx -> retry _ after _ date ▁= ▁0; ▁ctx -> est _ client _ initialized ▁= ▁1; ▁return ▁( ctx ); ▁} ▁/* ! ▁@ br i ef ▁est _ client _ init () ▁is ▁used ▁by ▁an ▁application ▁to ▁create ▁a ▁context ▁in ▁the ▁EST ▁library . ▁This ▁context ▁is ▁used ▁when ▁invoking ▁other ▁functions ▁in ▁the ▁client ▁API . ▁@ param ▁ca _ chain ▁Require d ▁char ▁buffer ▁containing ▁CA ▁certificates ▁as ▁raw ▁byte ▁data , ▁to ▁be ▁used ▁for ▁authenticating ▁the ▁EST ▁server ▁@ param ▁ca _ chain _ len ▁length ▁of ▁ca _ chain ▁char ▁buffer . ▁@ param ▁cert _ format ▁ define s ▁the ▁format ▁of ▁the ▁certificates ▁that ▁will ▁be ▁passed ▁down ▁dur ing ▁this ▁instantiat ion ▁of ▁the ▁EST ▁client ▁library . ▁Currently , ▁the ▁only ▁value ▁accepted ▁is ▁EST _ CERT _ FORMAT _ PEM ▁@ param ▁cert _ verify _ cb ▁A ▁pointer ▁to ▁a ▁function ▁in ▁the ▁EST ▁client ▁application ▁that ▁is ▁called ▁when ▁a ▁received ▁server ▁identity ▁certificate ▁has ▁failed ▁verification ▁from ▁the ▁SSL ▁code . ▁This ▁function ▁takes ▁as ▁input ▁two ▁parameters , ▁a ▁pointer ▁to ▁the ▁X 509 ▁structure ▁containing ▁the ▁server ' s ▁certificate , ▁and ▁a ▁integer ▁value ▁set ▁to ▁the ▁OpenSSL ▁defined ▁error ▁for ▁this ▁certificate . ▁This ▁callback ▁function ▁return s ▁a ▁0 ▁if ▁the ▁server ' s ▁identity ▁certificate ▁has ▁been ▁rejected , ▁and ▁any ▁other ▁value ▁if ▁it ▁has ▁been ▁approved . ▁This ▁function ▁allow s ▁an ▁application ▁to ▁initialize ▁an ▁EST ▁client ▁context . ▁The ▁application ▁must ▁provide ▁the ▁local ▁CA ▁certificates ▁( ca _ chain / ca _ chain _ len ) ▁to ▁use ▁for ▁client ▁operation . ▁The ▁certificates ▁provided ▁must ▁be ▁in ▁the ▁format ▁specified ▁by ▁the ▁cert _ format ▁parameter . ▁Currently , ▁only ▁PEM ▁encoded ▁certificates ▁are ▁supported . ▁The ▁length ▁parameters ▁for ▁the ▁certificates ▁( ca _ chain _ len ) ▁are ▁to ▁be ▁used ▁when ▁DER ▁formatt ed ▁certificates ▁are ▁passed . ▁The ▁CA ▁certificates ▁ma y ▁contain ▁CRL ▁entries ▁that ▁will ▁be ▁used ▁when ▁authenticating ▁the ▁certificates ▁received ▁from ▁the ▁server . ▁@ return ▁EST _ CTX . ▁If ▁error , ▁NULL . ▁*/ ▁static ▁EST _ ERROR ▁est _ client _ parse _ path _ seg ▁( char ▁* path _ seg ) ▁{ ▁UriPa rs er State A ▁state ; ▁ Uri UriA ▁parsed _ uri ; ▁int ▁uriparse _ rc ; ▁UriPa th Segment A ▁* cur _ seg ▁= ▁NULL ; ▁char ▁* cur _ seg _ str ▁= ▁NULL ; ▁EST _ OPERATION ▁operation ; ▁char ▁ canned _ uri [ EST _ URI _ MAX _ LEN ] ; ▁/* ▁* ▁build ▁out ▁a ▁ canned ▁URI ▁to ▁pass ▁to ▁the ▁ uriparser ▁library . ▁* ▁This ▁will ▁cause ▁the ▁incoming ▁path ▁segment ▁to ▁be ▁in ▁the ▁* ▁correct ▁sp o t ▁within ▁a ▁URI ▁as ▁it ▁gets ▁validated . ▁ Main ▁issue ▁* ▁is ▁the ▁possible ▁use ▁of ▁a ▁':' ▁in ▁the ▁path ▁segment ▁be coming ▁a ▁* ▁the me ▁ del im i ter ▁*/ ▁mem zero _ s ( canned _ uri , ▁EST _ URI _ MAX _ LEN ); ▁str c py _ s ( canned _ uri , ▁EST _ URI _ MAX _ LEN , ▁" / . well - known / est / "); ▁str cat _ s ( canned _ uri , ▁EST _ URI _ MAX _ LEN , ▁path _ seg ); ▁state . uri ▁= ▁& parse d _ uri ; ▁uriparse _ rc ▁= ▁uri P ar se UriA (& state , ▁ canned _ uri ); ▁if ▁( uri parse _ rc ▁ != ▁URI _ SUCCESS ) ▁{ ▁uri Free Uri Members A ( state . uri ); ▁return ▁( EST _ ERR _ HTTP _ INVALID _ P ATH _ SEGMENT ); ▁} ▁cur _ seg ▁= ▁parsed _ uri . pathHead ; ▁if ▁( cur _ seg ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" No ▁valid ▁path ▁segment ▁in ▁suppl ied ▁string "); ▁uri Free Uri Members A ( state . uri ); ▁return ▁( EST _ ERR _ HTTP _ INVALID _ P ATH _ SEGMENT ); ▁} ▁cur _ seg ▁= ▁cur _ seg -> next -> next ; ▁cur _ seg _ str ▁= ▁( char ▁* ) cur _ seg -> text . first ; ▁operation ▁= ▁est _ parse _ operation ( cur _ seg _ str ); ▁/* ▁* ▁look ▁to ▁see ▁if ▁the ▁operation ▁path ▁come s ▁next : ▁* ▁cacerts , ▁csrattrs , ▁simpleenroll , ▁ simplereenroll . ▁* ▁If ▁any ▁of ▁the ▁operations ▁occur ▁in ▁this ▁path ▁segment ▁* ▁string , ▁then ▁this ▁is ▁a ▁problem . ▁*/ ▁if ▁( operation ▁ != ▁EST _ OP _ MAX ) ▁{ ▁EST _ LOG _ ERR (" Path ▁segment ▁string ▁contains ▁an ▁operation ▁value . ▁path ▁segment ▁passed ▁in ▁= ▁% s \ n ", ▁cur _ seg _ str ); ▁uri Free Uri Members A ( state . uri ); ▁return ▁( EST _ ERR _ HTTP _ INVALID _ P ATH _ SEGMENT ); ▁} ▁/* ▁* ▁Look ▁to ▁see ▁if ▁there ▁are ▁multiple ▁segments ▁*/ ▁if ▁( ( char ▁* ) cur _ seg -> next ▁ != ▁NULL ▁|| ▁* ( cur _ seg -> text . afterLast ) ▁ != ▁'\0') ▁{ ▁EST _ LOG _ ERR (" Path ▁segment ▁string ▁contains ▁multiple ▁path ▁segments ▁or ▁more ▁than ▁a ▁path ▁segment "); ▁uri Free Uri Members A ( state . uri ); ▁return ▁( EST _ ERR _ HTTP _ INVALID _ P ATH _ SEGMENT ); ▁} ▁uri Free Uri Members A ( state . uri ); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ client _ set _ server () ▁is ▁called ▁by ▁the ▁application ▁layer ▁to ▁specify ▁the ▁address / port ▁of ▁the ▁EST ▁server . ▁It ▁must ▁be ▁called ▁after ▁est _ client _ init () ▁and ▁prior ▁to ▁is su ing ▁any ▁EST ▁commands . ▁@ param ▁ctx ▁ Pointer ▁to ▁EST ▁context ▁for ▁a ▁client ▁session ▁@ param ▁server ▁Name ▁of ▁the ▁EST ▁server ▁to ▁connect ▁to . ▁The ▁ASCII ▁string ▁representing ▁the ▁name ▁of ▁the ▁server ▁is ▁ limited ▁to ▁25 4 ▁characters ▁@ param ▁port ▁TCP ▁port ▁on ▁the ▁EST ▁server ▁to ▁connect ▁@ param ▁path _ segment ▁A ▁string ▁containing ▁the ▁optional ▁path ▁segment ▁to ▁be ▁added ▁to ▁the ▁URI . ▁If ▁not ▁used , ▁set ▁to ▁NULL . ▁@ return ▁EST _ ERROR ▁EST _ ERR _ NONE ▁- ▁Success . ▁EST _ ERR _ NO _ CTX ▁- ▁NULL ▁value ▁passed ▁for ▁EST ▁context ▁EST _ ERR _ INVALID _ SERVER _ NAME ▁- ▁NULL ▁value ▁passed ▁for ▁EST ▁server ▁name , ▁or ▁server ▁name ▁string ▁too ▁long ▁EST _ ERR _ CLIENT _ NOT _ INITIALIZED ▁- ▁Call ed ▁before ▁est _ client _ init () ▁EST _ ERR _ INVALID _ PORT _ NUM ▁- ▁I nvalid ▁port ▁number ▁input , ▁ less ▁than ▁zero ▁or ▁greate r ▁than ▁65535 ▁est _ client _ set _ server ▁error ▁checks ▁its ▁input ▁parameters ▁and ▁then ▁store s ▁both ▁the ▁hostname ▁and ▁port ▁number ▁into ▁the ▁EST ▁context . ▁*/ ▁EST _ ERROR ▁est _ client _ set _ server ▁( EST _ CTX ▁* ctx , ▁const ▁char ▁* server , ▁int ▁port , ▁char ▁* path _ segment ) ▁{ ▁if ▁(! ctx ) ▁{ ▁return ▁EST _ ERR _ NO _ CTX ; ▁} ▁if ▁(! ctx -> est _ client _ initialized ) ▁{ ▁return ▁EST _ ERR _ CLIENT _ NOT _ INITIALIZED ; ▁} ▁if ▁( server ▁== ▁NULL ) ▁{ ▁return ▁EST _ ERR _ INVALID _ SERVER _ NAME ; ▁} ▁if ▁( port ▁< = ▁0 ▁|| ▁port ▁> ▁65535 ) ▁{ ▁return ▁EST _ ERR _ INVALID _ PORT _ NUM ; ▁} ▁if ▁( EOK ▁ != ▁strncpy _ s ( ctx -> est _ server , ▁EST _ MAX _ SERVER NAME _ LEN , ▁server , ▁EST _ MAX _ SERVER NAME _ LEN )) ▁{ ▁return ▁EST _ ERR _ INVALID _ SERVER _ NAME ; ▁} ▁ctx -> est _ port _ num ▁= ▁port ; ▁# if def ▁HAV E _ URI PARSE R ▁{ ▁int ▁path _ segment _ len ; ▁EST _ ERROR ▁rc ; ▁if ▁( path _ segment ▁ != ▁NULL ) ▁{ ▁if ▁(* path _ segment ▁== ▁'\0') ▁{ ▁return ▁EST _ ERR _ HTTP _ INVALID _ P ATH _ SEGMENT ; ▁} ▁/* ▁* ▁Make ▁sure ▁it ' s ▁not ▁too ▁long ▁*/ ▁path _ segment _ len ▁= ▁ strnlen _ s ( path _ segment , ▁EST _ MAX _ P ATH _ SEGMENT _ LEN +1 ); ▁if ▁( path _ segment _ len ▁> ▁EST _ MAX _ P ATH _ SEGMENT _ LEN ) ▁{ ▁return ▁EST _ ERR _ HTTP _ INVALID _ P ATH _ SEGMENT ; ▁} ▁/* ▁* ▁Validate ▁the ▁incoming ▁path ▁segment ▁string ▁*/ ▁rc ▁= ▁est _ client _ parse _ path _ seg ( path _ segment ); ▁if ▁( rc ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" path ▁segment ▁failed ▁validation . "); ▁return ▁( rc ); ▁} ▁/* ▁* ▁valid . ▁store ▁it ▁away ▁in ▁the ▁context ▁*/ ▁rc ▁= ▁est _ store _ path _ segment ( ctx , ▁path _ segment , ▁path _ segment _ len ); ▁if ▁( rc ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁store ▁URI ▁path ▁segment . "); ▁return ▁( rc ); ▁} ▁} ▁} ▁# else ▁{ ▁/* ▁* ▁If ▁no ▁ uriparser ▁support , ▁then ▁we ▁cannot ▁support ▁* ▁a ▁path ▁segment ▁being ▁passed ▁in ▁*/ ▁if ▁( path _ segment ) ▁{ ▁EST _ LOG _ ERR (" U se ▁of ▁path ▁segments ▁not ▁supported ▁in ▁this ▁build ▁of ▁libEST . "); ▁return ▁EST _ ERR _ HTTP _ P ATH _ SEGMENT _ NOT _ SUPPORTED ; ▁} ▁} ▁# endif ▁return ▁EST _ ERR _ NONE ; ▁} ▁/* ! ▁@ br i ef ▁est _ client _ set _ proxy () ▁is ▁called ▁by ▁the ▁application ▁layer ▁to ▁specify ▁the ▁proxy ▁to ▁the ▁EST ▁server . ▁It ▁must ▁be ▁called ▁after ▁est _ client _ init () ▁and ▁prior ▁to ▁is su ing ▁any ▁EST ▁commands . ▁@ param ▁ctx ▁ Pointer ▁to ▁EST ▁context ▁for ▁a ▁client ▁session ▁@ param ▁proxy _ proto ▁ Proxy ▁protocol ▁@ param ▁proxy _ server ▁Name ▁of ▁the ▁proxy ▁server ▁to ▁connect ▁to . ▁The ▁ASCII ▁string ▁representing ▁the ▁name ▁of ▁the ▁server ▁is ▁ limited ▁to ▁25 4 ▁characters ▁( EST _ MAX _ SERVER NAME _ LEN ) ▁@ param ▁port ▁TCP ▁port ▁on ▁the ▁proxy ▁server ▁to ▁connect ▁@ param ▁proxy _ auth ▁ Proxy ▁authentication ▁method ▁@ param ▁username ▁User name ▁to ▁use ▁to ▁authenticate ▁with ▁the ▁proxy ▁@ param ▁password ▁Password ▁to ▁use ▁to ▁authenticate ▁with ▁the ▁proxy ▁@ return ▁EST _ ERROR ▁EST _ ERR _ NONE ▁- ▁Success . ▁EST _ ERR _ NO _ CTX ▁- ▁NULL ▁value ▁passed ▁for ▁EST ▁context ▁EST _ ERR _ INVALID _ SERVER _ NAME ▁- ▁NULL ▁value ▁passed ▁for ▁EST ▁server ▁name , ▁or ▁server ▁name ▁string ▁too ▁long ▁EST _ ERR _ INVALID _ PORT _ NUM ▁- ▁port ▁num ▁to ▁proxy ▁server ▁is ▁invalid ▁EST _ ERR _ CLIENT _ NOT _ INITIALIZED ▁- ▁Call ed ▁before ▁est _ client _ init () ▁EST _ ERR _ INVALID _ PARAMETERS ▁- ▁NULL ▁value ▁passed ▁for ▁e i ther ▁username ▁or ▁password ▁OR ▁username ▁or ▁password ▁is ▁too ▁long ▁EST _ ERR _ CLIENT _ PROXY _ MODE _ NOT _ SUPPORTED ▁- ▁client ▁proxy ▁mode ▁is ▁only ▁supported ▁when ▁ built ▁with ▁libcurl ▁support ▁EST _ ERR _ INVALID _ CLIENT _ PROXY _ PROTOCOL ▁- ▁An ▁invalid ▁proxy ▁protocol ▁has ▁been ▁specified ▁est _ client _ set _ proxy ▁error ▁checks ▁its ▁input ▁parameters ▁and ▁then ▁store s ▁the ▁proxy ▁information ▁into ▁the ▁EST ▁context . ▁NOTE : ▁HTTP ▁proxy ▁tunnel l ing ▁is ▁not ▁supported ▁by ▁libEST ▁in ▁server ▁mode . ▁If ▁configur ing ▁libEST ▁in ▁client ▁mode ▁to ▁communicate ▁with ▁libEST ▁in ▁server ▁mode , ▁then ▁EST _ CLIENT _ PROXY _ HTTP _ NOTUNNEL ▁must ▁be ▁specified ▁for ▁the ▁proxy ▁protocol . ▁*/ ▁EST _ ERROR ▁est _ client _ set _ proxy ▁( EST _ CTX ▁* ctx , ▁EST _ CLIENT _ PROXY _ PROTO ▁proxy _ proto , ▁const ▁char ▁* proxy _ server , ▁un signed ▁short ▁int ▁proxy _ port , ▁un signed ▁int ▁proxy _ auth , ▁const ▁char ▁* username , ▁const ▁char ▁* password ) ▁{ ▁# if def ▁HAV E _ LIB CURL ▁if ▁(! ctx ) ▁{ ▁return ▁EST _ ERR _ NO _ CTX ; ▁} ▁if ▁(! ctx -> est _ client _ initialized ) ▁{ ▁return ▁EST _ ERR _ CLIENT _ NOT _ INITIALIZED ; ▁} ▁if ▁( proxy _ server ▁== ▁NULL ▁|| ▁proxy _ server [0 ] ▁== ▁'\0') ▁{ ▁return ▁EST _ ERR _ INVALID _ SERVER _ NAME ; ▁} ▁if ▁( EST _ MAX _ SERVER NAME _ LEN ▁< ▁ strnlen _ s ( proxy _ server , ▁EST _ MAX _ SERVER NAME _ LEN + 2)) ▁{ ▁return ▁EST _ ERR _ INVALID _ SERVER _ NAME ; ▁} ▁ctx -> proxy _ server [0 ] ▁= ▁'\0'; ▁if ▁( EOK ▁ != ▁strncpy _ s ( ctx -> proxy _ server , ▁sizeof ( ctx -> proxy _ server ) , ▁proxy _ server , ▁sizeof ( ctx -> proxy _ server ))) ▁{ ▁return ▁EST _ ERR _ INVALID _ SERVER _ NAME ; ▁} ▁if ▁( proxy _ port ▁< = ▁0 ▁|| ▁proxy _ port ▁> ▁65535 ) ▁{ ▁return ▁EST _ ERR _ INVALID _ PORT _ NUM ; ▁} ▁ctx -> proxy _ port ▁= ▁proxy _ port ; ▁if ▁( proxy _ proto ▁< ▁EST _ CLIENT _ PROXY _ HTTP _ NOTUNNEL ▁|| ▁proxy _ proto ▁> ▁EST _ CLIENT _ PROXY _ SOCKS 5 _ HOSTNAME ) ▁{ ▁return ▁EST _ ERR _ INVALID _ CLIENT _ PROXY _ PROTOCOL ; ▁} ▁ctx -> proxy _ proto ▁= ▁proxy _ proto ; ▁if ▁( proxy _ auth ▁ != ▁EST _ CLIENT _ PROXY _ AUTH _ NONE ▁&& ▁(0 ▁ != ▁( proxy _ auth ▁& ▁ ~ ( EST _ CLIENT _ PROXY _ AUTH _ BASIC | EST _ CLIENT _ PROXY _ AUTH _ NTLM ) ))) ▁{ ▁return ▁EST _ ERR _ INVALID _ CLIENT _ PROXY _ AUTH ; ▁} ▁ctx -> proxy _ auth ▁= ▁proxy _ auth ; ▁if ▁( username ▁&& ▁password ▁&& ▁proxy _ auth ▁ != ▁EST _ CLIENT _ PROXY _ AUTH _ NONE ) ▁{ ▁if ▁( MAX _ UIDPWD ▁< ▁ strnlen _ s ( username , ▁ MAX _ UIDPWD + 2)) ▁{ ▁return ▁EST _ ERR _ INVALID _ PARAMETERS ; ▁} ▁if ▁( username [0 ] ▁== ▁'\0') ▁{ ▁return ▁EST _ ERR _ INVALID _ PARAMETERS ; ▁} ▁ctx -> proxy _ username [0 ] ▁= ▁'\0'; ▁if ▁( EOK ▁ != ▁strncpy _ s ( ctx -> proxy _ username , ▁sizeof ( ctx -> proxy _ username ) , ▁username , ▁sizeof ( ctx -> proxy _ username ))) ▁{ ▁return ▁EST _ ERR _ INVALID _ PARAMETERS ; ▁} ▁if ▁( MAX _ UIDPWD ▁< ▁ strnlen _ s ( password , ▁ MAX _ UIDPWD + 2)) ▁{ ▁return ▁EST _ ERR _ INVALID _ PARAMETERS ; ▁} ▁if ▁( password [0 ] ▁== ▁'\0') ▁{ ▁return ▁EST _ ERR _ INVALID _ PARAMETERS ; ▁} ▁ctx -> proxy _ password [0 ] ▁= ▁'\0'; ▁if ▁( EOK ▁ != ▁strncpy _ s ( ctx -> proxy _ password , ▁sizeof ( ctx -> proxy _ password ) , ▁password , ▁sizeof ( ctx -> proxy _ password ))) ▁{ ▁return ▁EST _ ERR _ INVALID _ PARAMETERS ; ▁} ▁ctx -> proxy _ auth ▁= ▁proxy _ auth ; ▁} ▁ctx -> use _ proxy ▁= ▁1; ▁return ▁EST _ ERR _ NONE ; ▁# else ▁/* ▁* ▁If ▁the ▁EST ▁library ▁was ▁not ▁ built ▁with ▁support ▁for ▁libcurl ▁then ▁client ▁* ▁proxy ▁mode ▁is ▁not ▁supported . ▁*/ ▁EST _ LOG _ ERR (" Client ▁proxy ▁mode ▁requires ▁libest ▁to ▁be ▁ built ▁with ▁libcurl . "); ▁return ▁EST _ ERR _ CLIENT _ PROXY _ MODE _ NOT _ SUPPORTED ; ▁# endif ▁} ▁/* ! ▁@ br i ef ▁est _ client _ set _ sign _ digest () ▁is ▁called ▁by ▁the ▁application ▁layer ▁to ▁specify ▁the ▁hash ▁algorithm ▁used ▁to ▁sign ▁the ▁PKCS 10 ▁CSR ▁dur ing ▁the ▁enroll ▁operation . ▁It ▁must ▁be ▁called ▁after ▁est _ client _ init () ▁and ▁prior ▁to ▁is su ing ▁any ▁EST ▁commands . ▁@ param ▁ctx ▁ Pointer ▁to ▁EST ▁context ▁for ▁a ▁client ▁session ▁@ param ▁nid ▁This ▁is ▁the ▁NID ▁value ▁defined ▁in ▁the ▁OpenSSL ▁header ▁file ▁obj _ m a c . h ▁for ▁the ▁desired ▁digest ▁to ▁use ▁for ▁signing . ▁@ return ▁EST _ ERROR ▁EST _ ERR _ NONE ▁- ▁Success . ▁EST _ ERR _ NO _ CTX ▁- ▁NULL ▁value ▁passed ▁for ▁EST ▁context ▁EST _ ERR _ INVALID _ DIGEST ▁- ▁An ▁un supported ▁NID ▁was ▁provided . ▁libEST ▁support s ▁SHA 1, ▁SHA 224 , ▁SHA 256 , ▁SHA 384 , ▁and ▁SHA 512 ▁digest s . ▁SHA 256 ▁is ▁the ▁default ▁digest ▁to ▁use ▁for ▁signing . ▁There ' s ▁no ▁need ▁to ▁invoke ▁this ▁function ▁un less ▁another ▁digest ▁is ▁desired . ▁The ▁supported ▁NID ▁values ▁are : ▁NID _ sha 1 ▁NID _ sha 224 ▁NID _ sha 256 ▁NID _ sha 384 ▁NID _ sha 512 ▁*/ ▁EST _ ERROR ▁est _ client _ set _ sign _ digest ▁( EST _ CTX ▁* ctx , ▁int ▁nid ) ▁{ ▁if ▁(! ctx ) ▁{ ▁return ▁EST _ ERR _ NO _ CTX ; ▁} ▁switch ▁( nid ) ▁{ ▁case ▁NID _ sha 512 : ▁ctx -> signing _ digest ▁= ▁E VP _ sha 512 (); ▁break ; ▁case ▁NID _ sha 384 : ▁ctx -> signing _ digest ▁= ▁E VP _ sha 384 (); ▁break ; ▁case ▁NID _ sha 256 : ▁ctx -> signing _ digest ▁= ▁E VP _ sha 256 (); ▁break ; ▁case ▁NID _ sha 224 : ▁ctx -> signing _ digest ▁= ▁E VP _ sha 224 (); ▁break ; ▁case ▁NID _ sha 1 : ▁ctx -> signing _ digest ▁= ▁E VP _ sha 1 (); ▁break ; ▁default : ▁return ▁( EST _ ERR _ INVALID _ DIGEST ); ▁break ; ▁} ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ client _ copy _ retry _ after () ▁copie s ▁the ▁retry ▁after ▁value ▁stored ▁in ▁this ▁client ▁context . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁current ▁EST ▁context . ▁@ param ▁retry _ delay ▁ Pointer ▁to ▁the ▁integer ▁where ▁the ▁retry - after ▁delay ▁ se cs ▁value ▁is ▁copied . ▁If ▁the ▁server ▁sent ▁a ▁retry - after ▁in ▁delay ▁seconds ▁format ▁then ▁it ▁will ▁be ▁passed ▁here . ▁If ▁it ▁did ▁not , ▁then ▁this ▁value ▁will ▁be ▁zero . ▁@ param ▁retry _ time ▁ Pointer ▁to ▁the ▁time _ t ▁where ▁the ▁retry - after ▁time ▁date ▁value ▁is ▁copied . ▁If ▁the ▁server ▁sent ▁a ▁retry - after ▁in ▁time ▁and ▁date ▁string ▁format ▁then ▁this ▁string ▁is ▁convert ed ▁into ▁a ▁time _ t ▁value ▁and ▁passed ▁up ▁in ▁this ▁parameter . ▁This ▁value ▁will ▁only ▁be ▁set ▁if ▁the ▁server ▁sent ▁a ▁time ▁and ▁date ▁string ▁response , ▁otherwise , ▁this ▁value ▁is ▁set ▁to ▁zero . ▁@ return ▁EST _ ERROR ▁When ▁a ▁response ▁is ▁received ▁from ▁the ▁EST ▁server ▁the ▁headers ▁are ▁checked ▁to ▁see ▁if ▁the ▁server ▁has ▁included ▁a ▁Re try - After ▁header , ▁indicat ing ▁that ▁this ▁request ▁currently ▁cannot ▁be ▁processed . ▁If ▁a ▁Re try - After ▁HTTP ▁header ▁is ▁included ▁in ▁the ▁received ▁response ▁from ▁the ▁server ▁the ▁delay ▁value ▁is ▁saved ▁in ▁the ▁context ▁and ▁an ▁EST ▁error ▁code ▁is ▁given ▁to ▁the ▁application ▁on ▁this ▁request ▁indicat ing ▁that ▁the ▁client ▁must ▁retry ▁the ▁request ▁at ▁a ▁later ▁time . ▁The ▁value ▁specified ▁by ▁the ▁server ▁can ▁be ▁in ▁one ▁of ▁two ▁basic ▁format s , ▁a ▁string ▁version ▁of ▁a ▁integer ▁value ▁that ▁represents ▁the ▁number ▁of ▁seconds ▁the ▁client ▁must ▁wait ▁before ▁retry ing ▁the ▁request , ▁and ▁a ▁string ▁containing ▁a ▁date ▁and ▁time ▁when ▁the ▁client ▁can ▁retry ▁the ▁request . ▁The ▁date ▁and ▁time ▁string ▁can ▁be ▁in ▁any ▁format ▁specified ▁in ▁RFC ▁ 2616 . ▁If ▁the ▁second ▁delay ▁value ▁is ▁sent ▁it ▁is ▁convert ed ▁into ▁an ▁integer ▁and ▁saved ▁in ▁the ▁EST ▁context ▁and ▁if ▁the ▁date ▁time ▁string ▁value ▁is ▁sent ▁it ▁is ▁convert ed ▁into ▁a ▁time _ t ▁value ▁and ▁saved ▁into ▁the ▁EST ▁context . ▁The ▁application ▁must ▁then ▁call ▁est _ client _ copy _ retry _ after () ▁to ▁obtain ▁the ▁amount ▁of ▁time ▁to ▁wait ▁before ▁retry ing ▁the ▁request . ▁est _ client _ copy _ retry _ after () ▁copie s ▁the ▁current ▁retry - after ▁value ▁from ▁the ▁client ▁context ▁and ▁return s ▁it ▁to ▁the ▁application . ▁Only ▁one ▁of ▁the ▁two ▁return ▁values ▁will ▁be ▁set ▁with ▁a ▁non - zero ▁value . ▁NOTE : ▁The ▁processing ▁of ▁a ▁Re try - After ▁value ▁in ▁time / date ▁format ▁is ▁currently ▁not ▁supported . ▁The ▁EST ▁Client ▁will ▁al way s ▁return ▁only ▁a ▁retry ▁delay ▁value ▁in ▁seconds . ▁*/ ▁EST _ ERROR ▁est _ client _ copy _ retry _ after ▁( EST _ CTX ▁* ctx , ▁int ▁* retry _ delay , ▁time _ t ▁* retry _ time ) ▁{ ▁if ▁(! ctx ) ▁{ ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁if ▁(! ctx -> est _ client _ initialized ) ▁{ ▁return ▁EST _ ERR _ CLIENT _ NOT _ INITIALIZED ; ▁} ▁* retry _ delay ▁= ▁ctx -> retry _ after _ delay ; ▁ctx -> retry _ after _ delay ▁= ▁0; ▁* retry _ time ▁= ▁ctx -> retry _ after _ date ; ▁ctx -> retry _ after _ date ▁= ▁0; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ client _ force _ pop () ▁is ▁used ▁by ▁an ▁application ▁to ▁enable ▁the ▁p roof - of - possession ▁generation ▁at ▁the ▁EST ▁client . ▁This ▁proves ▁that ▁the ▁EST ▁client ▁that ▁sent ▁the ▁CSR ▁to ▁the ▁server / proxy ▁is ▁in ▁ possession ▁of ▁the ▁private ▁key ▁that ▁was ▁used ▁to ▁sign ▁the ▁CSR . ▁This ▁bind s ▁the ▁TLS ▁session ▁ID ▁to ▁the ▁CSR . ▁Note , ▁if ▁the ▁CSR ▁attributes ▁configured ▁on ▁the ▁server ▁require ▁PoP ▁checking , ▁then ▁there ▁is ▁no ▁need ▁to ▁call ▁this ▁function ▁to ▁enable ▁PoP . ▁The ▁PoP ▁will ▁be ▁enabled ▁automatically ▁under ▁this ▁scenario ▁when ▁the ▁CSR ▁attributes ▁are ▁requested ▁from ▁the ▁server / proxy . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁This ▁function ▁ma y ▁be ▁called ▁at ▁any ▁time . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ client _ force _ pop ▁( EST _ CTX ▁* ctx ) ▁{ ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁ctx -> client _ force _ pop ▁= ▁1; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ client _ un force _ pop () ▁is ▁used ▁by ▁an ▁application ▁to ▁disable ▁the ▁p roof - of - possession ▁generation ▁at ▁the ▁EST ▁client . ▁P lease ▁see ▁the ▁do c u me n ation ▁for ▁est _ client _ force _ pop () ▁for ▁more ▁information ▁on ▁the ▁p roof - of - possession ▁check . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁This ▁function ▁ma y ▁be ▁called ▁at ▁any ▁time . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ client _ un force _ pop ▁( EST _ CTX ▁* ctx ) ▁{ ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁ctx -> client _ force _ pop ▁= ▁0; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ client _ set _ read _ timeout () ▁is ▁used ▁by ▁an ▁application ▁to ▁set ▁timeout ▁value ▁of ▁read ▁operations . ▁ After ▁the ▁EST ▁client ▁send s ▁a ▁request ▁to ▁the ▁EST ▁server ▁it ▁will ▁attempt ▁to ▁read ▁the ▁response ▁from ▁the ▁server . ▁This ▁timeout ▁value ▁limit s ▁the ▁amount ▁of ▁time ▁the ▁client ▁will ▁wait ▁for ▁the ▁response . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁@ param ▁timeout ▁Integer ▁value ▁representing ▁the ▁read ▁timeout ▁in ▁seconds . ▁The ▁minimum ▁value ▁is ▁EST _ SSL _ READ _ TIMEOUT _ MIN ▁and ▁the ▁maximum ▁value ▁is ▁EST _ SSL _ READ _ TIMEOUT _ MAX . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ client _ set _ read _ timeout ▁( EST _ CTX ▁* ctx , ▁int ▁timeout ) ▁{ ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁if ▁( timeout ▁< ▁EST _ SSL _ READ _ TIMEOUT _ MIN ▁|| ▁timeout ▁> ▁EST _ SSL _ READ _ TIMEOUT _ MAX ) ▁{ ▁EST _ LOG _ ERR (" I nvalid ▁read ▁timeout ▁value ▁passed : ▁% d ▁" , ▁timeout ); ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁ctx -> read _ timeout ▁= ▁timeout ; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ client _ get _ last _ http _ status () ▁is ▁used ▁by ▁an ▁application ▁to ▁get ▁the ▁HTTP ▁status ▁code ▁returned ▁by ▁the ▁EST ▁server ▁for ▁the ▁most ▁recent ▁operation . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁This ▁can ▁be ▁called ▁after ▁an ▁EST ▁operation , ▁suc h ▁as ▁an ▁enroll ▁operation . ▁This ▁function ▁will ▁return ▁the ▁most ▁recent ▁HTTP ▁status ▁code ▁received ▁from ▁the ▁EST ▁server . ▁Normally , ▁a ▁status ▁of ▁200 ▁woul d ▁be ▁returned ▁by ▁the ▁EST ▁server ▁to ▁indicate ▁a ▁successful ▁operation . ▁How ever , ▁if ▁the ▁operation ▁failed ▁for ▁some ▁reason , ▁the ▁HTTP ▁status ▁code ▁ma y ▁be ▁useful ▁to ▁understand ▁the ▁reason ▁for ▁failure . ▁For ▁instance , ▁the ▁EST ▁server ▁woul d ▁return ▁a ▁HTTP ▁status ▁of ▁401 ▁if ▁the ▁EST ▁client ▁was ▁not ▁authorized . ▁P lease ▁see ▁RFC ▁ 2616 ▁for ▁a ▁description ▁of ▁the ▁vari ous ▁HTTP ▁status ▁codes . ▁@ return ▁int ▁value ▁representing ▁the ▁HTTP ▁status ▁code , ▁or ▁NULL ▁if ▁the ▁a ▁NULL ▁EST ▁context ▁was ▁provided . ▁*/ ▁int ▁est _ client _ get _ last _ http _ status ▁( EST _ CTX ▁* ctx ) ▁{ ▁if ▁( ctx ) ▁{ ▁return ▁ctx -> last _ http _ status ; ▁} ▁else ▁{ ▁return ▁0; ▁} ▁}